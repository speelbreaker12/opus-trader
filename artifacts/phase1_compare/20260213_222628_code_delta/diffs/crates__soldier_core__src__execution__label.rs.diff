diff --git a/tmp/phase1-code-delta-ygRu/opus/crates/soldier_core/src/execution/label.rs b/tmp/phase1-code-delta-ygRu/ralph/crates/soldier_core/src/execution/label.rs
index 75953d8..3f71607 100644
--- a/tmp/phase1-code-delta-ygRu/opus/crates/soldier_core/src/execution/label.rs
+++ b/tmp/phase1-code-delta-ygRu/ralph/crates/soldier_core/src/execution/label.rs
@@ -1,120 +1,230 @@
-//! Compact label schema per CONTRACT.md §1.1.
-//!
-//! Canonical outbound format: `s4:{sid8}:{gid12}:{li}:{ih16}`
-//!
-//! - `sid8` = first 8 chars of stable strategy id hash
-//! - `gid12` = first 12 chars of group_id (UUID without dashes, truncated)
-//! - `li` = leg_idx (0 or 1)
-//! - `ih16` = 16-hex intent hash
-//!
-//! Deribit constraint: label MUST be <= 64 chars.
-//! If a computed label would exceed 64 chars, reject with `LabelTooLong`.
-//! Truncation MUST NOT occur.
-
-/// Maximum label length per Deribit constraint.
-pub const LABEL_MAX_LEN: usize = 64;
-
-/// Input fields for encoding an s4 label.
-#[derive(Debug, Clone)]
-pub struct LabelInput<'a> {
-    /// First 8 chars of the strategy ID hash.
-    pub sid8: &'a str,
-    /// First 12 chars of the group_id (UUID without dashes).
-    pub gid12: &'a str,
-    /// Leg index within the group (0 or 1).
-    pub leg_idx: u32,
-    /// 16-hex intent hash string.
-    pub ih16: &'a str,
-}
+use crate::risk::RiskState;
+
+const LABEL_PREFIX: &str = "s4";
+const MAX_LABEL_LEN: usize = 64;
+const SID_LEN: usize = 8;
+const GID_LEN: usize = 12;
 
-/// Parsed components from a decoded s4 label.
 #[derive(Debug, Clone, PartialEq, Eq)]
-pub struct ParsedLabel {
-    /// Strategy ID hash prefix (8 chars).
+pub struct CompactLabelParts {
     pub sid8: String,
-    /// Group ID prefix (12 chars).
     pub gid12: String,
-    /// Leg index.
-    pub leg_idx: u32,
-    /// Intent hash prefix (16 hex chars).
+    pub leg_idx: u8,
     pub ih16: String,
 }
 
-/// Error returned when label encoding or decoding fails.
 #[derive(Debug, Clone, PartialEq, Eq)]
-pub enum LabelError {
-    /// CONTRACT.md: computed label exceeds 64 chars → reject, no truncation.
-    /// Caller MUST set `RiskState::Degraded`.
-    LabelTooLong {
-        /// The computed label length.
-        len: usize,
-    },
-    /// Label does not start with "s4:" prefix.
+pub enum LabelDecodeError {
     InvalidPrefix,
-    /// Label has wrong number of segments (expected 5).
-    WrongSegmentCount {
-        /// Actual number of segments found.
-        count: usize,
-    },
-    /// leg_idx segment is not a valid integer.
+    InvalidFormat,
     InvalidLegIdx,
 }
 
-/// Encode an s4 label from its components.
-///
-/// Format: `s4:{sid8}:{gid12}:{li}:{ih16}`
-///
-/// Returns `Err(LabelTooLong)` if the result exceeds 64 chars.
-/// Truncation MUST NOT occur (CONTRACT.md).
-pub fn encode_label(input: &LabelInput<'_>) -> Result<String, LabelError> {
-    let label = format!(
-        "s4:{}:{}:{}:{}",
-        input.sid8, input.gid12, input.leg_idx, input.ih16
-    );
-
-    if label.len() > LABEL_MAX_LEN {
-        return Err(LabelError::LabelTooLong { len: label.len() });
-    }
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum LabelRejectReason {
+    LabelTooLong,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub struct LabelEncodeReject {
+    pub risk_state: RiskState,
+    pub reason: LabelRejectReason,
+}
 
-    Ok(label)
+pub fn encode_compact_label(
+    strat_id: &str,
+    group_id: &str,
+    leg_idx: u8,
+    intent_hash: u64,
+) -> Result<String, LabelEncodeReject> {
+    let sid_full = hash_hex64(strat_id.as_bytes());
+    let sid8 = &sid_full[..SID_LEN.min(sid_full.len())];
+    let gid12 = compact_group_id(group_id);
+    let ih16 = format!("{:016x}", intent_hash);
+    encode_compact_label_with_hashes(sid8, &gid12, leg_idx, &ih16)
 }
 
-/// Decode (parse) an s4 label into its components.
-///
-/// Expected format: `s4:{sid8}:{gid12}:{li}:{ih16}`
-pub fn decode_label(label: &str) -> Result<ParsedLabel, LabelError> {
-    if !label.starts_with("s4:") {
-        return Err(LabelError::InvalidPrefix);
+pub fn encode_compact_label_with_hashes(
+    sid: &str,
+    gid12: &str,
+    leg_idx: u8,
+    ih: &str,
+) -> Result<String, LabelEncodeReject> {
+    let leg_str = leg_idx.to_string();
+    let total_len = label_len(sid, gid12, &leg_str, ih);
+    if total_len > MAX_LABEL_LEN {
+        return Err(LabelEncodeReject {
+            risk_state: RiskState::Degraded,
+            reason: LabelRejectReason::LabelTooLong,
+        });
     }
 
-    let parts: Vec<&str> = label.split(':').collect();
-    // Expected: ["s4", sid8, gid12, li, ih16]
-    if parts.len() != 5 {
-        return Err(LabelError::WrongSegmentCount { count: parts.len() });
+    Ok(format!(
+        "{}:{}:{}:{}:{}",
+        LABEL_PREFIX, sid, gid12, leg_str, ih
+    ))
+}
+
+pub fn decode_compact_label(label: &str) -> Result<CompactLabelParts, LabelDecodeError> {
+    let mut parts = label.split(':');
+    let prefix = parts.next().ok_or(LabelDecodeError::InvalidFormat)?;
+    if prefix != LABEL_PREFIX {
+        return Err(LabelDecodeError::InvalidPrefix);
+    }
+    let sid8 = parts.next().ok_or(LabelDecodeError::InvalidFormat)?;
+    let gid12 = parts.next().ok_or(LabelDecodeError::InvalidFormat)?;
+    let leg_idx_raw = parts.next().ok_or(LabelDecodeError::InvalidFormat)?;
+    let ih16 = parts.next().ok_or(LabelDecodeError::InvalidFormat)?;
+    if parts.next().is_some() {
+        return Err(LabelDecodeError::InvalidFormat);
     }
 
-    let leg_idx: u32 = parts[3].parse().map_err(|_| LabelError::InvalidLegIdx)?;
+    let leg_idx = leg_idx_raw
+        .parse::<u8>()
+        .map_err(|_| LabelDecodeError::InvalidLegIdx)?;
 
-    Ok(ParsedLabel {
-        sid8: parts[1].to_string(),
-        gid12: parts[2].to_string(),
+    Ok(CompactLabelParts {
+        sid8: sid8.to_string(),
+        gid12: gid12.to_string(),
         leg_idx,
-        ih16: parts[4].to_string(),
+        ih16: ih16.to_string(),
     })
 }
 
-/// Derive `sid8` from a strategy ID string.
-///
-/// Uses xxhash64 of the strategy ID, then takes the first 8 hex chars.
-pub fn derive_sid8(strat_id: &str) -> String {
-    let hash = xxhash_rust::xxh64::xxh64(strat_id.as_bytes(), 0);
-    format!("{hash:016x}")[..8].to_string()
+fn compact_group_id(group_id: &str) -> String {
+    let mut buf = String::with_capacity(GID_LEN);
+    for ch in group_id.chars() {
+        if ch == '-' {
+            continue;
+        }
+        if buf.len() >= GID_LEN {
+            break;
+        }
+        buf.push(ch);
+    }
+    buf
+}
+
+fn label_len(sid: &str, gid12: &str, leg_idx: &str, ih: &str) -> usize {
+    LABEL_PREFIX.len() + 4 + sid.len() + gid12.len() + leg_idx.len() + ih.len()
+}
+
+fn hash_hex64(input: &[u8]) -> String {
+    let hash = xxhash64(input);
+    format!("{:016x}", hash)
+}
+
+fn xxhash64(input: &[u8]) -> u64 {
+    const PRIME1: u64 = 11400714785074694791;
+    const PRIME2: u64 = 14029467366897019727;
+    const PRIME3: u64 = 1609587929392839161;
+    const PRIME4: u64 = 9650029242287828579;
+    const PRIME5: u64 = 2870177450012600261;
+
+    let len = input.len();
+    let mut index = 0usize;
+    let mut hash: u64;
+
+    if len >= 32 {
+        let mut v1 = PRIME1.wrapping_add(PRIME2);
+        let mut v2 = PRIME2;
+        let mut v3 = 0u64;
+        let mut v4 = 0u64.wrapping_sub(PRIME1);
+
+        while index + 32 <= len {
+            v1 = round(v1, read_u64_le(&input[index..index + 8]), PRIME1, PRIME2);
+            v2 = round(
+                v2,
+                read_u64_le(&input[index + 8..index + 16]),
+                PRIME1,
+                PRIME2,
+            );
+            v3 = round(
+                v3,
+                read_u64_le(&input[index + 16..index + 24]),
+                PRIME1,
+                PRIME2,
+            );
+            v4 = round(
+                v4,
+                read_u64_le(&input[index + 24..index + 32]),
+                PRIME1,
+                PRIME2,
+            );
+            index += 32;
+        }
+
+        hash = v1
+            .rotate_left(1)
+            .wrapping_add(v2.rotate_left(7))
+            .wrapping_add(v3.rotate_left(12))
+            .wrapping_add(v4.rotate_left(18));
+
+        hash = merge_round(hash, v1, PRIME1, PRIME4);
+        hash = merge_round(hash, v2, PRIME1, PRIME4);
+        hash = merge_round(hash, v3, PRIME1, PRIME4);
+        hash = merge_round(hash, v4, PRIME1, PRIME4);
+    } else {
+        hash = PRIME5;
+    }
+
+    hash = hash.wrapping_add(len as u64);
+
+    while index + 8 <= len {
+        let k1 = round(0, read_u64_le(&input[index..index + 8]), PRIME1, PRIME2);
+        hash ^= k1;
+        hash = hash
+            .rotate_left(27)
+            .wrapping_mul(PRIME1)
+            .wrapping_add(PRIME4);
+        index += 8;
+    }
+
+    if index + 4 <= len {
+        let k1 = read_u32_le(&input[index..index + 4]) as u64;
+        hash ^= k1.wrapping_mul(PRIME1);
+        hash = hash
+            .rotate_left(23)
+            .wrapping_mul(PRIME2)
+            .wrapping_add(PRIME3);
+        index += 4;
+    }
+
+    while index < len {
+        hash ^= (input[index] as u64).wrapping_mul(PRIME5);
+        hash = hash.rotate_left(11).wrapping_mul(PRIME1);
+        index += 1;
+    }
+
+    hash ^= hash >> 33;
+    hash = hash.wrapping_mul(PRIME2);
+    hash ^= hash >> 29;
+    hash = hash.wrapping_mul(PRIME3);
+    hash ^= hash >> 32;
+
+    hash
+}
+
+fn round(acc: u64, input: u64, prime1: u64, prime2: u64) -> u64 {
+    acc.wrapping_add(input.wrapping_mul(prime2))
+        .rotate_left(31)
+        .wrapping_mul(prime1)
+}
+
+fn merge_round(acc: u64, val: u64, prime1: u64, prime4: u64) -> u64 {
+    let mut acc = acc ^ round(0, val, prime1, prime4);
+    acc = acc.wrapping_mul(prime1).wrapping_add(prime4);
+    acc
+}
+
+fn read_u64_le(bytes: &[u8]) -> u64 {
+    let mut buf = [0u8; 8];
+    buf.copy_from_slice(&bytes[..8]);
+    u64::from_le_bytes(buf)
 }
 
-/// Derive `gid12` from a UUID group_id string.
-///
-/// Strips dashes from the UUID and takes the first 12 chars.
-pub fn derive_gid12(group_id: &str) -> String {
-    let no_dashes: String = group_id.chars().filter(|c| *c != '-').collect();
-    no_dashes[..12.min(no_dashes.len())].to_string()
+fn read_u32_le(bytes: &[u8]) -> u32 {
+    let mut buf = [0u8; 4];
+    buf.copy_from_slice(&bytes[..4]);
+    u32::from_le_bytes(buf)
 }
