diff --git a/tmp/phase1-code-delta-ygRu/opus/crates/soldier_core/src/execution/build_order_intent.rs b/tmp/phase1-code-delta-ygRu/ralph/crates/soldier_core/src/execution/build_order_intent.rs
index ccb79c0..5b1694a 100644
--- a/tmp/phase1-code-delta-ygRu/opus/crates/soldier_core/src/execution/build_order_intent.rs
+++ b/tmp/phase1-code-delta-ygRu/ralph/crates/soldier_core/src/execution/build_order_intent.rs
@@ -1,346 +1,353 @@
-//! Single chokepoint for order intent construction and gate ordering.
-//!
-//! CONTRACT.md CSP.5.2: All dispatch must route through `build_order_intent()`.
-//!
-//! **Gate ordering (deterministic):**
-//! 1. Dispatch authorization (RiskState check)
-//! 2. Preflight (order type validation)
-//! 3. Quantize
-//! 4. Dispatch consistency (AT-920 contracts/amount + quantity clamp validation)
-//! 5. Fee cache staleness check
-//! 6. Liquidity Gate (book-walk slippage)
-//! 7. Net Edge Gate (fee + slippage vs min_edge)
-//! 8. Pricer (IOC limit price clamping)
-//! 9. RecordedBeforeDispatch (WAL append)
-//!
-//! Only after all gates pass is an `OrderIntent` produced.
-
-use crate::risk::RiskState;
-
-// --- Intent class --------------------------------------------------------
-
-/// Intent classification for dispatch authorization.
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum ChokeIntentClass {
-    /// Risk-increasing intent -> requires all gates.
-    Open,
-    /// Risk-reducing order placement.
-    Close,
-    /// Hedge intent.
-    Hedge,
-    /// Cancel-only intent.
-    CancelOnly,
-}
+use std::cell::RefCell;
+use std::sync::Arc;
+use std::sync::atomic::{AtomicU64, Ordering};
+
+use crate::risk::{FeeModelSnapshot, FeeStalenessConfig, RiskState, evaluate_fee_staleness};
 
-// --- Gate step -----------------------------------------------------------
+use super::{
+    InstrumentQuantization, IntentClassification, L2BookSnapshot, LiquidityGateConfig,
+    LiquidityGateIntent, LiquidityGateRejectReason, NetEdgeGateIntent, NetEdgeRejectReason,
+    OrderIntent, OrderTypeGuardConfig, OrderTypeRejectReason, PreflightReject, PricerIntent,
+    QuantizeRejectReason, RejectReason, Side, evaluate_liquidity_gate, evaluate_net_edge_gate,
+    preflight, price_ioc_limit, quantize_steps,
+};
 
-/// Named gate steps for ordering trace.
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum GateStep {
-    DispatchAuth,
     Preflight,
     Quantize,
-    DispatchConsistency,
-    FeeCacheCheck,
+    FeeCache,
     LiquidityGate,
     NetEdgeGate,
     Pricer,
-    RecordedBeforeDispatch,
 }
 
-// --- Chokepoint result ---------------------------------------------------
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum DispatchStep {
+    RecordIntent,
+    DispatchAttempt,
+}
 
-/// Reject reason from the chokepoint.
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum ChokeRejectReason {
-    /// RiskState is not Healthy -> OPEN blocked.
-    RiskStateNotHealthy,
-    /// A gate rejected the intent (gate name + reason string).
-    GateRejected { gate: GateStep, reason: String },
+#[derive(Debug, Clone, PartialEq)]
+pub enum BuildOrderIntentOutcome {
+    Allowed,
+    Rejected(BuildOrderIntentRejectReason),
 }
 
-/// Result of the chokepoint evaluation.
 #[derive(Debug, Clone, PartialEq)]
-pub enum ChokeResult {
-    /// All gates passed -> OrderIntent is ready for dispatch.
-    Approved {
-        /// Ordered list of gates that were executed.
-        gate_trace: Vec<GateStep>,
-    },
-    /// Intent was rejected at a specific gate.
-    Rejected {
-        /// Rejection reason.
-        reason: ChokeRejectReason,
-        /// Gates executed before rejection (for audit).
-        gate_trace: Vec<GateStep>,
-    },
+pub enum BuildOrderIntentRejectReason {
+    Preflight(OrderTypeRejectReason),
+    MissingContext,
+    Quantize(QuantizeRejectReason),
+    DispatchAuth(RiskState),
+    LiquidityGate(LiquidityGateRejectReason),
+    NetEdge(NetEdgeRejectReason),
+    Pricer(RejectReason),
+    RecordedBeforeDispatch,
 }
 
-// --- Metrics -------------------------------------------------------------
-
-/// Observability metrics for the chokepoint.
-#[derive(Debug)]
-pub struct ChokeMetrics {
-    /// Total intents approved.
-    approved_total: u64,
-    /// Total intents rejected.
-    rejected_total: u64,
-    /// Rejections due to risk state.
-    rejected_risk_state: u64,
+#[derive(Debug, Clone, PartialEq)]
+pub enum BuildOrderIntentError {
+    Preflight(PreflightReject),
+    Rejected(BuildOrderIntentRejectReason),
 }
 
-impl ChokeMetrics {
-    /// Create a new metrics tracker.
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum GateSequenceResult {
+    Allowed,
+    Rejected,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum RecordIntentOutcome {
+    Recorded,
+    Failed,
+}
+
+#[derive(Debug, Clone)]
+pub struct BuildOrderIntentObservers {
+    pub recorded_total: Arc<AtomicU64>,
+    pub dispatch_total: Arc<AtomicU64>,
+}
+
+impl BuildOrderIntentObservers {
     pub fn new() -> Self {
         Self {
-            approved_total: 0,
-            rejected_total: 0,
-            rejected_risk_state: 0,
+            recorded_total: Arc::new(AtomicU64::new(0)),
+            dispatch_total: Arc::new(AtomicU64::new(0)),
         }
     }
 
-    fn record_approved(&mut self) {
-        self.approved_total += 1;
+    fn record_intent(&self) {
+        self.recorded_total.fetch_add(1, Ordering::Relaxed);
     }
 
-    fn record_rejected(&mut self) {
-        self.rejected_total += 1;
+    fn record_dispatch(&self) {
+        self.dispatch_total.fetch_add(1, Ordering::Relaxed);
     }
+}
 
-    fn record_rejected_risk_state(&mut self) {
-        self.rejected_risk_state += 1;
+impl Default for BuildOrderIntentObservers {
+    fn default() -> Self {
+        Self::new()
     }
+}
 
-    pub fn approved_total(&self) -> u64 {
-        self.approved_total
-    }
+#[derive(Debug, Clone)]
+pub struct BuildOrderIntentContext {
+    pub classification: IntentClassification,
+    pub side: Side,
+    pub raw_qty: f64,
+    pub raw_limit_price: f64,
+    pub quantization: InstrumentQuantization,
+    pub fee_model: FeeModelSnapshot,
+    pub fee_staleness_config: FeeStalenessConfig,
+    pub is_maker: bool,
+    pub l2_snapshot: Option<L2BookSnapshot>,
+    pub liquidity_config: LiquidityGateConfig,
+    pub now_ms: u64,
+    pub gross_edge_usd: f64,
+    pub min_edge_usd: f64,
+    pub fair_price: f64,
+    pub risk_state: RiskState,
+    pub record_outcome: RecordIntentOutcome,
+    pub observers: Option<BuildOrderIntentObservers>,
+}
 
-    pub fn rejected_total(&self) -> u64 {
-        self.rejected_total
-    }
+static GATE_SEQUENCE_ALLOWED_TOTAL: AtomicU64 = AtomicU64::new(0);
+static GATE_SEQUENCE_REJECTED_TOTAL: AtomicU64 = AtomicU64::new(0);
 
-    pub fn rejected_risk_state(&self) -> u64 {
-        self.rejected_risk_state
-    }
+thread_local! {
+    static BUILD_CONTEXT: RefCell<Option<BuildOrderIntentContext>> = const { RefCell::new(None) };
+    static GATE_SEQUENCE_TRACE: RefCell<Vec<GateStep>> = const { RefCell::new(Vec::new()) };
+    static DISPATCH_TRACE: RefCell<Vec<DispatchStep>> = const { RefCell::new(Vec::new()) };
+    static LAST_OUTCOME: RefCell<Option<BuildOrderIntentOutcome>> = const { RefCell::new(None) };
 }
 
-impl Default for ChokeMetrics {
-    fn default() -> Self {
-        Self::new()
-    }
+pub fn with_build_order_intent_context<F, R>(context: BuildOrderIntentContext, f: F) -> R
+where
+    F: FnOnce() -> R,
+{
+    BUILD_CONTEXT.with(|cell| {
+        let previous = cell.borrow_mut().replace(context);
+        let result = f();
+        *cell.borrow_mut() = previous;
+        result
+    })
 }
 
-// --- Chokepoint evaluator ------------------------------------------------
+pub fn take_gate_sequence_trace() -> Vec<GateStep> {
+    GATE_SEQUENCE_TRACE.with(|trace| trace.borrow_mut().drain(..).collect())
+}
 
-/// Build an order intent through the single chokepoint.
-///
-/// This is the ONLY entry point for OrderIntent construction.
-/// All gates run in deterministic order. OPEN intents require all gates;
-/// CLOSE/HEDGE/CANCEL skip some gates but still flow through the chokepoint.
-///
-/// Returns `ChokeResult::Approved` with the gate trace if all pass,
-/// or `ChokeResult::Rejected` with the failing gate.
-pub fn build_order_intent(
-    intent_class: ChokeIntentClass,
-    risk_state: RiskState,
-    metrics: &mut ChokeMetrics,
-    gate_results: &GateResults,
-) -> ChokeResult {
-    let mut trace = Vec::new();
-
-    // Gate 1: Dispatch authorization (RiskState check)
-    trace.push(GateStep::DispatchAuth);
-    if intent_class == ChokeIntentClass::Open && risk_state != RiskState::Healthy {
-        metrics.record_rejected();
-        metrics.record_rejected_risk_state();
-        return ChokeResult::Rejected {
-            reason: ChokeRejectReason::RiskStateNotHealthy,
-            gate_trace: trace,
-        };
-    }
+pub fn take_dispatch_trace() -> Vec<DispatchStep> {
+    DISPATCH_TRACE.with(|trace| trace.borrow_mut().drain(..).collect())
+}
 
-    // CANCEL-only intents skip remaining gates.
-    if intent_class == ChokeIntentClass::CancelOnly {
-        metrics.record_approved();
-        return ChokeResult::Approved { gate_trace: trace };
-    }
+pub fn take_build_order_intent_outcome() -> Option<BuildOrderIntentOutcome> {
+    LAST_OUTCOME.with(|cell| cell.borrow_mut().take())
+}
 
-    // Gate 2: Preflight
-    trace.push(GateStep::Preflight);
-    if !gate_results.preflight_passed {
-        metrics.record_rejected();
-        return ChokeResult::Rejected {
-            reason: ChokeRejectReason::GateRejected {
-                gate: GateStep::Preflight,
-                reason: "preflight rejected".to_string(),
-            },
-            gate_trace: trace,
-        };
+pub fn gate_sequence_total(result: GateSequenceResult) -> u64 {
+    match result {
+        GateSequenceResult::Allowed => GATE_SEQUENCE_ALLOWED_TOTAL.load(Ordering::Relaxed),
+        GateSequenceResult::Rejected => GATE_SEQUENCE_REJECTED_TOTAL.load(Ordering::Relaxed),
     }
+}
 
-    // Gate 3: Quantize
-    trace.push(GateStep::Quantize);
-    if !gate_results.quantize_passed {
-        metrics.record_rejected();
-        return ChokeResult::Rejected {
-            reason: ChokeRejectReason::GateRejected {
-                gate: GateStep::Quantize,
-                reason: "quantize failed".to_string(),
-            },
-            gate_trace: trace,
-        };
-    }
+fn reset_trace() {
+    GATE_SEQUENCE_TRACE.with(|trace| trace.borrow_mut().clear());
+    DISPATCH_TRACE.with(|trace| trace.borrow_mut().clear());
+    LAST_OUTCOME.with(|cell| cell.borrow_mut().take());
+    super::clear_execution_metric_lines();
+}
 
-    // Gate 4: Dispatch consistency (AT-920 contracts/amount validation)
-    trace.push(GateStep::DispatchConsistency);
-    if !gate_results.dispatch_consistency_passed {
-        metrics.record_rejected();
-        return ChokeResult::Rejected {
-            reason: ChokeRejectReason::GateRejected {
-                gate: GateStep::DispatchConsistency,
-                reason: "dispatch consistency failed".to_string(),
-            },
-            gate_trace: trace,
-        };
-    }
+fn record_gate_step(step: GateStep) {
+    GATE_SEQUENCE_TRACE.with(|trace| trace.borrow_mut().push(step));
+}
 
-    // Anti-bypass clamp check: when liquidity clamp metadata is provided,
-    // dispatch qty must never exceed the gate-approved max.
-    match (gate_results.requested_qty, gate_results.max_dispatch_qty) {
-        (None, None) => {}
-        (Some(requested_qty), Some(max_dispatch_qty)) => {
-            let invalid_requested = !requested_qty.is_finite() || requested_qty <= 0.0;
-            let invalid_max = !max_dispatch_qty.is_finite() || max_dispatch_qty <= 0.0;
-            if invalid_requested || invalid_max || requested_qty > max_dispatch_qty + 1e-12 {
-                metrics.record_rejected();
-                return ChokeResult::Rejected {
-                    reason: ChokeRejectReason::GateRejected {
-                        gate: GateStep::DispatchConsistency,
-                        reason: "requested qty exceeds liquidity clamp".to_string(),
-                    },
-                    gate_trace: trace,
-                };
-            }
+fn record_dispatch_step(step: DispatchStep) {
+    DISPATCH_TRACE.with(|trace| trace.borrow_mut().push(step));
+}
+
+fn finish_outcome(outcome: BuildOrderIntentOutcome) {
+    match outcome {
+        BuildOrderIntentOutcome::Allowed => {
+            GATE_SEQUENCE_ALLOWED_TOTAL.fetch_add(1, Ordering::Relaxed);
+            super::emit_execution_metric_line("gate_sequence_total", "result=allowed");
         }
-        _ => {
-            metrics.record_rejected();
-            return ChokeResult::Rejected {
-                reason: ChokeRejectReason::GateRejected {
-                    gate: GateStep::DispatchConsistency,
-                    reason: "incomplete liquidity clamp metadata".to_string(),
-                },
-                gate_trace: trace,
-            };
+        BuildOrderIntentOutcome::Rejected(_) => {
+            GATE_SEQUENCE_REJECTED_TOTAL.fetch_add(1, Ordering::Relaxed);
+            super::emit_execution_metric_line("gate_sequence_total", "result=rejected");
         }
     }
+    LAST_OUTCOME.with(|cell| {
+        *cell.borrow_mut() = Some(outcome);
+    });
+}
 
-    // Gate 5: Fee cache staleness
-    trace.push(GateStep::FeeCacheCheck);
-    if !gate_results.fee_cache_passed {
-        metrics.record_rejected();
-        return ChokeResult::Rejected {
-            reason: ChokeRejectReason::GateRejected {
-                gate: GateStep::FeeCacheCheck,
-                reason: "fee cache stale".to_string(),
-            },
-            gate_trace: trace,
-        };
+fn effective_risk_state(primary: RiskState, fallback: RiskState) -> RiskState {
+    if primary != RiskState::Healthy {
+        return primary;
     }
+    fallback
+}
 
-    // Gates 6-8 only for OPEN intents.
-    if intent_class == ChokeIntentClass::Open {
-        // Gate 6: Liquidity Gate
-        trace.push(GateStep::LiquidityGate);
-        if !gate_results.liquidity_gate_passed {
-            metrics.record_rejected();
-            return ChokeResult::Rejected {
-                reason: ChokeRejectReason::GateRejected {
-                    gate: GateStep::LiquidityGate,
-                    reason: "liquidity gate rejected".to_string(),
-                },
-                gate_trace: trace,
-            };
-        }
-
-        // Gate 7: Net Edge Gate
-        trace.push(GateStep::NetEdgeGate);
-        if !gate_results.net_edge_passed {
-            metrics.record_rejected();
-            return ChokeResult::Rejected {
-                reason: ChokeRejectReason::GateRejected {
-                    gate: GateStep::NetEdgeGate,
-                    reason: "net edge too low".to_string(),
-                },
-                gate_trace: trace,
-            };
-        }
-
-        // Gate 8: Pricer
-        trace.push(GateStep::Pricer);
-        if !gate_results.pricer_passed {
-            metrics.record_rejected();
-            return ChokeResult::Rejected {
-                reason: ChokeRejectReason::GateRejected {
-                    gate: GateStep::Pricer,
-                    reason: "pricer rejected".to_string(),
-                },
-                gate_trace: trace,
-            };
-        }
+fn fee_rate_for_model(model: &FeeModelSnapshot, is_maker: bool) -> f64 {
+    if is_maker {
+        model.maker_fee_rate
+    } else {
+        model.taker_fee_rate
     }
+}
 
-    // Gate 9: RecordedBeforeDispatch
-    trace.push(GateStep::RecordedBeforeDispatch);
-    if !gate_results.wal_recorded {
-        metrics.record_rejected();
-        return ChokeResult::Rejected {
-            reason: ChokeRejectReason::GateRejected {
-                gate: GateStep::RecordedBeforeDispatch,
-                reason: "WAL append failed".to_string(),
-            },
-            gate_trace: trace,
-        };
+fn estimate_notional_usd(fair_price: f64, qty: f64) -> f64 {
+    fair_price.abs() * qty.abs()
+}
+
+fn estimate_slippage_usd(slippage_bps: Option<f64>, notional_usd: f64) -> f64 {
+    match slippage_bps {
+        Some(bps) => (bps / 10_000.0) * notional_usd,
+        None => 0.0,
     }
+}
 
-    metrics.record_approved();
-    ChokeResult::Approved { gate_trace: trace }
+fn finish_reject(reason: BuildOrderIntentRejectReason) {
+    finish_outcome(BuildOrderIntentOutcome::Rejected(reason));
 }
 
-// --- Gate results (pre-computed by caller) ------------------------------
+fn finish_allowed() {
+    finish_outcome(BuildOrderIntentOutcome::Allowed);
+}
 
-/// Pre-computed gate results passed to the chokepoint.
-///
-/// Each gate is evaluated independently before calling `build_order_intent`.
-/// The chokepoint enforces ordering and early-exit semantics.
-#[derive(Debug, Clone)]
-pub struct GateResults {
-    pub preflight_passed: bool,
-    pub quantize_passed: bool,
-    pub dispatch_consistency_passed: bool,
-    pub fee_cache_passed: bool,
-    pub liquidity_gate_passed: bool,
-    pub net_edge_passed: bool,
-    pub pricer_passed: bool,
-    pub wal_recorded: bool,
-    /// Caller-provided requested dispatch quantity.
-    pub requested_qty: Option<f64>,
-    /// Caller-provided max allowed quantity from upstream liquidity clamp.
-    pub max_dispatch_qty: Option<f64>,
+fn reject_with_error(reason: BuildOrderIntentRejectReason) -> BuildOrderIntentError {
+    finish_reject(reason.clone());
+    BuildOrderIntentError::Rejected(reason)
 }
 
-impl Default for GateResults {
-    fn default() -> Self {
-        Self {
-            preflight_passed: true,
-            quantize_passed: true,
-            dispatch_consistency_passed: true,
-            fee_cache_passed: true,
-            liquidity_gate_passed: true,
-            net_edge_passed: true,
-            pricer_passed: true,
-            wal_recorded: true,
-            requested_qty: None,
-            max_dispatch_qty: None,
+/// build_order_intent runs the deterministic gate sequence and records the outcome via
+/// take_build_order_intent_outcome().
+pub fn build_order_intent(
+    intent: OrderIntent,
+    config: OrderTypeGuardConfig,
+) -> Result<OrderIntent, BuildOrderIntentError> {
+    reset_trace();
+    record_gate_step(GateStep::Preflight);
+    let intent = match preflight::build_order_intent(intent, config) {
+        Ok(intent) => intent,
+        Err(err) => {
+            finish_reject(BuildOrderIntentRejectReason::Preflight(err.reason));
+            return Err(BuildOrderIntentError::Preflight(err));
         }
+    };
+
+    let context = BUILD_CONTEXT.with(|cell| cell.borrow().clone());
+    let context = match context {
+        Some(context) => context,
+        None => {
+            return Err(reject_with_error(
+                BuildOrderIntentRejectReason::MissingContext,
+            ));
+        }
+    };
+
+    record_gate_step(GateStep::Quantize);
+    let quantized = match quantize_steps(
+        context.side,
+        context.raw_qty,
+        context.raw_limit_price,
+        &context.quantization,
+    ) {
+        Ok(quantized) => quantized,
+        Err(err) => {
+            return Err(reject_with_error(BuildOrderIntentRejectReason::Quantize(
+                err.reason,
+            )));
+        }
+    };
+
+    record_gate_step(GateStep::FeeCache);
+    let fee_rate = fee_rate_for_model(&context.fee_model, context.is_maker);
+    let fee_decision = evaluate_fee_staleness(
+        fee_rate,
+        context.now_ms,
+        context.fee_model.fee_model_cached_at_ts_ms,
+        context.fee_staleness_config,
+    );
+    let combined_risk_state = effective_risk_state(context.risk_state, fee_decision.risk_state);
+    if context.classification == IntentClassification::Open
+        && combined_risk_state != RiskState::Healthy
+    {
+        return Err(reject_with_error(
+            BuildOrderIntentRejectReason::DispatchAuth(combined_risk_state),
+        ));
+    }
+
+    record_gate_step(GateStep::LiquidityGate);
+    let liquidity_intent = LiquidityGateIntent {
+        classification: context.classification,
+        side: context.side,
+        order_qty: quantized.qty_q,
+        l2_snapshot: context.l2_snapshot.as_ref(),
+        now_ms: context.now_ms,
+    };
+    let liquidity_outcome =
+        match evaluate_liquidity_gate(&liquidity_intent, context.liquidity_config) {
+            Ok(outcome) => outcome,
+            Err(err) => {
+                return Err(reject_with_error(
+                    BuildOrderIntentRejectReason::LiquidityGate(err.reason),
+                ));
+            }
+        };
+
+    record_gate_step(GateStep::NetEdgeGate);
+    let notional_usd = estimate_notional_usd(context.fair_price, quantized.qty_q);
+    let expected_slippage_usd = estimate_slippage_usd(liquidity_outcome.slippage_bps, notional_usd);
+    let fee_estimate_usd = fee_decision.fee_rate_effective * notional_usd;
+    let net_edge_intent = NetEdgeGateIntent {
+        classification: context.classification,
+        gross_edge_usd: Some(context.gross_edge_usd),
+        fee_usd: Some(fee_estimate_usd),
+        expected_slippage_usd: Some(expected_slippage_usd),
+        min_edge_usd: Some(context.min_edge_usd),
+    };
+    if let Err(err) = evaluate_net_edge_gate(&net_edge_intent) {
+        return Err(reject_with_error(BuildOrderIntentRejectReason::NetEdge(
+            err.reason,
+        )));
+    }
+
+    record_gate_step(GateStep::Pricer);
+    let pricer_intent = PricerIntent {
+        side: context.side,
+        fair_price: context.fair_price,
+        gross_edge_usd: context.gross_edge_usd,
+        fee_estimate_usd,
+        min_edge_usd: context.min_edge_usd,
+        qty: quantized.qty_q,
+    };
+    if let Err(err) = price_ioc_limit(&pricer_intent) {
+        return Err(reject_with_error(BuildOrderIntentRejectReason::Pricer(
+            err.reason,
+        )));
+    }
+
+    record_dispatch_step(DispatchStep::RecordIntent);
+    if let Some(observers) = context.observers.as_ref() {
+        observers.record_intent();
+    }
+    if context.record_outcome == RecordIntentOutcome::Failed {
+        return Err(reject_with_error(
+            BuildOrderIntentRejectReason::RecordedBeforeDispatch,
+        ));
     }
+
+    record_dispatch_step(DispatchStep::DispatchAttempt);
+    if let Some(observers) = context.observers.as_ref() {
+        observers.record_dispatch();
+    }
+
+    finish_allowed();
+    Ok(intent)
 }
