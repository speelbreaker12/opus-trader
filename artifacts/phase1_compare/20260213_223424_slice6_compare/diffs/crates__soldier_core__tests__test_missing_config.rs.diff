diff --git a/tmp/slice6-compare-wOA1/opus/crates/soldier_core/tests/test_missing_config.rs b/tmp/slice6-compare-wOA1/ralph/crates/soldier_core/tests/test_missing_config.rs
index e1d2af6..ad8cb2f 100644
--- a/tmp/slice6-compare-wOA1/opus/crates/soldier_core/tests/test_missing_config.rs
+++ b/tmp/slice6-compare-wOA1/ralph/crates/soldier_core/tests/test_missing_config.rs
@@ -1,388 +1,261 @@
-//! CI test proving missing critical config causes fail-closed rejection.
-//!
-//! CONTRACT.md Appendix A: Safety-Critical Thresholds.
-//! Missing or invalid config MUST cause rejection with an enumerated
-//! reason code — never silently default to an unsafe value.
+use std::collections::BTreeMap;
+use std::path::{Path, PathBuf};
+use std::process::Command;
+use std::sync::atomic::Ordering;
 
 use soldier_core::execution::{
-    ChokeIntentClass, ChokeMetrics, ChokeRejectReason, ChokeResult, GateResults, build_order_intent,
+    BuildOrderIntentContext, BuildOrderIntentObservers, BuildOrderIntentOutcome,
+    BuildOrderIntentRejectReason, InstrumentQuantization, IntentClassification, L2BookLevel,
+    L2BookSnapshot, LiquidityGateConfig, LiquidityGateRejectReason, NetEdgeRejectReason,
+    OrderIntent, OrderType, OrderTypeGuardConfig, QuantizeRejectReason, RecordIntentOutcome, Side,
+    build_order_intent, take_build_order_intent_outcome, take_dispatch_trace,
+    with_build_order_intent_context,
 };
-use soldier_core::execution::{
-    GateIntentClass, LiquidityGateInput, LiquidityGateMetrics, LiquidityGateRejectReason,
-    LiquidityGateResult, evaluate_liquidity_gate,
-};
-use soldier_core::execution::{
-    NetEdgeInput, NetEdgeMetrics, NetEdgeRejectReason, NetEdgeResult, evaluate_net_edge,
-};
-use soldier_core::execution::{
-    PricerInput, PricerMetrics, PricerRejectReason, PricerResult, PricerSide, compute_limit_price,
-};
-use soldier_core::execution::{
-    QuantizeConstraints, QuantizeError, QuantizeMetrics, Side, quantize,
-};
-use soldier_core::risk::RiskState;
-
-// ─── Missing quantize constraints ────────────────────────────────────────
-
-#[test]
-fn test_missing_tick_size_fails_closed() {
-    let mut m = QuantizeMetrics::new();
-    let constraints = QuantizeConstraints {
-        tick_size: 0.0, // invalid — zero
-        amount_step: 0.1,
-        min_amount: 0.1,
-    };
-
-    let result = quantize(1.0, 100.0, Side::Buy, &constraints, &mut m);
+use soldier_core::risk::{FeeModelSnapshot, FeeStalenessConfig, RiskState};
+use soldier_core::venue::InstrumentKind;
+
+const CONFIG_MISSING_REASON: &str = "CONFIG_MISSING";
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
+enum CriticalKey {
+    InstrumentTickSize,
+    InstrumentAmountStep,
+    InstrumentMinAmount,
+    L2BookSnapshot,
+    FeeModelCachedAtTsMs,
+    NetEdgeMinUsd,
+}
 
-    match result {
-        Err(QuantizeError::InstrumentMetadataMissing { field }) => {
-            assert_eq!(field, "tick_size", "Rejection must name the missing field");
+impl CriticalKey {
+    fn as_str(self) -> &'static str {
+        match self {
+            CriticalKey::InstrumentTickSize => "INSTRUMENT_TICK_SIZE",
+            CriticalKey::InstrumentAmountStep => "INSTRUMENT_AMOUNT_STEP",
+            CriticalKey::InstrumentMinAmount => "INSTRUMENT_MIN_AMOUNT",
+            CriticalKey::L2BookSnapshot => "L2_BOOK_SNAPSHOT",
+            CriticalKey::FeeModelCachedAtTsMs => "FEE_MODEL_CACHED_AT_TS_MS",
+            CriticalKey::NetEdgeMinUsd => "NET_EDGE_MIN_USD",
         }
-        other => panic!("expected InstrumentMetadataMissing, got {other:?}"),
     }
 }
 
-#[test]
-fn test_missing_amount_step_fails_closed() {
-    let mut m = QuantizeMetrics::new();
-    let constraints = QuantizeConstraints {
-        tick_size: 0.5,
-        amount_step: 0.0, // invalid — zero
-        min_amount: 0.1,
-    };
-
-    let result = quantize(1.0, 100.0, Side::Buy, &constraints, &mut m);
+struct MissingCase {
+    key: CriticalKey,
+    apply: fn(BuildOrderIntentContext) -> BuildOrderIntentContext,
+    expected: BuildOrderIntentRejectReason,
+}
 
-    match result {
-        Err(QuantizeError::InstrumentMetadataMissing { field }) => {
-            assert_eq!(field, "amount_step");
-        }
-        other => panic!("expected InstrumentMetadataMissing, got {other:?}"),
+fn base_intent() -> OrderIntent {
+    OrderIntent {
+        instrument_kind: InstrumentKind::Perpetual,
+        order_type: OrderType::Limit,
+        trigger: None,
+        trigger_price: None,
+        linked_order_type: None,
     }
 }
 
-#[test]
-fn test_nan_tick_size_fails_closed() {
-    let mut m = QuantizeMetrics::new();
-    let constraints = QuantizeConstraints {
-        tick_size: f64::NAN,
-        amount_step: 0.1,
-        min_amount: 0.1,
-    };
-
-    let result = quantize(1.0, 100.0, Side::Buy, &constraints, &mut m);
-
-    assert!(
-        matches!(result, Err(QuantizeError::InstrumentMetadataMissing { .. })),
-        "NaN tick_size must fail-closed"
-    );
+fn sample_book(now_ms: u64) -> L2BookSnapshot {
+    L2BookSnapshot {
+        bids: vec![L2BookLevel {
+            price: 99.5,
+            qty: 10.0,
+        }],
+        asks: vec![L2BookLevel {
+            price: 100.0,
+            qty: 10.0,
+        }],
+        ts_ms: now_ms,
+    }
 }
 
-#[test]
-fn test_infinity_amount_step_fails_closed() {
-    let mut m = QuantizeMetrics::new();
-    let constraints = QuantizeConstraints {
-        tick_size: 0.5,
-        amount_step: f64::INFINITY,
-        min_amount: 0.1,
-    };
-
-    let result = quantize(1.0, 100.0, Side::Buy, &constraints, &mut m);
-
-    assert!(
-        matches!(result, Err(QuantizeError::InstrumentMetadataMissing { .. })),
-        "Infinity amount_step must fail-closed"
-    );
+fn base_context(observers: BuildOrderIntentObservers) -> BuildOrderIntentContext {
+    let now_ms = 1_000;
+    BuildOrderIntentContext {
+        classification: IntentClassification::Open,
+        side: Side::Buy,
+        raw_qty: 1.2,
+        raw_limit_price: 100.1,
+        quantization: InstrumentQuantization {
+            tick_size: 0.5,
+            amount_step: 0.1,
+            min_amount: 0.1,
+        },
+        fee_model: FeeModelSnapshot {
+            fee_tier: 1,
+            maker_fee_rate: 0.0002,
+            taker_fee_rate: 0.0005,
+            fee_model_cached_at_ts_ms: Some(now_ms),
+        },
+        fee_staleness_config: FeeStalenessConfig::default(),
+        is_maker: false,
+        l2_snapshot: Some(sample_book(now_ms)),
+        liquidity_config: LiquidityGateConfig::default(),
+        now_ms,
+        gross_edge_usd: 10.0,
+        min_edge_usd: 1.0,
+        fair_price: 100.0,
+        risk_state: RiskState::Healthy,
+        record_outcome: RecordIntentOutcome::Recorded,
+        observers: Some(observers),
+    }
 }
 
-#[test]
-fn test_negative_tick_size_fails_closed() {
-    let mut m = QuantizeMetrics::new();
-    let constraints = QuantizeConstraints {
-        tick_size: -0.5,
-        amount_step: 0.1,
-        min_amount: 0.1,
-    };
-
-    let result = quantize(1.0, 100.0, Side::Buy, &constraints, &mut m);
-
-    assert!(
-        matches!(result, Err(QuantizeError::InstrumentMetadataMissing { .. })),
-        "Negative tick_size must fail-closed"
-    );
+fn missing_tick_size(mut context: BuildOrderIntentContext) -> BuildOrderIntentContext {
+    context.quantization.tick_size = 0.0;
+    context
 }
 
-// ─── Missing net edge inputs (fail-closed) ───────────────────────────────
-
-#[test]
-fn test_missing_gross_edge_fails_closed() {
-    let mut m = NetEdgeMetrics::new();
-    let input = NetEdgeInput {
-        gross_edge_usd: None, // missing
-        fee_usd: Some(3.0),
-        expected_slippage_usd: Some(1.0),
-        min_edge_usd: Some(2.0),
-    };
-
-    let result = evaluate_net_edge(&input, &mut m);
-
-    assert!(
-        matches!(
-            result,
-            NetEdgeResult::Rejected {
-                reason: NetEdgeRejectReason::NetEdgeInputMissing,
-                ..
-            }
-        ),
-        "Missing gross_edge must fail-closed with NetEdgeInputMissing"
-    );
+fn missing_amount_step(mut context: BuildOrderIntentContext) -> BuildOrderIntentContext {
+    context.quantization.amount_step = 0.0;
+    context
 }
 
-#[test]
-fn test_missing_fee_usd_fails_closed() {
-    let mut m = NetEdgeMetrics::new();
-    let input = NetEdgeInput {
-        gross_edge_usd: Some(10.0),
-        fee_usd: None, // missing
-        expected_slippage_usd: Some(1.0),
-        min_edge_usd: Some(2.0),
-    };
-
-    let result = evaluate_net_edge(&input, &mut m);
-
-    assert!(matches!(
-        result,
-        NetEdgeResult::Rejected {
-            reason: NetEdgeRejectReason::NetEdgeInputMissing,
-            ..
-        }
-    ));
+fn missing_min_amount(mut context: BuildOrderIntentContext) -> BuildOrderIntentContext {
+    context.quantization.min_amount = -1.0;
+    context
 }
 
-#[test]
-fn test_missing_slippage_fails_closed() {
-    let mut m = NetEdgeMetrics::new();
-    let input = NetEdgeInput {
-        gross_edge_usd: Some(10.0),
-        fee_usd: Some(3.0),
-        expected_slippage_usd: None, // missing
-        min_edge_usd: Some(2.0),
-    };
-
-    let result = evaluate_net_edge(&input, &mut m);
-
-    assert!(matches!(
-        result,
-        NetEdgeResult::Rejected {
-            reason: NetEdgeRejectReason::NetEdgeInputMissing,
-            ..
-        }
-    ));
+fn missing_l2_snapshot(mut context: BuildOrderIntentContext) -> BuildOrderIntentContext {
+    context.l2_snapshot = None;
+    context
 }
 
-#[test]
-fn test_missing_min_edge_fails_closed() {
-    let mut m = NetEdgeMetrics::new();
-    let input = NetEdgeInput {
-        gross_edge_usd: Some(10.0),
-        fee_usd: Some(3.0),
-        expected_slippage_usd: Some(1.0),
-        min_edge_usd: None, // missing
-    };
-
-    let result = evaluate_net_edge(&input, &mut m);
-
-    assert!(matches!(
-        result,
-        NetEdgeResult::Rejected {
-            reason: NetEdgeRejectReason::NetEdgeInputMissing,
-            ..
-        }
-    ));
+fn missing_fee_model_cached_at(mut context: BuildOrderIntentContext) -> BuildOrderIntentContext {
+    context.fee_model.fee_model_cached_at_ts_ms = None;
+    context
 }
 
-// ─── Missing L2 book data (fail-closed) ──────────────────────────────────
-
-#[test]
-fn test_missing_l2_book_fails_closed() {
-    let mut m = LiquidityGateMetrics::new();
-    let input = LiquidityGateInput {
-        order_qty: 1.0,
-        is_buy: true,
-        intent_class: GateIntentClass::Open,
-        is_marketable: true,
-        l2_snapshot: None, // missing book
-        now_ms: 1000,
-        l2_book_snapshot_max_age_ms: 5000,
-        max_slippage_bps: 200.0,
-    };
-
-    let result = evaluate_liquidity_gate(&input, &mut m);
-
-    assert!(
-        matches!(
-            result,
-            LiquidityGateResult::Rejected {
-                reason: LiquidityGateRejectReason::LiquidityGateNoL2,
-                ..
-            }
-        ),
-        "Missing L2 book must fail-closed with LiquidityGateNoL2"
-    );
+fn missing_net_edge_min(mut context: BuildOrderIntentContext) -> BuildOrderIntentContext {
+    context.min_edge_usd = f64::NAN;
+    context
 }
 
-// ─── Missing pricer input (invalid qty) ──────────────────────────────────
-
-#[test]
-fn test_zero_qty_pricer_fails_closed() {
-    let mut m = PricerMetrics::new();
-    let input = PricerInput {
-        fair_price: 100.0,
-        gross_edge_usd: 10.0,
-        min_edge_usd: 2.0,
-        fee_estimate_usd: 3.0,
-        qty: 0.0, // invalid
-        side: PricerSide::Buy,
-    };
-
-    let result = compute_limit_price(&input, &mut m);
+fn assert_rejects_without_side_effects(
+    name: &str,
+    context: BuildOrderIntentContext,
+    expected: BuildOrderIntentRejectReason,
+) {
+    let observers = context
+        .observers
+        .as_ref()
+        .expect("expected observers")
+        .clone();
+    let result = with_build_order_intent_context(context, || {
+        build_order_intent(base_intent(), OrderTypeGuardConfig::default())
+    });
+    assert!(result.is_err(), "{name} expected fail-closed rejection");
+
+    let outcome = take_build_order_intent_outcome().expect("expected outcome");
+    assert_eq!(
+        outcome,
+        BuildOrderIntentOutcome::Rejected(expected),
+        "{name} outcome mismatch"
+    );
 
     assert!(
-        matches!(
-            result,
-            PricerResult::Rejected {
-                reason: PricerRejectReason::InvalidInput,
-                ..
-            }
-        ),
-        "Zero qty must fail-closed with InvalidInput"
+        take_dispatch_trace().is_empty(),
+        "{name} should not record/dispatch"
+    );
+    assert_eq!(
+        observers.recorded_total.load(Ordering::Relaxed),
+        0,
+        "{name} should not record intent"
+    );
+    assert_eq!(
+        observers.dispatch_total.load(Ordering::Relaxed),
+        0,
+        "{name} should not dispatch intent"
     );
 }
 
-// ─── Chokepoint with unhealthy risk state ────────────────────────────────
-
-#[test]
-fn test_unhealthy_risk_state_fails_closed() {
-    let mut m = ChokeMetrics::new();
-    let gates = GateResults::default();
-
-    // All non-Healthy states must reject OPEN
-    for risk_state in [RiskState::Degraded, RiskState::Maintenance, RiskState::Kill] {
-        let result = build_order_intent(ChokeIntentClass::Open, risk_state, &mut m, &gates);
-
-        assert!(
-            matches!(
-                result,
-                ChokeResult::Rejected {
-                    reason: ChokeRejectReason::RiskStateNotHealthy,
-                    ..
-                }
-            ),
-            "RiskState::{risk_state:?} must fail-closed for OPEN intents"
-        );
-    }
+fn repo_root() -> PathBuf {
+    let manifest_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
+    manifest_dir
+        .parent()
+        .and_then(|path| path.parent())
+        .map(|path| path.to_path_buf())
+        .expect("repo root")
 }
 
-// ─── All rejections produce enumerated reason codes ──────────────────────
-
-#[test]
-fn test_all_rejections_have_enumerated_reason_codes() {
-    // Verify that every rejection path returns a structured enum variant,
-    // not a free-text string. The enum variants ARE the enumerated codes.
-
-    // QuantizeError variants
-    let qe1 = QuantizeError::InstrumentMetadataMissing { field: "tick_size" };
-    let qe2 = QuantizeError::TooSmallAfterQuantization {
-        qty_q: 0.0,
-        min_amount: 1.0,
-    };
-    assert!(matches!(
-        qe1,
-        QuantizeError::InstrumentMetadataMissing { .. }
-    ));
-    assert!(matches!(
-        qe2,
-        QuantizeError::TooSmallAfterQuantization { .. }
-    ));
-
-    // NetEdgeRejectReason variants
-    assert!(matches!(
-        NetEdgeRejectReason::NetEdgeInputMissing,
-        NetEdgeRejectReason::NetEdgeInputMissing
-    ));
-    assert!(matches!(
-        NetEdgeRejectReason::NetEdgeTooLow,
-        NetEdgeRejectReason::NetEdgeTooLow
-    ));
-
-    // PricerRejectReason variants
-    assert!(matches!(
-        PricerRejectReason::InvalidInput,
-        PricerRejectReason::InvalidInput
-    ));
-    assert!(matches!(
-        PricerRejectReason::NetEdgeTooLow,
-        PricerRejectReason::NetEdgeTooLow
-    ));
-
-    // ChokeRejectReason variants
-    assert!(matches!(
-        ChokeRejectReason::RiskStateNotHealthy,
-        ChokeRejectReason::RiskStateNotHealthy
-    ));
-
-    // LiquidityGateRejectReason variants
-    assert!(matches!(
-        LiquidityGateRejectReason::LiquidityGateNoL2,
-        LiquidityGateRejectReason::LiquidityGateNoL2
-    ));
+fn python_exe() -> String {
+    std::env::var("PYTHON").unwrap_or_else(|_| "python3".to_string())
 }
 
-// ─── No persistent side effects on config-missing rejections ─────────────
+fn write_config_matrix(results: &BTreeMap<CriticalKey, &'static str>) {
+    let mut entries = Vec::with_capacity(results.len());
+    for (key, status) in results {
+        entries.push(format!(
+            "\"{}\": {{\"status\": \"{}\", \"reason\": \"{}\"}}",
+            key.as_str(),
+            status,
+            CONFIG_MISSING_REASON
+        ));
+    }
+    let payload = format!("{{{}}}", entries.join(", "));
+    let python = python_exe();
+    let status = Command::new(&python)
+        .current_dir(repo_root())
+        .arg("tools/phase1_evidence.py")
+        .arg("config-matrix")
+        .arg(payload)
+        .status()
+        .expect("run config-matrix evidence writer");
+    assert!(status.success(), "config-matrix writer failed");
+}
 
 #[test]
-fn test_config_missing_no_side_effects() {
-    // Run all config-missing scenarios and verify zero persistent state
-
-    // 1. Missing tick_size
-    let mut qm = QuantizeMetrics::new();
-    let bad_constraints = QuantizeConstraints {
-        tick_size: 0.0,
-        amount_step: 0.1,
-        min_amount: 0.1,
-    };
-    let _ = quantize(1.0, 100.0, Side::Buy, &bad_constraints, &mut qm);
-
-    // 2. Missing net edge input
-    let mut nem = NetEdgeMetrics::new();
-    let _ = evaluate_net_edge(
-        &NetEdgeInput {
-            gross_edge_usd: None,
-            fee_usd: None,
-            expected_slippage_usd: None,
-            min_edge_usd: None,
+fn test_missing_config_fails_closed() {
+    let cases = [
+        MissingCase {
+            key: CriticalKey::InstrumentTickSize,
+            apply: missing_tick_size,
+            expected: BuildOrderIntentRejectReason::Quantize(
+                QuantizeRejectReason::InstrumentMetadataMissing,
+            ),
         },
-        &mut nem,
-    );
-
-    // 3. Missing L2
-    let mut lgm = LiquidityGateMetrics::new();
-    let _ = evaluate_liquidity_gate(
-        &LiquidityGateInput {
-            order_qty: 1.0,
-            is_buy: true,
-            intent_class: GateIntentClass::Open,
-            is_marketable: true,
-            l2_snapshot: None,
-            now_ms: 1000,
-            l2_book_snapshot_max_age_ms: 5000,
-            max_slippage_bps: 200.0,
+        MissingCase {
+            key: CriticalKey::InstrumentAmountStep,
+            apply: missing_amount_step,
+            expected: BuildOrderIntentRejectReason::Quantize(
+                QuantizeRejectReason::InstrumentMetadataMissing,
+            ),
         },
-        &mut lgm,
-    );
+        MissingCase {
+            key: CriticalKey::InstrumentMinAmount,
+            apply: missing_min_amount,
+            expected: BuildOrderIntentRejectReason::Quantize(
+                QuantizeRejectReason::InstrumentMetadataMissing,
+            ),
+        },
+        MissingCase {
+            key: CriticalKey::L2BookSnapshot,
+            apply: missing_l2_snapshot,
+            expected: BuildOrderIntentRejectReason::LiquidityGate(
+                LiquidityGateRejectReason::LiquidityGateNoL2,
+            ),
+        },
+        MissingCase {
+            key: CriticalKey::FeeModelCachedAtTsMs,
+            apply: missing_fee_model_cached_at,
+            expected: BuildOrderIntentRejectReason::DispatchAuth(RiskState::Degraded),
+        },
+        MissingCase {
+            key: CriticalKey::NetEdgeMinUsd,
+            apply: missing_net_edge_min,
+            expected: BuildOrderIntentRejectReason::NetEdge(
+                NetEdgeRejectReason::NetEdgeInputMissing,
+            ),
+        },
+    ];
+
+    let mut results: BTreeMap<CriticalKey, &'static str> = BTreeMap::new();
+    for case in cases {
+        let observers = BuildOrderIntentObservers::new();
+        let context = (case.apply)(base_context(observers));
+        assert_rejects_without_side_effects(case.key.as_str(), context, case.expected);
+        results.insert(case.key, "PASS");
+    }
 
-    // Only metrics changed — no WAL, no orders, no positions
-    // (Metrics changes are expected and are the ONLY allowed side effect)
-    assert!(nem.reject_input_missing() >= 1);
+    write_config_matrix(&results);
 }
