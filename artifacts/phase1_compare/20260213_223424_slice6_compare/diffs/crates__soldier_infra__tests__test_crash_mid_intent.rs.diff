diff --git a/tmp/slice6-compare-wOA1/opus/crates/soldier_infra/tests/test_crash_mid_intent.rs b/tmp/slice6-compare-wOA1/ralph/crates/soldier_infra/tests/test_crash_mid_intent.rs
index 25749c0..e9156aa 100644
--- a/tmp/slice6-compare-wOA1/opus/crates/soldier_infra/tests/test_crash_mid_intent.rs
+++ b/tmp/slice6-compare-wOA1/ralph/crates/soldier_infra/tests/test_crash_mid_intent.rs
@@ -1,301 +1,79 @@
-//! CI test proving crash mid-intent before dispatch causes no duplicate dispatch.
-//!
-//! CONTRACT.md AT-935, AT-233, §2.4: RecordedBeforeDispatch.
-//!
-//! Scenario: Process crashes AFTER WAL append but BEFORE dispatch to exchange.
-//! On restart, replay must NOT re-dispatch the intent. The WAL records
-//! the intent in Created state (sent_ts=0) which indicates it was never sent.
-
-use soldier_infra::store::{IntentRecord, LedgerMetrics, TlsState, WalLedger};
-use soldier_infra::wal::{BarrierMetrics, WalBarrierConfig, durable_append};
+use std::path::PathBuf;
+use std::time::{SystemTime, UNIX_EPOCH};
+
+use soldier_infra::store::{Ledger, LedgerRecord, ReplayOutcome, Side};
+
+fn temp_wal_path(test_name: &str) -> PathBuf {
+    let mut path = std::env::temp_dir();
+    let nanos = SystemTime::now()
+        .duration_since(UNIX_EPOCH)
+        .expect("clock")
+        .as_nanos();
+    path.push(format!(
+        "soldier_infra_{}_{}_{}.wal",
+        test_name,
+        std::process::id(),
+        nanos
+    ));
+    path
+}
 
-/// Create a test intent record.
-fn test_intent(hash: &str, state: TlsState, sent_ts: u64) -> IntentRecord {
-    IntentRecord {
-        intent_hash: hash.to_string(),
-        group_id: "group-001".to_string(),
+fn sample_record(intent_hash: u64) -> LedgerRecord {
+    LedgerRecord {
+        intent_hash,
+        group_id: "group-1".to_string(),
         leg_idx: 0,
-        instrument: "BTC-PERPETUAL".to_string(),
-        side: "buy".to_string(),
-        qty_q: 1.0,
-        limit_price_q: 50000.0,
-        tls_state: state,
-        created_ts: 1000,
-        sent_ts,
-        ack_ts: 0,
-        last_fill_ts: 0,
+        instrument: "BTC-PERP".to_string(),
+        side: Side::Buy,
+        qty_steps: Some(10),
+        qty_q: None,
+        limit_price_q: Some(100.5),
+        price_ticks: None,
+        tls_state: "Open".to_string(),
+        created_ts: 1,
+        sent_ts: None,
+        ack_ts: None,
+        last_fill_ts: None,
         exchange_order_id: None,
         last_trade_id: None,
     }
 }
 
-// ─── Crash before dispatch: intent in Created state ──────────────────────
-
 #[test]
 fn test_crash_mid_intent_no_duplicate_dispatch() {
-    // PHASE 1: Normal operation — append intent to WAL
-    let mut ledger = WalLedger::new(100);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig::default();
-
-    let intent = test_intent("intent-crash-001", TlsState::Created, 0);
-    let result = durable_append(&mut ledger, intent, &config, &mut lm, &mut bm);
-    assert!(result.is_ok(), "WAL append must succeed");
-    assert_eq!(ledger.queue_depth(), 1);
-
-    // === SIMULATED CRASH HERE ===
-    // Process crashes after WAL append but before dispatch.
-    // The intent is in Created state with sent_ts=0.
-
-    // PHASE 2: Restart — replay the WAL
-    let replay = ledger.replay();
-
-    assert_eq!(replay.records_replayed, 1);
-    assert_eq!(replay.in_flight_count, 1, "Created intent is in-flight");
-    assert_eq!(replay.in_flight_hashes, vec!["intent-crash-001"]);
-
-    // PHASE 3: Restart reconciliation — check if intent was sent
-    let was_sent = ledger.was_sent("intent-crash-001");
-    assert!(
-        !was_sent,
-        "Intent was NOT sent before crash — must NOT be re-dispatched"
-    );
-
-    // Decision: since was_sent=false, the restart logic should NOT dispatch.
-    // The intent was never sent to the exchange, so re-dispatching would be
-    // the FIRST dispatch — but the signal/edge that triggered it is now stale.
-    // Correct behavior: discard unsent intents on restart (they'll be
-    // regenerated by the next tick if the signal is still valid).
-}
-
-// ─── Crash after dispatch: intent in Sent state ──────────────────────────
-
-#[test]
-fn test_crash_after_dispatch_detected_on_replay() {
-    let mut ledger = WalLedger::new(100);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig::default();
-
-    // Intent was sent to exchange before crash
-    let intent = test_intent("intent-sent-002", TlsState::Sent, 2000);
-    durable_append(&mut ledger, intent, &config, &mut lm, &mut bm).unwrap();
-
-    // === SIMULATED CRASH HERE ===
-
-    // Replay detects in-flight intent that WAS sent
-    let replay = ledger.replay();
-    assert_eq!(replay.in_flight_count, 1);
-
-    let was_sent = ledger.was_sent("intent-sent-002");
-    assert!(
-        was_sent,
-        "Intent WAS sent — needs reconciliation with exchange, NOT re-dispatch"
-    );
-
-    // Correct behavior: query exchange for this order's status,
-    // update WAL accordingly. Do NOT re-send.
-}
-
-// ─── Terminal states are NOT in-flight ───────────────────────────────────
-
-#[test]
-fn test_terminal_states_not_in_flight_on_restart() {
-    let mut ledger = WalLedger::new(100);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig::default();
-
-    // Add intents in terminal states
-    durable_append(
-        &mut ledger,
-        test_intent("filled-001", TlsState::Filled, 1000),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    durable_append(
-        &mut ledger,
-        test_intent("cancelled-002", TlsState::Cancelled, 1000),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    durable_append(
-        &mut ledger,
-        test_intent("rejected-003", TlsState::Rejected, 0),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    durable_append(
-        &mut ledger,
-        test_intent("failed-004", TlsState::Failed, 0),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    // === SIMULATED RESTART ===
-    let replay = ledger.replay();
-
-    assert_eq!(replay.records_replayed, 4);
-    assert_eq!(
-        replay.in_flight_count, 0,
-        "Terminal states must NOT be in-flight"
-    );
-    assert!(replay.in_flight_hashes.is_empty());
-}
-
-// ─── Mixed states on restart ─────────────────────────────────────────────
-
-#[test]
-fn test_mixed_states_on_restart() {
-    let mut ledger = WalLedger::new(100);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig::default();
-
-    // Mix of states
-    durable_append(
-        &mut ledger,
-        test_intent("created-unsent", TlsState::Created, 0),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    durable_append(
-        &mut ledger,
-        test_intent("sent-pending", TlsState::Sent, 2000),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    durable_append(
-        &mut ledger,
-        test_intent("acked-live", TlsState::Acked, 2000),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    durable_append(
-        &mut ledger,
-        test_intent("filled-done", TlsState::Filled, 2000),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    // === SIMULATED RESTART ===
-    let replay = ledger.replay();
-
-    assert_eq!(replay.records_replayed, 4);
-    assert_eq!(
-        replay.in_flight_count, 3,
-        "Created + Sent + Acked are in-flight"
-    );
-
-    // Check dispatch decisions per intent
-    assert!(
-        !ledger.was_sent("created-unsent"),
-        "Created/unsent must NOT be re-dispatched"
-    );
-    assert!(
-        ledger.was_sent("sent-pending"),
-        "Sent must be reconciled, not re-dispatched"
-    );
-    assert!(
-        ledger.was_sent("acked-live"),
-        "Acked must be reconciled, not re-dispatched"
-    );
-}
-
-// ─── No ghost state after crash ──────────────────────────────────────────
-
-#[test]
-fn test_no_ghost_state_after_crash() {
-    let mut ledger = WalLedger::new(100);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig::default();
-
-    // Record intent but don't dispatch
-    durable_append(
-        &mut ledger,
-        test_intent("ghost-check", TlsState::Created, 0),
-        &config,
-        &mut lm,
-        &mut bm,
-    )
-    .unwrap();
-
-    // === CRASH AND RESTART ===
-    let replay = ledger.replay();
-
-    // The unsent intent should be discoverable for cleanup
-    assert!(replay.in_flight_hashes.contains(&"ghost-check".to_string()));
-
-    // Verify the record state — it should clearly show "never sent"
-    let record = ledger.get("ghost-check").unwrap();
-    assert_eq!(record.tls_state, TlsState::Created);
-    assert_eq!(record.sent_ts, 0);
-    assert!(record.exchange_order_id.is_none());
-
-    // This intent has no corresponding exchange order — safe to discard.
-    // No ghost state exists because nothing was sent to the exchange.
-}
-
-// ─── WAL append failure means no dispatch possible ───────────────────────
-
-#[test]
-fn test_wal_append_failure_prevents_dispatch() {
-    // Queue capacity = 0 → every append fails
-    let mut ledger = WalLedger::new(0);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig::default();
-
-    let intent = test_intent("should-not-dispatch", TlsState::Created, 0);
-    let result = durable_append(&mut ledger, intent, &config, &mut lm, &mut bm);
-
-    assert!(result.is_err(), "WAL append must fail on full queue");
-    assert_eq!(ledger.queue_depth(), 0, "No intent recorded");
-
-    // Since RecordedBeforeDispatch failed, the chokepoint gate would reject.
-    // No dispatch is possible without successful WAL append.
-    assert_eq!(lm.wal_write_errors(), 1);
-}
-
-// ─── Durability barrier with fsync ───────────────────────────────────────
-
-#[test]
-fn test_durable_append_with_fsync_barrier() {
-    let mut ledger = WalLedger::new(100);
-    let mut lm = LedgerMetrics::new();
-    let mut bm = BarrierMetrics::new();
-    let config = WalBarrierConfig {
-        require_wal_fsync_before_dispatch: true,
-    };
-
-    let intent = test_intent("fsync-test", TlsState::Created, 0);
-    let result = durable_append(&mut ledger, intent, &config, &mut lm, &mut bm).unwrap();
-
-    assert!(result.fsync_applied, "Fsync barrier must be applied");
-    assert_eq!(bm.barrier_wait_count(), 1);
-    assert_eq!(ledger.queue_depth(), 1);
+    let path = temp_wal_path("crash_mid_intent");
+    let record = sample_record(4242);
+
+    let ledger = Ledger::open(&path).expect("open ledger");
+    ledger
+        .record_before_dispatch(record.clone())
+        .expect("record before dispatch");
+    ledger.flush().expect("flush before crash");
+    drop(ledger);
+
+    let ledger = Ledger::open(&path).expect("reopen ledger");
+    let replay = ledger.replay_latest().expect("replay after crash");
+    let pending = replay.pending_dispatches();
+    assert_eq!(pending.len(), 1);
+    assert_eq!(pending[0].intent_hash, record.intent_hash);
+
+    let mut dispatch_count = 0u64;
+    for pending_record in pending {
+        dispatch_count += 1;
+        ledger
+            .record_replay_outcome(pending_record, ReplayOutcome::Sent { sent_ts: 200 })
+            .expect("mark sent");
+    }
+    assert_eq!(dispatch_count, 1);
+    ledger.flush().expect("flush sent record");
+    drop(ledger);
+
+    let ledger = Ledger::open(&path).expect("reopen ledger again");
+    let replay = ledger.replay_latest().expect("replay after sent");
+    let pending = replay.pending_dispatches();
+    assert!(pending.is_empty());
+    let latest = replay
+        .record_by_intent_hash(record.intent_hash)
+        .expect("latest record");
+    assert_eq!(latest.sent_ts, Some(200));
 }
