{
  "project": "StoicTrader",
  "source": {
    "implementation_plan_path": "IMPLEMENTATION_PLAN.md",
    "contract_path": "specs/CONTRACT.md"
  },
  "rules": {
    "one_commit_per_story": true,
    "passes_only_flips_after_verify_green": true,
    "wip_limit": 2,
    "verify_entrypoint": "./plans/verify.sh"
  },
  "items": [
    {
      "id": "S0-000",
      "priority": 200,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 — Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-A Launch Policy Baseline",
      "category": "policy",
      "description": "Create launch policy doc with explicit constraints (instruments, position limits, order rate, environments).",
      "contract_refs": [
        "P0-A Launch Policy Baseline"
      ],
      "plan_refs": [
        "Global Non‑Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/launch_policy.md",
          "evidence/phase0/policy/launch_policy_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes allowed instruments/venues.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes max position/daily loss.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes max order rate/pacing.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes environments (DEV/STAGING/PAPER/LIVE).",
        "GIVEN evidence/phase0/policy/launch_policy_snapshot.md exists WHEN reviewed THEN is literal copy of docs."
      ],
      "steps": [
        "Create docs/launch_policy.md with allowed instruments and venues.",
        "Add allowed order types section.",
        "Add max position / max daily loss (capital stop).",
        "Add max order rate / pacing rule.",
        "Add environments section (DEV/STAGING/PAPER/LIVE with purpose).",
        "Copy full contents to evidence/phase0/policy/launch_policy_snapshot.md."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/launch_policy.md",
        "test -s evidence/phase0/policy/launch_policy_snapshot.md"
      ],
      "evidence": [
        "docs/launch_policy.md",
        "evidence/phase0/policy/launch_policy_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_trading_policy.rs"
      ]
    },
    {
      "id": "S0-001",
      "priority": 199,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 — Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-B Environment Isolation",
      "category": "policy",
      "description": "Document environment isolation (separate keys/configs per env, no cross-env leakage).",
      "contract_refs": [
        "P0-B Environment Isolation"
      ],
      "plan_refs": [
        "Global Non‑Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/env_matrix.md",
          "evidence/phase0/env/env_matrix_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN lists each environment (DEV/STAGING/PAPER/LIVE).",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows which exchange account per env.",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows key permissions per env.",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows where secrets are stored.",
        "GIVEN evidence/phase0/env/env_matrix_snapshot.md exists WHEN reviewed THEN is literal copy of docs."
      ],
      "steps": [
        "Create docs/env_matrix.md with environment table.",
        "Add exchange account + API key per environment.",
        "Add permissions/scope per key (read-only vs trade vs withdraw).",
        "Add where secrets are stored (vault, env vars, etc.).",
        "Copy full contents to evidence/phase0/env/env_matrix_snapshot.md."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/env_matrix.md",
        "test -s evidence/phase0/env/env_matrix_snapshot.md"
      ],
      "evidence": [
        "docs/env_matrix.md",
        "evidence/phase0/env/env_matrix_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S0-002",
      "priority": 198,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 — Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-C Keys & Secrets Baseline",
      "category": "policy",
      "description": "Document key creation rules, rotation plan, and prove least-privilege with JSON scope probe.",
      "contract_refs": [
        "P0-C Keys & Secrets Baseline"
      ],
      "plan_refs": [
        "Global Non‑Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/keys_and_secrets.md",
          "evidence/phase0/keys/key_scope_probe.json"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes key creation rules (least privilege).",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes rotation plan.",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes where secrets live.",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes LIVE key protection.",
        "GIVEN evidence/phase0/keys/key_scope_probe.json WHEN parsed THEN is valid JSON with required fields."
      ],
      "steps": [
        "Create docs/keys_and_secrets.md with key creation rules.",
        "Add rotation plan (who/when/how).",
        "Add where secrets live (what must never appear in repo).",
        "Add how LIVE keys are protected from local/dev usage.",
        "Execute key scope probe and record in JSON format.",
        "Verify JSON has required fields: env, exchange, key_id, scopes, withdraw_enabled, timestamp_utc, operator."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/keys_and_secrets.md",
        "python -c \"import json; json.load(open('evidence/phase0/keys/key_scope_probe.json'))\""
      ],
      "evidence": [
        "docs/keys_and_secrets.md",
        "evidence/phase0/keys/key_scope_probe.json"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "human_blocker": {
        "why": "Key scope probes require access to exchange APIs",
        "question": "Has key scope probe been executed and recorded as JSON?",
        "options": [
          "Yes - probe JSON recorded",
          "No - awaiting access"
        ],
        "recommended": "Execute probe and record in key_scope_probe.json",
        "unblock_steps": [
          "Get API access",
          "Run scope probe",
          "Record JSON with required fields"
        ]
      }
    },
    {
      "id": "S0-003",
      "priority": 197,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 — Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-D Break-Glass Runbook + Drill",
      "category": "policy",
      "description": "Create break-glass runbook and execute a recorded drill proving halt capability.",
      "contract_refs": [
        "P0-D Break-Glass Runbook"
      ],
      "plan_refs": [
        "Global Non‑Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/break_glass_runbook.md",
          "evidence/phase0/break_glass/runbook_snapshot.md",
          "evidence/phase0/break_glass/drill.md",
          "evidence/phase0/break_glass/log_excerpt.txt"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has STOP TRADING steps.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has verify no further OPEN risk.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has verify risk reduction possible.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has escalation + notify.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has trigger scenario.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has time to halt.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has observed behavior.",
        "GIVEN evidence/phase0/break_glass/log_excerpt.txt WHEN reviewed THEN proves drill occurred."
      ],
      "steps": [
        "Create docs/break_glass_runbook.md with STOP TRADING steps (kill switch).",
        "Add how to verify no further OPEN risk.",
        "Add how to verify risk reduction still possible.",
        "Add escalation and who to notify.",
        "Copy runbook to evidence/phase0/break_glass/runbook_snapshot.md.",
        "Execute drill: simulate runaway order attempt.",
        "Record drill in evidence/phase0/break_glass/drill.md with trigger, time to halt, observed behavior.",
        "Capture log excerpt in evidence/phase0/break_glass/log_excerpt.txt."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/break_glass_runbook.md",
        "test -s evidence/phase0/break_glass/runbook_snapshot.md",
        "test -s evidence/phase0/break_glass/drill.md",
        "test -s evidence/phase0/break_glass/log_excerpt.txt"
      ],
      "evidence": [
        "docs/break_glass_runbook.md",
        "evidence/phase0/break_glass/runbook_snapshot.md",
        "evidence/phase0/break_glass/drill.md",
        "evidence/phase0/break_glass/log_excerpt.txt"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "break_glass_drill_completed",
            "type": "gauge",
            "unit": "count",
            "labels": [],
            "note": "Evidence artifact: log_excerpt.txt proves drill occurred (1 when drill completed)"
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "human_blocker": {
        "why": "Drill requires human execution and observation",
        "question": "Has the break-glass drill been executed with witnesses?",
        "options": [
          "Yes - drill completed and recorded",
          "No - drill not yet executed"
        ],
        "recommended": "Execute drill in DEV/STAGING before marking done",
        "unblock_steps": [
          "Create runbook doc",
          "Execute drill",
          "Record in drill.md",
          "Capture log excerpt"
        ]
      }
    },
    {
      "id": "S0-004",
      "priority": 196,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 — Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-E Health Endpoint",
      "category": "infra",
      "description": "Implement health endpoint returning ok/build_id/contract_version.",
      "contract_refs": [
        "P0-E Health Endpoint Scaffolding",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "Global Non‑Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/health_endpoint.md",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/src/health.rs",
          "crates/soldier_infra/tests/test_health.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN health endpoint called WHEN system healthy THEN returns ok=true, build_id, contract_version.",
        "GIVEN health command WHEN system healthy THEN exits 0.",
        "GIVEN docs/health_endpoint.md WHEN reviewed THEN documents command and format."
      ],
      "steps": [
        "Create docs/health_endpoint.md documenting the health command.",
        "Define expected output format (ok, build_id, contract_version).",
        "Implement health endpoint in soldier_infra.",
        "Wire health endpoint to CLI command.",
        "Implement test_health_endpoint_returns_required_fields.",
        "Implement test_health_command_exits_zero_when_healthy.",
        "Run tests and verify all pass."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_health"
      ],
      "evidence": [
        "cargo test output",
        "docs/health_endpoint.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "ok",
          "build_id",
          "contract_version"
        ],
        "status_contract_ats": [
          "AT-012"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_health.rs"
      ]
    },
    {
      "id": "S1-010",
      "priority": 88,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Appendix A config defaults",
      "category": "infra",
      "description": "Apply Appendix A safety-critical defaults in infra config and verify missing-value behavior.",
      "contract_refs": [
        "CONTRACT.md Appendix A: Configuration Defaults (Safety-Critical Thresholds)",
        "CONTRACT.md AT-341",
        "CONTRACT.md AT-040",
        "Anchor-001",
        "Anchor-002",
        "Anchor-003",
        "Anchor-008",
        "Anchor-009",
        "Anchor-010",
        "Anchor-012",
        "Anchor-015",
        "Anchor-016",
        "Anchor-020",
        "Anchor-022",
        "VR-001",
        "VR-002",
        "VR-003",
        "VR-004a",
        "VR-004b",
        "VR-005",
        "VR-006",
        "VR-008",
        "VR-009",
        "VR-015",
        "VR-016",
        "VR-023"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.0 — Repo verification harness (plans/verify.sh) + safety-critical config defaults (Appendix A)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests"
        ],
        "create": [
          "crates/soldier_infra/config"
        ],
        "avoid": [
          "plans/**",
          "crates/soldier_core/**"
        ]
      },
      "acceptance": [
        "GIVEN config omits instrument_cache_ttl_s WHEN defaults are applied THEN the TTL uses the Appendix A default of 3600s.",
        "GIVEN config omits the global evidence cooldown setting WHEN defaults are applied THEN the cooldown uses the Appendix A default of 120s.",
        "GIVEN config omits mm_util_kill WHEN defaults are applied THEN the kill threshold uses the Appendix A default of 0.95.",
        "GIVEN a safety-critical gate references a parameter without an Appendix A default WHEN the parameter is missing THEN the gate fails closed with a deterministic reason."
      ],
      "steps": [
        "Define a centralized defaults table covering Appendix A safety-critical parameters, including instrument_cache_ttl_s, evidenceguard_global_cooldown, and mm_util_kill.",
        "Create a config loader in crates/soldier_infra that applies Appendix A defaults when values are missing.",
        "Add a fail-closed path for safety-critical parameters that lack Appendix A defaults, surfacing a deterministic error.",
        "Create crates/soldier_infra/tests/test_config_defaults.rs with a test for missing instrument_cache_ttl_s and the global evidence cooldown applying defaults.",
        "Add a test case for missing mm_util_kill applying the Appendix A default.",
        "Add a test case for a missing non-Appendix A parameter to assert fail-closed behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_config_defaults"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_config_defaults output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "config_defaults_applied_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "config_key"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-001",
      "priority": 90,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Workspace scaffolding",
      "category": "infra",
      "description": "Initialize the Rust workspace with soldier_core and soldier_infra crates.",
      "contract_refs": [
        "CONTRACT.md 0.X Repository Layout & Canonical Module Mapping (Non-Negotiable)",
        "CONTRACT.md AT-905"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md C) Entry Criteria"
      ],
      "scope": {
        "touch": [
          "Cargo.toml",
          ".gitignore",
          "crates/soldier_core/Cargo.toml",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_infra/Cargo.toml",
          "crates/soldier_infra/src/lib.rs"
        ],
        "avoid": [
          "python/**",
          "specs/**",
          "artifacts/**"
        ]
      },
      "acceptance": [
        "GIVEN the repo layout WHEN inspected THEN crates/soldier_core and crates/soldier_infra directories exist.",
        "GIVEN Cargo.toml is inspected WHEN reading workspace members THEN it includes crates/soldier_core and crates/soldier_infra.",
        "GIVEN the workspace is configured WHEN running `cargo test --workspace` THEN it builds and exits 0."
      ],
      "steps": [
        "Create the crates/ directory if it does not exist.",
        "Initialize crates/soldier_core as a Rust library crate.",
        "Initialize crates/soldier_infra as a Rust library crate.",
        "Create or update the root Cargo.toml with a workspace members list including both crates.",
        "Run `cargo test --workspace` to confirm the workspace builds."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test --workspace output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-011",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Deribit instrument structs",
      "category": "infra",
      "description": "Define Deribit public instrument structs for metadata mapping.",
      "contract_refs": [
        "CONTRACT.md AT-333"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.1 — InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/deribit/public/mod.rs",
          "crates/soldier_infra/src/deribit/mod.rs",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/Cargo.toml"
        ],
        "avoid": [
          "crates/soldier_core/**"
        ]
      },
      "acceptance": [
        "GIVEN AT-333 requires InstrumentKind derivation from venue metadata WHEN the Deribit public instrument struct is defined THEN it MUST include the 'kind' field (option|future|option_combo) required for mapping to the contract InstrumentKind enum.",
        "GIVEN the contract OrderSize struct requires tick_size, amount_step, min_amount, and contract_multiplier (AT-333) WHEN the Deribit public instrument struct is defined THEN all four fields are present and deserializable from /public/get_instruments responses.",
        "GIVEN soldier_core will consume Deribit metadata (AT-333) WHEN the Deribit public module is compiled THEN the instrument structs are pub-exported from soldier_infra and importable by dependent crates."
      ],
      "steps": [
        "Define the minimal Deribit public instrument structs needed for mapping in crates/soldier_infra/deribit/public, including tick_size, amount_step, min_amount, and contract_multiplier.",
        "Add required serde derives for deserialization from Deribit API responses.",
        "Wire imports in crates/soldier_infra/src/deribit/mod.rs and src/lib.rs to expose the public module.",
        "Add basic unit tests or compile checks to verify the struct fields are correctly defined.",
        "Run cargo test -p soldier_infra to confirm the module compiles and is accessible."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra"
      ],
      "evidence": [
        "cargo test -p soldier_infra output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-002",
      "priority": 80,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 InstrumentKind and RiskState",
      "category": "execution",
      "description": "Implement InstrumentKind derivation and RiskState enum per contract definitions.",
      "contract_refs": [
        "CONTRACT.md AT-333"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.1 — InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/src/risk/state.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_core/policy/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN Deribit metadata for a USDC-margined perpetual WHEN deriving InstrumentKind THEN it returns linear_future.",
        "GIVEN metadata for option, perpetual, inverse_future, and linear_future instruments WHEN deriving InstrumentKind THEN it maps to the contract enum values.",
        "GIVEN instrument metadata from /public/get_instruments WHEN mapping to internal fields THEN tick_size, amount_step, min_amount, and contract_multiplier match the fetched values (test_instrument_metadata_uses_get_instruments).",
        "GIVEN the RiskState enum WHEN compiled THEN it includes Healthy, Degraded, Maintenance, and Kill variants."
      ],
      "steps": [
        "Define the RiskState enum in crates/soldier_core/risk/state.rs with the contract variants.",
        "Define the InstrumentKind enum in crates/soldier_core/venue/types.rs with contract values.",
        "Implement conversion logic from Deribit instrument metadata to InstrumentKind, including linear perpetual → linear_future and metadata field passthrough.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_kind_mapping.rs for mapping behavior and metadata passthrough (test_instrument_metadata_uses_get_instruments).",
        "Wire any required imports so the new enums are accessible where used."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_kind_mapping"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_kind_mapping output"
      ],
      "dependencies": [
        "S1-011"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
          "location": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
          "anchor": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata)."
        }
      ],
      "enforcing_contract_ats": [
        "AT-333"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
      ]
    },
    {
      "id": "S1-003",
      "priority": 70,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL",
      "category": "risk",
      "description": "Enforce InstrumentCache TTL and degrade RiskState on stale metadata.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
        "CONTRACT.md AT-104",
        "VR-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.1 — InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN cached instrument metadata older than the configured TTL WHEN accessed THEN RiskState::Degraded is returned for that lookup (test_stale_instrument_cache_sets_degraded).",
        "GIVEN cached metadata within TTL WHEN accessed THEN RiskState::Healthy is returned alongside the metadata.",
        "GIVEN instrument_cache_age_s > instrument_cache_ttl_s and an OPEN intent WHEN dispatch eligibility is checked THEN the OPEN is rejected and CLOSE/HEDGE/CANCEL remain allowed (test_instrument_cache_ttl_blocks_opens_allows_closes).",
        "GIVEN cache access WHEN processing THEN the cache age is compared against instrument_cache_ttl_s deterministically."
      ],
      "steps": [
        "Locate or create the InstrumentCache structure in crates/soldier_core/venue.",
        "Add timestamp tracking for cache insert/update and compute cache age on read; record instrument_cache_age_s and increment instrument_cache_hits_total.",
        "Compare cache age to TTL and return RiskState::Degraded when stale.",
        "Expose the cache freshness signal to dispatch eligibility checks so OPEN is rejected and CLOSE/HEDGE/CANCEL remain allowed when stale.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_cache_ttl.rs for fresh vs stale behavior.",
        "Add a unit test for stale metadata blocking OPEN while allowing CLOSE/HEDGE/CANCEL.",
        "Add or update a test to assert cache age comparisons against instrument_cache_ttl_s are deterministic."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl output",
        "Unit test asserts RiskState::Degraded on stale metadata",
        "Unit test asserts OPEN blocked and CLOSE/HEDGE/CANCEL allowed when metadata is stale",
        "Unit test asserts instrument_cache_ttl_s comparison is deterministic"
      ],
      "dependencies": [
        "S1-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
          "location": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
          "anchor": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement"
        }
      ],
      "enforcing_contract_ats": [
        "AT-104"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "instrument_cache_hits_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          },
          {
            "name": "instrument_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "RiskState::Healthy",
        "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
      ]
    },
    {
      "id": "S1-006",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL observability",
      "category": "risk",
      "description": "Add required TTL observability hooks for instrument cache freshness.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
        "VR-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.1 — InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN a TTL breach WHEN processing THEN a structured log InstrumentCacheTtlBreach{instrument_id, age_s, ttl_s} is emitted.",
        "GIVEN any cache access WHEN processing THEN instrument_cache_hits_total increments and instrument_cache_age_s is updated.",
        "GIVEN a stale access WHEN processing THEN instrument_cache_stale_total increments.",
        "GIVEN a metadata refresh failure WHEN processing THEN instrument_cache_refresh_errors_total increments."
      ],
      "steps": [
        "Emit a structured log InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s on staleness.",
        "Increment instrument_cache_hits_total on every cache access.",
        "Update instrument_cache_age_s gauge with computed cache age.",
        "Increment instrument_cache_stale_total on staleness.",
        "Increment instrument_cache_refresh_errors_total when a metadata refresh fails.",
        "Add test assertions in crates/soldier_core/tests/test_instrument_cache_ttl.rs for the log event.",
        "Add test assertions for metric increments and gauge updates using an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl output",
        "Log capture shows InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s",
        "Unit test asserts instrument_cache_hits_total and instrument_cache_stale_total increments",
        "Unit test asserts instrument_cache_refresh_errors_total increment",
        "Unit test asserts instrument_cache_age_s gauge update"
      ],
      "dependencies": [
        "S1-003"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
          "location": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
          "anchor": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement"
        }
      ],
      "enforcing_contract_ats": [
        "AT-104"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "instrument_cache_hits_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          },
          {
            "name": "instrument_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "instrument_cache_stale_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
      ]
    },
    {
      "id": "S1-004",
      "priority": 60,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize canonical sizing",
      "category": "execution",
      "description": "Implement OrderSize canonical sizing with deterministic notional_usd using the discovery report.",
      "contract_refs": [
        "CONTRACT.md OrderSize struct (MUST implement):",
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract)"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.2 — OrderSize canonical sizing + notional invariant"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_infra/**",
          "crates/soldier_core/src/venue/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind option or linear_future WHEN building OrderSize THEN qty_coin is canonical and notional_usd = qty_coin * index_price.",
        "GIVEN instrument_kind option WHEN building OrderSize THEN qty_usd is unset.",
        "GIVEN instrument_kind perpetual or inverse_future WHEN building OrderSize THEN qty_usd is canonical and notional_usd = qty_usd.",
        "GIVEN any OrderSize WHEN built THEN notional_usd is always populated and internal fields are consistent with the contract invariants."
      ],
      "steps": [
        "Review docs/order_size_discovery.md for current gaps and proposed tests.",
        "Create crates/soldier_core/execution/order_size.rs if missing.",
        "Define the OrderSize struct with contracts, qty_coin, qty_usd, and notional_usd.",
        "Implement a constructor/builder that computes canonical units based on InstrumentKind.",
        "Ensure option sizing uses qty_coin and leaves qty_usd unset.",
        "Populate notional_usd deterministically using index_price for coin-sized instruments.",
        "Add a debug log OrderSizeComputed{instrument_kind, notional_usd}.",
        "Add unit tests in crates/soldier_core/tests/test_order_size.rs for canonical sizing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_order_size output"
      ],
      "dependencies": [
        "S1-002",
        "S1-008"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md OrderSize struct (MUST implement):",
          "location": "CONTRACT.md OrderSize struct (MUST implement):",
          "anchor": "CONTRACT.md OrderSize struct (MUST implement):"
        }
      ],
      "enforcing_contract_ats": [
        "AT-277"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "order_size_computed_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_order_size.rs"
      ]
    },
    {
      "id": "S1-005",
      "priority": 50,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher amount mapping",
      "category": "execution",
      "description": "Map OrderSize to Deribit request amounts using the discovery report.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.3 — Dispatcher amount mapping + mismatch reject→Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/risk/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN option or linear_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_coin.",
        "GIVEN perpetual or inverse_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_usd.",
        "GIVEN any OrderSize WHEN mapping THEN exactly one canonical amount field is set and the other is unset.",
        "GIVEN intent classification CLOSE/HEDGE WHEN mapping THEN reduce_only=true; GIVEN OPEN THEN reduce_only=false or omitted."
      ],
      "steps": [
        "Review docs/dispatch_map_discovery.md for current gaps and proposed tests.",
        "Create or update crates/soldier_core/execution/dispatch_map.rs with OrderSize mapping logic.",
        "Implement the rule: exactly one canonical amount field is sent per instrument_kind.",
        "Ensure outbound request uses qty_coin for option/linear_future and qty_usd for perpetual/inverse_future.",
        "Map reduce_only from intent classification only (CLOSE/HEDGE=true, OPEN=false or omitted).",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for amount field selection.",
        "Add a negative test asserting no second amount field is set."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_dispatch_map output",
        "Unit test asserts reduce_only mapping by intent classification"
      ],
      "dependencies": [
        "S1-004",
        "S1-009"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
          "location": "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
          "anchor": "CONTRACT.md Dispatcher Rules (Deribit request mapping):"
        }
      ],
      "enforcing_contract_ats": [
        "AT-277"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_dispatch_map.rs"
      ]
    },
    {
      "id": "S1-007",
      "priority": 55,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mismatch rejection",
      "category": "execution",
      "description": "Reject contract/amount mismatches and emit mismatch metrics.",
      "contract_refs": [
        "CONTRACT.md AT-920"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.3 — Dispatcher amount mapping + mismatch reject→Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/risk/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN AT-920 requires rejecting intent on contracts/amount mismatch and setting RiskState::Degraded WHEN contracts vs canonical amount differ by more than contracts_amount_match_tolerance=0.001 THEN the intent is rejected with RejectReason::UnitMismatch AND RiskState::Degraded is returned (enforcing fail-closed per contract).",
        "GIVEN AT-920 requires observability of mismatch rejections WHEN a mismatch rejection occurs THEN order_intent_reject_unit_mismatch_total counter increments by 1.",
        "GIVEN the contract requires deterministic error propagation (AT-920) WHEN a mismatch rejection occurs THEN the error is surfaced to callers with RejectReason::UnitMismatch and includes the computed mismatch delta."
      ],
      "steps": [
        "Validate contracts vs canonical amount using contracts_amount_match_tolerance=0.001 and return an error with RiskState::Degraded on mismatch.",
        "Define a deterministic error reason for unit mismatches to surface to callers.",
        "Increment order_intent_reject_unit_mismatch_total for mismatch rejections.",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for mismatch rejection behavior.",
        "Add or update unit tests in crates/soldier_core/tests/test_order_size.rs for mismatch cases.",
        "Assert the metric increment via an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_dispatch_map output",
        "cargo test -p soldier_core --test test_order_size output",
        "Unit test asserts order_intent_reject_unit_mismatch_total increment",
        "Unit test asserts contracts_amount_match_tolerance=0.001 applied"
      ],
      "dependencies": [
        "S1-005"
      ],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
          "location": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
          "anchor": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`"
        }
      ],
      "enforcing_contract_ats": [
        "AT-920"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "UnitMismatch"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "order_intent_reject_unit_mismatch_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "crates/soldier_core/tests/test_dispatch_map.rs",
        "crates/soldier_core/tests/test_order_size.rs"
      ]
    },
    {
      "id": "S1-008",
      "priority": 95,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize discovery",
      "category": "qa",
      "description": "Discover current OrderSize logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract)",
        "CONTRACT.md OrderSize struct (MUST implement):",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.2 — OrderSize canonical sizing + notional invariant"
      ],
      "scope": {
        "touch": [
          "docs/order_size_discovery.md"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN the current OrderSize implementation WHEN inspected THEN docs/order_size_discovery.md lists current fields, call sites, and gaps vs the contract OrderSize struct.",
        "GIVEN contract unit invariants WHEN inspected THEN docs/order_size_discovery.md lists required tests to add for canonical sizing.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff needed for OrderSize canonical sizing."
      ],
      "steps": [
        "Locate current OrderSize logic and any related helpers in the codebase.",
        "Identify call sites that construct OrderSize or size fields.",
        "Draft docs/order_size_discovery.md with: current fields, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align OrderSize with contract invariants.",
        "Keep the report scoped to OrderSize and sizing invariants only."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -f docs/order_size_discovery.md",
        "rg -n \"OrderSize\" docs/order_size_discovery.md"
      ],
      "evidence": [
        "docs/order_size_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-009",
      "priority": 85,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mapping discovery",
      "category": "qa",
      "description": "Discover current dispatcher mapping logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 — Instrument Units + Dispatcher Invariants / S1.3 — Dispatcher amount mapping + mismatch reject→Degraded"
      ],
      "scope": {
        "touch": [
          "docs/dispatch_map_discovery.md"
        ],
        "avoid": [
          "crates/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN the current dispatch mapping WHEN inspected THEN docs/dispatch_map_discovery.md lists current amount field logic and contract gaps.",
        "GIVEN contract mapping rules WHEN inspected THEN docs/dispatch_map_discovery.md lists tests to add for canonical amount selection.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff required for dispatcher mapping."
      ],
      "steps": [
        "Locate current dispatch mapping logic in the codebase.",
        "Identify how outbound amount fields are chosen today.",
        "Draft docs/dispatch_map_discovery.md with: current logic, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align mapping with contract rules.",
        "Keep the report scoped to dispatcher mapping only."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -f docs/dispatch_map_discovery.md",
        "rg -n \"dispatch\" docs/dispatch_map_discovery.md"
      ],
      "evidence": [
        "docs/dispatch_map_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S2-000",
      "priority": 100,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.1 Quantization rounding",
      "category": "execution",
      "description": "Implement deterministic quantization for qty and limit price with safe rounding.",
      "contract_refs": [
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "AT-021",
        "AT-020"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.1 — Integer tick/step quantization (safer direction)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/quantize.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_quantize.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/idempotency/**"
        ]
      },
      "acceptance": [
        "GIVEN raw_qty and amount_step WHEN quantizing THEN qty_steps = floor(raw_qty / amount_step) and qty_q = qty_steps * amount_step.",
        "GIVEN a BUY raw_limit_price and tick_size WHEN quantizing THEN price_ticks = floor(raw_limit_price / tick_size) and limit_price_q = price_ticks * tick_size; GIVEN SELL THEN price_ticks = ceil(raw_limit_price / tick_size).",
        "GIVEN qty_q < min_amount WHEN quantizing THEN the intent is rejected with TooSmallAfterQuantization."
      ],
      "steps": [
        "Implement quantize helpers to read tick_size, amount_step, and min_amount from instrument metadata.",
        "Compute qty_steps and price_ticks as integers using amount_step and tick_size with directional rounding by side.",
        "Derive qty_q and limit_price_q from qty_steps and price_ticks.",
        "Add a rejection path when qty_q < min_amount with an explicit error type.",
        "Add counter quantization_reject_too_small_total for rejection metrics.",
        "Add unit tests in crates/soldier_core/tests/test_quantize.rs for rounding and rejection behavior.",
        "Ensure integer tick/step values are returned for downstream idempotency hashing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_quantize"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_quantize output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
          "location": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
          "anchor": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-020",
        "AT-021"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::TooSmallAfterQuantization"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "quantization_reject_too_small_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_quantize.rs"
      ]
    },
    {
      "id": "S2-001",
      "priority": 90,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.2 Intent hash from quantized fields",
      "category": "durability",
      "description": "Compute intent_hash from quantized fields only and exclude timestamps.",
      "contract_refs": [
        "CONTRACT.md 1.1 Labeling & Idempotency Contract",
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "AT-020",
        "Anchor-017",
        "VR-017"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.2 — Intent hash from quantized fields only"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/idempotency/hash.rs",
          "crates/soldier_core/src/idempotency/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_idempotency.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/execution/quantize.rs"
        ]
      },
      "acceptance": [
        "GIVEN two codepaths that yield identical quantized fields WHEN hashing THEN the intent_hash values are identical.",
        "GIVEN an intent with time-of-day timestamps WHEN hashing THEN timestamps are excluded from the hash input.",
        "GIVEN quantized qty_steps and price_ticks WHEN hashing THEN those integer values (plus stable strings) are used, not raw f64."
      ],
      "steps": [
        "Implement or update the intent_hash function in crates/soldier_core/idempotency/hash.rs to accept quantized integer inputs.",
        "Remove any inclusion of wall-clock timestamps from the hash input.",
        "Use qty_steps and price_ticks (integers) alongside instrument, side, group_id, and leg_idx in the hash material.",
        "Add unit tests in crates/soldier_core/tests/test_idempotency.rs for deterministic hashing.",
        "Ensure callers pass quantized integer fields into the hashing function."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_idempotency"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_idempotency output"
      ],
      "dependencies": [
        "S2-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1 Labeling & Idempotency Contract",
          "location": "CONTRACT.md 1.1 Labeling & Idempotency Contract",
          "anchor": "CONTRACT.md 1.1 Labeling & Idempotency Contract"
        }
      ],
      "enforcing_contract_ats": [
        "AT-020"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_idempotency.rs"
      ]
    },
    {
      "id": "S2-002",
      "priority": 80,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.3 Compact label schema",
      "category": "durability",
      "description": "Implement compact label encode/decode with 64-character limit enforcement.",
      "contract_refs": [
        "CONTRACT.md §1.1 Labeling & Idempotency Contract",
        "AT-216",
        "AT-217"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.3 — Compact label schema encode/decode (≤64 chars)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_label.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/recovery/**"
        ]
      },
      "acceptance": [
        "GIVEN strat_id, group_id, leg_idx, and intent_hash WHEN encoding THEN the label matches s4:{sid8}:{gid12}:{li}:{ih16} and is ≤ 64 chars.",
        "GIVEN a compact label WHEN decoding THEN sid8, gid12, leg_idx, and ih16 are parsed correctly.",
        "GIVEN a computed s4 label would exceed 64 chars WHEN encoding THEN the intent is rejected with Rejected(LabelTooLong), RiskState::Degraded is set, and no dispatch occurs (no truncation)."
      ],
      "steps": [
        "Implement label encoding in crates/soldier_core/src/execution/label.rs to produce sid8, gid12, and ih16.",
        "Enforce the ≤64 character limit; if the computed label would exceed 64 chars, reject with LabelTooLong and set RiskState::Degraded (no truncation).",
        "Implement label decoding to parse sid8, gid12, leg_idx, and ih16.",
        "Add unit tests in crates/soldier_core/tests/test_label.rs for length limits and parsing.",
        "Ensure encode/decode round-trips for valid inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_label output",
        "Test assertions for LabelTooLong rejection and label parsing"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md §1.1 Labeling & Idempotency Contract",
          "location": "CONTRACT.md §1.1 Labeling & Idempotency Contract",
          "anchor": "AT-216"
        }
      ],
      "enforcing_contract_ats": [
        "AT-216",
        "AT-217"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::LabelTooLong"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-216",
          "AT-217"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_label.rs"
      ]
    },
    {
      "id": "S2-003",
      "priority": 70,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.4 Label match disambiguation",
      "category": "risk",
      "description": "Disambiguate label matches deterministically and degrade on ambiguity.",
      "contract_refs": [
        "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
        "AT-022",
        "Anchor-001",
        "Anchor-019",
        "VR-021",
        "VR-022"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.4 — Label match disambiguation; ambiguity→Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/lib.rs"
        ],
        "create": [
          "crates/soldier_core/src/recovery",
          "crates/soldier_core/tests/test_label_match.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**"
        ]
      },
      "acceptance": [
        "GIVEN multiple intents sharing gid12 and leg_idx WHEN matching THEN tie-breakers are applied in order: ih16, instrument, side, qty_q.",
        "GIVEN ambiguity remains after tie-breakers WHEN matching THEN RiskState::Degraded is returned and no intent is matched (fail-closed).",
        "GIVEN a single clear candidate WHEN matching THEN the matched intent is returned deterministically."
      ],
      "steps": [
        "Parse labels into sid8, gid12, leg_idx, and ih16 in crates/soldier_core/src/recovery/label_match.rs.",
        "Build the candidate set by gid12 and leg_idx.",
        "Apply the tie-breakers in the contract order: ih16, instrument, side, qty_q.",
        "On unresolved ambiguity, return a Degraded outcome and increment label_match_ambiguity_total.",
        "Add unit tests in crates/soldier_core/tests/test_label_match.rs for disambiguation and ambiguity cases.",
        "Ensure the matching result is deterministic for identical inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label_match"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_label_match output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [
        "S2-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
          "location": "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
          "anchor": "AT-022"
        }
      ],
      "enforcing_contract_ats": [
        "AT-022"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "DEGRADED_LABEL_AMBIGUITY"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "label_match_ambiguity_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-022"
        ]
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "crates/soldier_core/tests/test_label_match.rs"
      ]
    },
    {
      "id": "S3-000",
      "priority": 100,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed)",
      "story_ref": "S3.1 Preflight guard",
      "category": "execution",
      "description": "Implement order-type preflight rules for market/stop/linked orders across instruments.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-013",
        "AT-023",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-004",
        "AT-016",
        "AT-017",
        "AT-018",
        "AT-019",
        "AT-913",
        "AT-914",
        "AT-915",
        "Anchor-013",
        "Anchor-014",
        "Anchor-023",
        "VR-025",
        "VR-026",
        "VR-027"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed) / S3.1 — Preflight guard (market/stop/linked rules)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/preflight.rs",
          "crates/soldier_core/src/execution/order_type_guard.rs",
          "crates/soldier_core/tests/test_preflight.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind=option WHEN order_type is market or stop or trigger fields are present THEN preflight rejects the intent deterministically.",
        "GIVEN instrument_kind in {linear_future,inverse_future,perpetual} WHEN order_type is market OR stop without trigger THEN preflight rejects the intent deterministically.",
        "GIVEN linked_order_type is set and linked orders are not explicitly enabled WHEN preflight runs THEN it rejects the intent and the preflight tests pass.",
        "GIVEN intent construction via build_order_intent WHEN preflight runs THEN it is invoked through a single shared preflight entrypoint (no bypass)."
      ],
      "steps": [
        "Create execution/preflight.rs and execution/order_type_guard.rs and wire them into crates/soldier_core/src/execution/mod.rs.",
        "Implement preflight checks for options and futures/perps per contract, returning explicit rejection reasons.",
        "Reject any linked_order_type unless feature-flagged and capability-enabled (default false).",
        "Add preflight_reject_total{reason} counter for rejects.",
        "Add unit tests in crates/soldier_core/tests/test_preflight.rs for market, stop, linked, and trigger requirements.",
        "Ensure preflight is invoked before any API dispatch path in the execution module.",
        "Expose a single preflight entrypoint (e.g., preflight_intent) and wire build_order_intent to call it."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_preflight"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_preflight output",
        "Unit test asserts reject reasons for market/stop/linked orders"
      ],
      "dependencies": [
        "S2-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-013"
        }
      ],
      "enforcing_contract_ats": [
        "AT-013",
        "AT-023",
        "AT-025",
        "AT-026"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "preflight_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_preflight.rs"
      ]
    },
    {
      "id": "S3-001",
      "priority": 90,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed)",
      "story_ref": "S3.2 Post-only crossing guard",
      "category": "execution",
      "description": "Reject post-only orders that would cross the book deterministically.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-916"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed) / S3.2 — Post‑only crossing guard"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/post_only_guard.rs",
          "crates/soldier_core/tests/test_post_only_guard.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN post_only=true and the limit price would cross the touch WHEN preflight runs THEN it rejects the intent deterministically.",
        "GIVEN post_only=true and the limit price does not cross the touch WHEN preflight runs THEN it allows the intent to pass.",
        "GIVEN post_only crossing scenarios WHEN running tests THEN test_post_only_crossing_rejected passes."
      ],
      "steps": [
        "Create execution/post_only_guard.rs and wire it into crates/soldier_core/src/execution/mod.rs.",
        "Implement crossing detection using best bid/ask touch prices and reject when post_only would cross.",
        "Integrate the post-only guard into the preflight sequence.",
        "Add counter post_only_cross_reject_total for reject metrics.",
        "Add unit tests in crates/soldier_core/tests/test_post_only_guard.rs for crossing and non-crossing cases."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_post_only_guard"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_post_only_guard output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-916"
        }
      ],
      "enforcing_contract_ats": [
        "AT-916"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "post_only_cross_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_post_only_guard.rs"
      ]
    },
    {
      "id": "S3-002",
      "priority": 80,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed)",
      "story_ref": "S3.3 Capabilities matrix + feature flags",
      "category": "execution",
      "description": "Implement venue capabilities to gate linked/OCO orders behind explicit flags.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-028",
        "AT-004",
        "AT-915",
        "Anchor-023",
        "VR-026",
        "VR-027",
        "VR-028"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed) / S3.3 — Capabilities matrix \\+ feature flags"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/venue/capabilities.rs",
          "crates/soldier_core/tests/test_capabilities.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN default configuration WHEN computing capabilities THEN linked/OCO support is false for all instruments.",
        "GIVEN a venue capability and feature flag are both enabled WHEN computing capabilities THEN linked/OCO support is true.",
        "GIVEN the default configuration WHEN running tests THEN test_oco_not_supported passes."
      ],
      "steps": [
        "Create venue/capabilities.rs with a capabilities struct and evaluation helpers.",
        "Expose a feature flag (ENABLE_LINKED_ORDERS_FOR_BOT) to gate linked/OCO support.",
        "Default linked_orders_supported to false unless both capability and feature flag are true.",
        "Add unit tests in crates/soldier_core/tests/test_capabilities.rs for default and enabled behavior.",
        "Wire capabilities into venue module exports for consumption by preflight."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_capabilities"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_capabilities output"
      ],
      "dependencies": [
        "S3-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-028"
        }
      ],
      "enforcing_contract_ats": [
        "AT-028",
        "AT-004",
        "AT-915"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_capabilities.rs"
      ]
    },
    {
      "id": "S4-000",
      "priority": 100,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.1 WAL append + replay no-resend",
      "category": "durability",
      "description": "Persist intents to a durable WAL and replay without resending after crash.",
      "contract_refs": [
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "CONTRACT.md §2.4.1 WAL Writer Isolation (Hot Loop Protection)",
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234",
        "Anchor-004",
        "Anchor-005",
        "Anchor-006",
        "VR-010",
        "VR-014"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.1 — WAL append \\+ replay no-resend"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests"
        ],
        "create": [
          "crates/soldier_infra/src/store"
        ],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN an intent is appended to the durable ledger before dispatch WHEN the system restarts THEN the intent is not resent.",
        "GIVEN the system restarts WHEN reconstructing state from the durable ledger THEN in-flight intents are rebuilt without duplicate dispatch.",
        "GIVEN a recorded intent WHEN persisted THEN the record includes intent_hash, group_id, leg_idx, instrument, side, qty_steps or qty_q, limit_price_q or price_ticks, tls_state, created_ts, sent_ts, ack_ts, last_fill_ts, and exchange_order_id when available.",
        "GIVEN ledger append fails WHEN dispatch is attempted THEN the OPEN intent is rejected and the error counter increments.",
        "GIVEN the WAL writer queue is full WHEN an append is attempted THEN the append returns immediately with an error (hot loop not blocked)."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/ledger.rs with append + replay primitives.",
        "Wire the store module into crates/soldier_infra/src/lib.rs.",
        "Record intents before dispatch (RecordedBeforeDispatch) and mark replay outcomes.",
        "Define the minimum persisted intent schema in ledger storage comments and enforce it in the record struct.",
        "Add unit tests in crates/soldier_infra/tests/test_ledger_replay.rs for no-resend after crash.",
        "Document WAL initialization and replay expectations in module-level comments."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_ledger_replay"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_ledger_replay output"
      ],
      "dependencies": [
        "S3-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
          "location": "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
          "anchor": "AT-935"
        }
      ],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "EXEC_WAL_WRITE_FAILED"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [
          {
            "name": "wal_write_errors",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_ledger_replay.rs"
      ]
    },
    {
      "id": "S4-001",
      "priority": 90,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.2 TLSM out-of-order events",
      "category": "execution",
      "description": "Handle fill-before-ack and out-of-order TLSM events without panic.",
      "contract_refs": [
        "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "AT-230",
        "AT-210",
        "Anchor-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.2 — TLSM out‑of‑order events (fill-before-ack)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/state.rs",
          "crates/soldier_core/src/execution/tlsm.rs",
          "crates/soldier_core/tests/test_tlsm.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs",
          "crates/soldier_core/tests/test_quantize.rs",
          "crates/soldier_core/tests/test_idempotency.rs",
          "crates/soldier_core/tests/test_label.rs",
          "crates/soldier_core/tests/test_label_match.rs"
        ]
      },
      "acceptance": [
        "GIVEN a fill arrives before an ack WHEN processing TLSM events THEN no panic occurs and the final state is Filled.",
        "GIVEN out-of-order TLSM events WHEN applied THEN transitions converge to the correct terminal state deterministically.",
        "GIVEN TLSM transitions are applied WHEN events process THEN each transition is appended to the durable ledger immediately."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/state.rs and tlsm.rs to model TLSM transitions.",
        "Wire TLSM modules into crates/soldier_core/src/execution/mod.rs.",
        "Implement out-of-order handling (fill-before-ack) without panics.",
        "Append each transition to WAL via the infra ledger adapter.",
        "Add unit tests in crates/soldier_core/tests/test_tlsm.rs for fill-before-ack behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_tlsm"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_tlsm output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
          "location": "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
          "anchor": "AT-230"
        }
      ],
      "enforcing_contract_ats": [
        "AT-230",
        "AT-210"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_tlsm.rs"
      ]
    },
    {
      "id": "S4-002",
      "priority": 80,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.3 Trade-ID registry dedupe",
      "category": "durability",
      "description": "Persist processed trade IDs to prevent duplicate processing.",
      "contract_refs": [
        "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
        "AT-269",
        "AT-270",
        "Anchor-007",
        "VR-022"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.3 — Trade‑ID registry dedupe"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests"
        ],
        "create": [
          "crates/soldier_infra/src/store"
        ],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN a trade_id already recorded WHEN handling a trade event THEN it is a NOOP and no duplicate updates occur.",
        "GIVEN a new trade_id WHEN processing a trade THEN trade_id is appended to the durable ledger before applying updates.",
        "GIVEN a restart WHEN the same trade_id is seen again THEN it is ignored due to the registry.",
        "GIVEN concurrent events for the same trade_id WHEN inserting THEN the registry insert is atomic and only one apply occurs."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/trade_id_registry.rs with persistent registry logic.",
        "Wire registry into crates/soldier_infra/src/lib.rs.",
        "Append trade_id before applying TLSM or position updates.",
        "Implement insert-if-absent atomically (single transaction or unique constraint) to avoid double-apply on concurrency.",
        "Add counter trade_id_duplicates_total when a duplicate trade_id is ignored.",
        "Add unit tests in crates/soldier_infra/tests/test_trade_id_registry.rs for dedupe behavior, including a concurrent insert case."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_trade_id_registry"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_trade_id_registry output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
          "location": "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
          "anchor": "AT-269"
        }
      ],
      "enforcing_contract_ats": [
        "AT-269",
        "AT-270"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "trade_id_duplicates_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_trade_id_registry.rs"
      ]
    },
    {
      "id": "S4-003",
      "priority": 70,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.4 Dispatch requires durable WAL barrier",
      "category": "durability",
      "description": "Block dispatch until WAL durability marker when configured.",
      "contract_refs": [
        "CONTRACT.md §2.4.1 WAL Writer Isolation (Hot Loop Protection)",
        "CONTRACT.md §2.4 Durable Intent Ledger",
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234",
        "Anchor-006",
        "VR-014"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.4 — Dispatch requires durable WAL barrier (when configured)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests"
        ],
        "create": [
          "crates/soldier_infra/src/wal.rs"
        ],
        "avoid": [
          "crates/soldier_infra/src/deribit/**",
          "crates/soldier_core/**"
        ]
      },
      "acceptance": [
        "GIVEN the durability barrier config flag is enabled WHEN a caller awaits the durable-append barrier THEN the WAL returns only after the configured durability marker (fsync or equivalent) completes.",
        "GIVEN the durability barrier config flag is disabled WHEN a caller awaits the durable-append barrier THEN the WAL returns immediately after enqueue (no fsync wait).",
        "GIVEN the WAL enqueue queue is full or enqueue fails WHEN append is attempted THEN the WAL returns an error, increments wal_write_errors, and does not block the caller indefinitely."
      ],
      "steps": [
        "Extend the ledger to expose a durable-append barrier API and config flag.",
        "Ensure WAL enqueue failure increments wal_write_errors and returns error without blocking.",
        "Add unit tests in crates/soldier_infra/tests/test_dispatch_durability.rs for barrier behavior.",
        "Document configuration flag require_wal_fsync_before_dispatch in infra config.",
        "Add a helper to surface barrier wait time for observability."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_dispatch_durability"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_dispatch_durability output"
      ],
      "dependencies": [
        "S4-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "RecordedBeforeDispatch is mandatory. DurableBeforeDispatch is required when the durability barrier flag is enabled.",
          "location": "CONTRACT.md §2.4 Durable Intent Ledger",
          "anchor": "AT-935"
        }
      ],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "EXEC_WAL_WRITE_FAILED"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [
          {
            "name": "wal_durability_barrier_wait_ms",
            "type": "histogram",
            "unit": "ms",
            "labels": []
          },
          {
            "name": "wal_write_errors",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_dispatch_durability.rs"
      ]
    },
    {
      "id": "S5-000",
      "priority": 100,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 — Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.1 Liquidity Gate (book-walk WAP, reject sweep)",
      "category": "execution",
      "description": "Implement Liquidity Gate book-walk slippage checks and L2 staleness rejects for OPEN intents.",
      "contract_refs": [
        "CONTRACT.md §1.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
        "CONTRACT.md Rejections due to missing/unparseable/stale L2 MUST use Rejected(LiquidityGateNoL2).",
        "CONTRACT.md AT-222",
        "CONTRACT.md AT-344",
        "CONTRACT.md AT-909",
        "CONTRACT.md AT-421",
        "VR-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 — Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.1 — Liquidity Gate (book-walk WAP, reject sweep)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/gate.rs",
          "crates/soldier_core/tests/test_liquidity_gate.rs"
        ],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN an L2 book where OrderQty implies slippage_bps > max_slippage_bps WHEN Liquidity Gate evaluates an OPEN intent THEN the intent is rejected with Rejected(ExpectedSlippageTooHigh) and no OrderIntent is emitted.",
        "GIVEN L2BookSnapshot is missing, unparseable, or older than l2_book_snapshot_max_age_ms WHEN Liquidity Gate evaluates an OPEN intent THEN it is rejected with Rejected(LiquidityGateNoL2) and dispatch count remains 0.",
        "GIVEN L2 is missing or stale WHEN evaluating intents THEN CANCEL-only proceeds and CLOSE/HEDGE order placement is rejected.",
        "GIVEN Liquidity Gate rejects WHEN evaluated THEN a LiquidityGateReject log entry includes WAP and slippage_bps."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/gate.rs with a Liquidity Gate evaluator that walks L2 depth and computes WAP and slippage_bps.",
        "Validate L2BookSnapshot freshness and structure; treat missing/unparseable/stale snapshots as LiquidityGateNoL2.",
        "Reject OPEN intents when slippage_bps exceeds max_slippage_bps with Rejected(ExpectedSlippageTooHigh).",
        "Emit a LiquidityGateReject log entry that includes WAP and slippage_bps on rejection.",
        "Export the Liquidity Gate from crates/soldier_core/src/execution/mod.rs for chokepoint integration.",
        "Add unit tests in crates/soldier_core/tests/test_liquidity_gate.rs for sweep rejection, no-L2 rejection reason, and cancel vs close/hedge behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_liquidity_gate"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_liquidity_gate output",
        "Assertions in test_liquidity_gate.rs for Rejected(ExpectedSlippageTooHigh) and Rejected(LiquidityGateNoL2)",
        "Captured LiquidityGateReject log entry with WAP and slippage_bps in test output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Reject if slippage_bps > max_slippage_bps (default 10bps).",
          "location": "CONTRACT.md §1.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
          "anchor": "CONTRACT.md §1.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-222",
        "AT-344",
        "AT-909",
        "AT-421"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::ExpectedSlippageTooHigh",
          "RejectReason::LiquidityGateNoL2"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "expected_slippage_bps",
            "type": "histogram",
            "unit": "pct",
            "labels": []
          },
          {
            "name": "liquidity_gate_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_liquidity_gate.rs"
      ]
    },
    {
      "id": "S5-001",
      "priority": 90,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 — Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.2 Fee cache staleness (soft buffer / hard ReduceOnly latch)",
      "category": "risk",
      "description": "Apply fee model cache staleness rules with soft buffering and hard-stale RiskState::Degraded blocks.",
      "contract_refs": [
        "CONTRACT.md §4.2 Fee-Aware Execution",
        "CONTRACT.md Fee Cache Staleness (Fail-Closed)",
        "CONTRACT.md AT-031",
        "CONTRACT.md AT-032",
        "CONTRACT.md AT-033",
        "CONTRACT.md AT-042",
        "CONTRACT.md AT-244",
        "CONTRACT.md AT-246",
        "VR-007"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 — Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.2 — Fee cache staleness (soft buffer / hard ReduceOnly latch)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/deribit/mod.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/state.rs"
        ],
        "create": [
          "crates/soldier_infra/src/deribit/account_summary.rs",
          "crates/soldier_core/src/risk/fees.rs",
          "crates/soldier_core/tests/test_fee_staleness.rs",
          "crates/soldier_core/tests/test_fee_cache.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN fee_model_cache_age_s is in the soft-stale window (fee_cache_soft_s < age <= fee_cache_hard_s) WHEN estimating fees THEN fee_rate_effective applies fee_stale_buffer (0.20).",
        "GIVEN fee_model_cache_age_s > fee_cache_hard_s WHEN evaluating an OPEN intent THEN RiskState::Degraded is set and the OPEN is rejected (fail-closed) with 0 dispatches.",
        "GIVEN fee_model_cached_at_ts_ms is missing or unparseable WHEN staleness is computed THEN it is treated as hard stale and OPEN intents are rejected (fail-closed).",
        "GIVEN fee tier changes WHEN the next polling cycle completes THEN NetEdge uses the updated fee tier within one cycle."
      ],
      "steps": [
        "Add crates/soldier_infra/src/deribit/account_summary.rs to parse /private/get_account_summary and store fee tier data with fee_model_cached_at_ts_ms in epoch ms.",
        "Poll the account summary every 60s and update fee_model_cache_age_s based on now_ms - fee_model_cached_at_ts_ms.",
        "Implement fee staleness logic in crates/soldier_core/src/risk/fees.rs to apply fee_stale_buffer in the soft-stale window.",
        "Treat hard-stale or missing fee_model_cached_at_ts_ms as RiskState::Degraded and expose the flag to Phase 1 dispatch authorization (OPEN blocked, CLOSE/HEDGE/CANCEL allowed).",
        "Add unit tests in crates/soldier_core/tests/test_fee_staleness.rs for soft buffer and hard stale behavior.",
        "Add unit tests in crates/soldier_core/tests/test_fee_cache.rs for missing timestamp handling, epoch-ms restart arithmetic, and fee tier update within one polling cycle."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_fee_staleness",
        "cargo test -p soldier_core --test test_fee_cache"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_fee_staleness output",
        "cargo test -p soldier_core --test test_fee_cache output",
        "Test assertions showing soft-stale fee buffer and hard-stale OPEN rejection"
      ],
      "dependencies": [
        "S5-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Hard stale (age > fee_cache_hard_s): set RiskState::Degraded.",
          "location": "CONTRACT.md §4.2 Fee-Aware Execution",
          "anchor": "CONTRACT.md §4.2 Fee-Aware Execution"
        }
      ],
      "enforcing_contract_ats": [
        "AT-031",
        "AT-032",
        "AT-033",
        "AT-042",
        "AT-244",
        "AT-246"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_FEE_MODEL_HARD_STALE",
          "REDUCEONLY_RISKSTATE_DEGRADED"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "fee_model_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "fee_model_refresh_fail_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_fee_staleness.rs",
        "crates/soldier_core/tests/test_fee_cache.rs"
      ]
    },
    {
      "id": "S5-002",
      "priority": 80,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 — Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.3 NetEdge gate",
      "category": "execution",
      "description": "Reject OPEN intents when net edge after fees and slippage falls below min_edge_usd.",
      "contract_refs": [
        "CONTRACT.md §1.4.1 Net Edge Gate (Fees + Expected Slippage)",
        "CONTRACT.md net_edge_usd = gross_edge_usd - fee_usd - expected_slippage_usd",
        "CONTRACT.md AT-015",
        "CONTRACT.md AT-932",
        "Anchor-018",
        "VR-012",
        "VR-018",
        "VR-019",
        "VR-020"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 — Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.3 — NetEdge gate"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/gates.rs",
          "crates/soldier_core/tests/test_net_edge_gate.rs"
        ],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN net_edge_usd < min_edge_usd WHEN evaluating an OPEN intent THEN it is rejected with Rejected(NetEdgeTooLow) and no dispatch occurs.",
        "GIVEN fee_usd or expected_slippage_usd is missing/unparseable WHEN evaluating an OPEN intent THEN it is rejected with Rejected(NetEdgeInputMissing) and no dispatch occurs.",
        "GIVEN gross_edge_usd is missing/unparseable WHEN evaluating an OPEN intent THEN it is rejected (fail-closed) and no OrderIntent is emitted."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/gates.rs with a NetEdgeGate evaluator.",
        "Compute net_edge_usd from gross_edge_usd, fee_usd, and expected_slippage_usd.",
        "Reject OPEN intents when any NetEdge input is missing/unparseable with Rejected(NetEdgeInputMissing).",
        "Reject OPEN intents when net_edge_usd < min_edge_usd with Rejected(NetEdgeTooLow).",
        "Export NetEdgeGate from crates/soldier_core/src/execution/mod.rs for use in the dispatch chokepoint.",
        "Add unit tests in crates/soldier_core/tests/test_net_edge_gate.rs for low edge rejection, missing inputs, and fees exceeding gross edge."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_net_edge_gate"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_net_edge_gate output",
        "Test assertions for Rejected(NetEdgeTooLow) and Rejected(NetEdgeInputMissing)"
      ],
      "dependencies": [
        "S5-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "net_edge_usd = gross_edge_usd - fee_usd - expected_slippage_usd.",
          "location": "CONTRACT.md §1.4.1 Net Edge Gate (Fees + Expected Slippage)",
          "anchor": "CONTRACT.md §1.4.1 Net Edge Gate (Fees + Expected Slippage)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-015",
        "AT-932"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::NetEdgeTooLow",
          "RejectReason::NetEdgeInputMissing"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "net_edge_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_net_edge_gate.rs"
      ]
    },
    {
      "id": "S5-003",
      "priority": 70,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 — Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.4 IOC limit pricer clamp (guarantee min edge at limit)",
      "category": "execution",
      "description": "Clamp IOC limit prices to guarantee min-edge bounds using the fee-aware pricer.",
      "contract_refs": [
        "CONTRACT.md §1.4 Fee-Aware IOC Limit Pricer (No Market Orders)",
        "CONTRACT.md AT-223"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 — Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.4 — IOC limit pricer clamp (guarantee min edge at limit)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/pricer.rs",
          "crates/soldier_core/tests/test_pricer.rs"
        ],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN net_edge_usd < min_edge_usd WHEN the pricer evaluates an OPEN intent THEN it is rejected with Rejected(NetEdgeTooLow) and no dispatch occurs.",
        "GIVEN fair_price, fee_estimate_usd, min_edge_usd, qty, and side WHEN the pricer computes a limit THEN limit_price is clamped to max_price_for_min_edge and never crosses beyond the min-edge bound.",
        "GIVEN an IOC limit order fills WHEN execution occurs THEN no fill is worse than limit_price and realized edge at limit_price >= min_edge_usd."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/pricer.rs implementing the fee-aware IOC limit pricer.",
        "Compute net_edge_usd and reject OPEN intents when net_edge_usd < min_edge_usd.",
        "Calculate proposed_limit from fair_price +/- 0.5 * net_edge_per_unit and clamp to max_price_for_min_edge.",
        "Return limit_price for IOC dispatch without any market-order fallback.",
        "Export the pricer from crates/soldier_core/src/execution/mod.rs for chokepoint integration.",
        "Add unit tests in crates/soldier_core/tests/test_pricer.rs for clamped limits and min-edge enforcement."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_pricer"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_pricer output",
        "Test assertions showing limit_price clamp and min-edge enforcement"
      ],
      "dependencies": [
        "S5-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Final limit clamped to guarantee min edge at the limit price.",
          "location": "CONTRACT.md §1.4 Fee-Aware IOC Limit Pricer (No Market Orders)",
          "anchor": "CONTRACT.md §1.4 Fee-Aware IOC Limit Pricer (No Market Orders)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-223"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::NetEdgeTooLow"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "pricer_limit_vs_fair_bps",
            "type": "histogram",
            "unit": "pct",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_pricer.rs"
      ]
    },
    {
      "id": "S5-004",
      "priority": 60,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 — Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.5 Enforce single chokepoint build_order_intent() (gate ordering)",
      "category": "execution",
      "description": "Route all dispatch through build_order_intent() and enforce deterministic gate ordering at the chokepoint.",
      "contract_refs": [
        "CONTRACT.md §1.4.1 Net Edge Gate (Fees + Expected Slippage)",
        "CONTRACT.md §1.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
        "CONTRACT.md RecordedBeforeDispatch",
        "CONTRACT.md CSP.5.2 Enforcement Rules"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 — Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.5 — Enforce single chokepoint build_order_intent() (gate ordering)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/build_order_intent.rs",
          "crates/soldier_core/tests/test_gate_ordering.rs",
          "crates/soldier_core/tests/test_phase1_dispatch_auth.rs"
        ],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN build_order_intent is called for an OPEN intent WHEN gates run THEN the sequence is preflight -> quantize -> fee cache check -> Liquidity Gate -> Net Edge Gate -> pricer, and only after all pass does dispatch occur.",
        "GIVEN RiskState::Degraded WHEN an OPEN intent is evaluated at the chokepoint THEN it is rejected and dispatch count remains 0 while CLOSE/HEDGE/CANCEL remain allowed.",
        "GIVEN any dispatch attempt WHEN inspecting code paths THEN build_order_intent is the only constructor used for OrderIntent dispatch (no alternate bypass)."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/build_order_intent.rs to centralize intent construction and gating.",
        "Route all dispatch entry points through build_order_intent and return early on gate failures.",
        "Implement a deterministic gate sequence trace used by test_gate_ordering_call_log.",
        "Enforce Phase 1 dispatch authorization: if RiskState != Healthy, reject OPEN intents and allow CLOSE/HEDGE/CANCEL.",
        "Ensure intent recording occurs before any network dispatch (RecordedBeforeDispatch).",
        "Restrict dispatch helpers to pub(crate) and update module exports to prevent bypass.",
        "Add tests in crates/soldier_core/tests/test_gate_ordering.rs and test_phase1_dispatch_auth.rs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_gate_ordering",
        "cargo test -p soldier_core --test test_phase1_dispatch_auth"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_gate_ordering output",
        "cargo test -p soldier_core --test test_phase1_dispatch_auth output",
        "Gate sequence trace assertions showing ordered steps"
      ],
      "dependencies": [
        "S5-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "This gate MUST run before any OrderIntent is eligible for dispatch.",
          "location": "CONTRACT.md §1.4.1 Net Edge Gate (Fees + Expected Slippage)",
          "anchor": "CONTRACT.md §1.4.1 Net Edge Gate (Fees + Expected Slippage)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-015"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_RISKSTATE_DEGRADED"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "gate_sequence_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_gate_ordering.rs",
        "crates/soldier_core/tests/test_phase1_dispatch_auth.rs"
      ]
    },
    {
      "id": "S6-000",
      "priority": 95,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-A Single Dispatch Chokepoint Proof",
      "category": "hardening",
      "description": "Implement CI tests proving exactly one module/function may dispatch exchange orders with no bypass paths.",
      "contract_refs": [
        "RecordedBeforeDispatch",
        "AT-935",
        "Anchor-006",
        "VR-014",
        "1. Execution Architecture: The \"Atomic Group\" (Real-Time Repair)"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/tests/test_dispatch_chokepoint.rs",
          "docs/dispatch_chokepoint.md"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_dispatch_chokepoint_no_direct_exchange_client_usage runs WHEN exchange client is imported outside chokepoint module THEN test fails.",
        "GIVEN test_dispatch_visibility_is_restricted runs WHEN dispatch function is public beyond pub(crate) THEN test fails.",
        "GIVEN docs/dispatch_chokepoint.md exists WHEN reviewed THEN it names the exact module, function, and exchange client type."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_dispatch_chokepoint.rs with AST/grep checks for exchange client usage.",
        "Implement test_dispatch_chokepoint_no_direct_exchange_client_usage that fails if exchange client constructed outside chokepoint.",
        "Implement test_dispatch_visibility_is_restricted that fails if dispatch fn is not pub(crate).",
        "Create docs/dispatch_chokepoint.md documenting the chokepoint module, function, and normative statement.",
        "Run tests and verify they pass on compliant code."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_chokepoint"
      ],
      "evidence": [
        "cargo test output showing test_dispatch_chokepoint_no_direct_exchange_client_usage PASS",
        "cargo test output showing test_dispatch_visibility_is_restricted PASS",
        "docs/dispatch_chokepoint.md exists with required content"
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_dispatch_chokepoint.rs"
      ]
    },
    {
      "id": "S6-001",
      "priority": 94,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-B Determinism Snapshot Test",
      "category": "hardening",
      "description": "Implement CI test proving identical inputs produce identical intent bytes/hashes across runs and restarts.",
      "contract_refs": [
        "CSP.2.1 Stable Intent Identity",
        "1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "evidence/phase1/determinism/intent_hashes.txt"
        ],
        "create": [
          "crates/soldier_core/tests/test_intent_determinism.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_intent_determinism_same_inputs_same_hash runs with fixed inputs and frozen clock WHEN executed twice THEN intent hash is identical.",
        "GIVEN test runs across process restart WHEN inputs are identical THEN hash is identical.",
        "GIVEN HashMap iteration order varies WHEN intent is built THEN hash is still identical (no map ordering dependency)."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_intent_determinism.rs.",
        "Implement test_intent_determinism_same_inputs_same_hash with clock injection.",
        "Use deterministic seed/inputs and assert exact byte equality or hash equality.",
        "Emit hash values to evidence/phase1/determinism/intent_hashes.txt.",
        "Run test twice and verify hashes match."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_intent_determinism"
      ],
      "evidence": [
        "cargo test output showing test_intent_determinism_same_inputs_same_hash PASS",
        "evidence/phase1/determinism/intent_hashes.txt showing identical hashes"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_intent_determinism.rs"
      ]
    },
    {
      "id": "S6-002",
      "priority": 93,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-C No Partial Side Effects on Rejection",
      "category": "hardening",
      "description": "Implement CI test proving rejected intents leave no persistent state changes except counters/logs.",
      "contract_refs": [
        "RecordedBeforeDispatch",
        "AT-201",
        "Anchor-006",
        "1.2 Atomic Group Executor"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/tests/test_rejection_side_effects.rs",
          "evidence/phase1/no_side_effects/rejection_cases.md"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_rejected_intent_has_no_side_effects runs for missing config rejection THEN WAL unchanged, no orders, no position delta.",
        "GIVEN test runs for invalid instrument meta rejection THEN same assertions hold.",
        "GIVEN test runs for quantization failure rejection THEN same assertions hold.",
        "GIVEN evidence/phase1/no_side_effects/rejection_cases.md exists THEN it lists at least 3 rejection cases with CI links."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_rejection_side_effects.rs.",
        "Implement test_rejected_intent_has_no_side_effects with parameterized rejection cases.",
        "Assert: WAL unchanged, no open orders, no position deltas, no exposure increments.",
        "Create evidence/phase1/no_side_effects/rejection_cases.md documenting 3+ cases.",
        "Link CI logs in the evidence doc."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_rejection_side_effects"
      ],
      "evidence": [
        "cargo test output showing test_rejected_intent_has_no_side_effects PASS",
        "evidence/phase1/no_side_effects/rejection_cases.md with 3+ cases"
      ],
      "dependencies": [
        "S6-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_rejection_side_effects.rs"
      ]
    },
    {
      "id": "S6-003",
      "priority": 92,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-D intent_id/run_id Propagation Contract",
      "category": "hardening",
      "description": "Implement CI test proving every intent-handling log/metric includes the same intent_id and run_id.",
      "contract_refs": [
        "0.Z.7.4 Observability Requirement"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [],
        "create": [
          "evidence/phase1/traceability/sample_rejection_log.txt",
          "crates/soldier_core/tests/test_intent_id_propagation.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_intent_id_propagates_to_logs_and_metrics triggers a rejected intent WHEN logs are captured THEN every log line includes identical intent_id.",
        "GIVEN metrics are emitted during intent handling WHEN inspected THEN they include intent_id label.",
        "GIVEN evidence/phase1/traceability/sample_rejection_log.txt exists THEN it shows consistent intent_id across all log lines."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_intent_id_propagation.rs.",
        "Implement test_intent_id_propagates_to_logs_and_metrics with log capture.",
        "Trigger a rejection and collect all logs/metrics from the intent span.",
        "Assert all entries include the same intent_id.",
        "Emit sample log to evidence/phase1/traceability/sample_rejection_log.txt."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_intent_id_propagation"
      ],
      "evidence": [
        "cargo test output showing test_intent_id_propagates_to_logs_and_metrics PASS",
        "evidence/phase1/traceability/sample_rejection_log.txt"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "intent_id_propagation_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_intent_id_propagation.rs"
      ]
    },
    {
      "id": "S6-004",
      "priority": 91,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-E Gate Ordering Constraints",
      "category": "hardening",
      "description": "Implement CI test and doc proving gate ordering invariants: reject before persist, WAL before dispatch.",
      "contract_refs": [
        "CONTRACT.md RecordedBeforeDispatch",
        "CONTRACT.md CSP.5.2 Enforcement Rules",
        "Anchor-006",
        "VR-014"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/tests/test_gate_ordering.rs",
          "docs/intent_gate_invariants.md"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_gate_ordering_constraints runs WHEN a side effect occurs before final accept THEN test fails.",
        "GIVEN WAL commit is attempted after dispatch WHEN test runs THEN test fails.",
        "GIVEN docs/intent_gate_invariants.md exists THEN it states the 3 normative ordering constraints."
      ],
      "steps": [
        "Extend or create crates/soldier_core/tests/test_gate_ordering.rs.",
        "Implement test_gate_ordering_constraints with instrumented gate/side-effect events.",
        "Assert: reject gates before persist, WAL before dispatch, no side effects before accept.",
        "Create docs/intent_gate_invariants.md with normative statements.",
        "Run test and verify pass."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_gate_ordering"
      ],
      "evidence": [
        "cargo test output showing test_gate_ordering_constraints PASS",
        "docs/intent_gate_invariants.md with 3 normative statements"
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_gate_ordering.rs"
      ]
    },
    {
      "id": "S6-005",
      "priority": 90,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-F Fail-Closed Defaults for Missing Config",
      "category": "hardening",
      "description": "Implement CI test proving missing critical config causes fail-closed rejection with enumerated reason code.",
      "contract_refs": [
        "Appendix A",
        "Appendix A: Configuration Defaults (Safety-Critical Thresholds)"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "evidence/phase1/config_fail_closed/missing_keys_matrix.json"
        ],
        "create": [
          "crates/soldier_core/tests/test_missing_config.rs",
          "docs/critical_config_keys.md"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_missing_config_fails_closed runs for each critical key WHEN key is removed THEN intent rejected.",
        "GIVEN rejection occurs THEN no persistent side effects (WAL, orders, positions).",
        "GIVEN rejection occurs THEN reject reason is enumerated (not free text).",
        "GIVEN evidence/phase1/config_fail_closed/missing_keys_matrix.json exists THEN it shows PASS/FAIL + reason code per key."
      ],
      "steps": [
        "Create docs/critical_config_keys.md listing Phase-1 critical config keys.",
        "Create crates/soldier_core/tests/test_missing_config.rs.",
        "Implement test_missing_config_fails_closed parameterized over critical keys.",
        "Assert rejection, no side effects, enumerated reason code.",
        "Emit evidence/phase1/config_fail_closed/missing_keys_matrix.json from test."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_missing_config"
      ],
      "evidence": [
        "cargo test output showing test_missing_config_fails_closed PASS",
        "evidence/phase1/config_fail_closed/missing_keys_matrix.json",
        "docs/critical_config_keys.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "CONFIG_MISSING"
        ]
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_missing_config.rs"
      ]
    },
    {
      "id": "S6-006",
      "priority": 89,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 — Phase 1 Hardening Gates",
      "story_ref": "P1-G Minimal Crash-Mid-Intent Proof",
      "category": "hardening",
      "description": "Implement CI test or drill proving crash mid-intent before dispatch causes no duplicate dispatch on restart.",
      "contract_refs": [
        "AT-935",
        "AT-233",
        "2.4 — WAL / intent ledger (RecordedBeforeDispatch)"
      ],
      "plan_refs": [
        "Phase 1 — Foundation (Panic‑Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [],
        "create": [
          "evidence/phase1/crash_mid_intent/drill.md",
          "crates/soldier_infra/tests/test_crash_mid_intent.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_crash_mid_intent_no_duplicate_dispatch runs WHEN process crashes before dispatch THEN restart produces no dispatch.",
        "GIVEN crash occurs mid-intent THEN no ghost state or unsafe opens on restart.",
        "IF AUTO test not feasible THEN evidence/phase1/crash_mid_intent/drill.md documents manual drill with proof logs."
      ],
      "steps": [
        "Create crates/soldier_infra/tests/test_crash_mid_intent.rs (preferred AUTO).",
        "Implement test_crash_mid_intent_no_duplicate_dispatch simulating crash before dispatch.",
        "Assert: no dispatch on restart, no side effects beyond counters/logs.",
        "If AUTO not feasible, document manual drill in evidence/phase1/crash_mid_intent/drill.md.",
        "Include trigger, restart steps, and proof logs in drill doc."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_crash_mid_intent"
      ],
      "evidence": [
        "cargo test output showing test_crash_mid_intent_no_duplicate_dispatch PASS",
        "OR evidence/phase1/crash_mid_intent/drill.md with recorded proof"
      ],
      "dependencies": [
        "S4-000",
        "S4-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_crash_mid_intent.rs"
      ]
    }
  ]
}
