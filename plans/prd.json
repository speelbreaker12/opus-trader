{
  "project": "StoicTrader",
  "source": { "implementation_plan_path": "IMPLEMENTATION_PLAN.md" },
  "rules": {
    "one_story_per_iteration": true,
    "one_commit_per_story": true,
    "no_prd_rewrite": true,
    "passes_only_flips_after_verify_green": true
  },
  "items": [
    {
      "id": "S1-000",
      "priority": 100,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 - Instrument Units + Dispatcher Invariants",
      "story_ref": "S1-000 Bootstrap verify script",
      "category": "workflow",
      "description": "Create plans/verify.sh that mirrors repo CI gates and is executable (read CI config, do not modify it).",
      "scope": { "touch": ["plans/verify.sh"], "avoid": [] },
      "acceptance": [
        "verify.sh mirrors CI gates and order",
        "verify.sh is executable and fail-fast",
        "CI config is read-only (do not modify .github/workflows)",
        "If CI gates cannot be determined with high confidence, output exactly: <promise>BLOCKED_CI_COMMANDS</promise> and do not mark passing"
      ],
      "steps": [
        "Read .github/workflows/* to determine CI gates and order.",
        "Read Makefile/Taskfile and scripts/ for test/format/lint entrypoints.",
        "Read docs/ and README for CI guidance.",
        "Draft plans/verify.sh with fail-fast shell settings and the CI gate order.",
        "If CI gates are unclear, emit the required BLOCKED promise and stop."
      ],
      "verify": [
        "bash -n plans/verify.sh",
        "chmod +x plans/verify.sh",
        "./plans/verify.sh"
      ],
      "evidence": [
        "plans/verify.sh exists with CI gate order and fail-fast settings",
        "Command output from bash -n plans/verify.sh"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S1-001a",
      "priority": 92,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 - Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.1a InstrumentKind derivation",
      "category": "execution",
      "description": "Derive InstrumentKind from venue metadata and treat linear perpetuals as linear_future.",
      "scope": {
        "touch": [
          "crates/soldier_core/venue/**",
          "crates/soldier_infra/deribit/public/**",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "InstrumentKind derives option|linear_future|inverse_future|perpetual from venue metadata",
        "Linear perpetuals (USDC-margined) map to linear_future for sizing",
        "test_linear_perp_treated_as_linear_future passes"
      ],
      "steps": [
        "Locate instrument metadata structures in crates/soldier_core/venue/** and crates/soldier_infra/deribit/public/**.",
        "Implement InstrumentKind derivation from venue metadata.",
        "Apply linear perpetual mapping to linear_future in the sizing path.",
        "Add unit test test_linear_perp_treated_as_linear_future in crates/soldier_core/tests/test_instrument_kind_mapping.rs.",
        "Run the targeted test and plans/verify.sh."
      ],
      "verify": [
        "cargo test -p soldier_core --test test_instrument_kind_mapping test_linear_perp_treated_as_linear_future",
        "./plans/verify.sh"
      ],
      "evidence": [
        "Test output from cargo test -p soldier_core --test test_instrument_kind_mapping test_linear_perp_treated_as_linear_future",
        "Code change showing InstrumentKind derived from venue metadata"
      ],
      "dependencies": ["S1-000"],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S1-001b",
      "priority": 90,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 - Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.1b Instrument cache TTL fail-closed",
      "category": "risk",
      "description": "Fail-closed on instrument cache TTL breach by setting RiskState::Degraded and emitting a structured log.",
      "scope": {
        "touch": [
          "crates/soldier_core/venue/**",
          "crates/soldier_infra/deribit/public/**",
          "crates/soldier_core/risk/state.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "Instrument cache TTL breach sets RiskState::Degraded",
        "A structured log is emitted when the instrument cache is stale",
        "test_stale_instrument_cache_sets_degraded passes"
      ],
      "steps": [
        "Locate instrument cache TTL configuration and age calculation in the venue metadata path.",
        "Implement a TTL breach check for the instrument cache.",
        "On stale cache, set RiskState::Degraded via crates/soldier_core/risk/state.rs and emit a structured log.",
        "Add unit test test_stale_instrument_cache_sets_degraded in crates/soldier_core/tests/test_instrument_cache_ttl.rs.",
        "Run the targeted test and plans/verify.sh."
      ],
      "verify": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl test_stale_instrument_cache_sets_degraded",
        "./plans/verify.sh"
      ],
      "evidence": [
        "Test output from cargo test -p soldier_core --test test_instrument_cache_ttl test_stale_instrument_cache_sets_degraded",
        "Structured log line showing instrument cache TTL breach"
      ],
      "dependencies": ["S1-001a"],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S1-001c",
      "priority": 88,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 - Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.1c Instrument cache observability",
      "category": "ops",
      "description": "Add instrument cache observability metrics for hits, staleness, and cache age.",
      "scope": {
        "touch": [
          "crates/soldier_core/venue/**",
          "crates/soldier_core/**"
        ],
        "avoid": []
      },
      "acceptance": [
        "instrument_cache_hits_total counter increments on cache hit",
        "instrument_cache_stale_total counter increments on stale detection",
        "instrument_cache_age_s gauge records cache age in seconds"
      ],
      "steps": [
        "Locate the metrics/telemetry interface used in crates/soldier_core/**.",
        "Emit instrument_cache_hits_total and instrument_cache_stale_total counters in the cache access path.",
        "Record instrument_cache_age_s gauge from computed cache age in seconds.",
        "Ensure metric names and labels align with existing telemetry conventions.",
        "Run plans/verify.sh."
      ],
      "verify": [
        "./plans/verify.sh"
      ],
      "evidence": [
        "Metric export or log snapshot showing instrument_cache_hits_total and instrument_cache_stale_total",
        "Metric export or log snapshot showing instrument_cache_age_s"
      ],
      "dependencies": ["S1-001b"],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S1-002",
      "priority": 80,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 - Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize canonical sizing",
      "category": "execution",
      "description": "Implement OrderSize canonical sizing and notional_usd invariant.",
      "scope": {
        "touch": [
          "crates/soldier_core/execution/order_size.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "OrderSize { contracts, qty_coin, qty_usd, notional_usd } is implemented and populated deterministically",
        "Canonical units: option|linear_future use qty_coin; perpetual|inverse_future use qty_usd",
        "test_order_size_option_perp_canonical_amount passes"
      ],
      "steps": [
        "Review crates/soldier_core/execution/order_size.rs and existing sizing logic.",
        "Implement OrderSize fields and canonical amount selection by InstrumentKind.",
        "Compute notional_usd deterministically for all instrument kinds.",
        "Add unit test test_order_size_option_perp_canonical_amount in crates/soldier_core/tests/test_order_size.rs.",
        "Run the targeted test and plans/verify.sh."
      ],
      "verify": [
        "cargo test -p soldier_core --test test_order_size test_order_size_option_perp_canonical_amount",
        "./plans/verify.sh"
      ],
      "evidence": [
        "Test output from cargo test -p soldier_core --test test_order_size test_order_size_option_perp_canonical_amount",
        "OrderSize notional_usd computation shown in code or test assertion"
      ],
      "dependencies": ["S1-001a"],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S1-003",
      "priority": 70,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 - Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher amount mapping",
      "category": "execution",
      "description": "Map dispatcher amounts to one canonical field and reject mismatches by degrading risk state.",
      "scope": {
        "touch": [
          "crates/soldier_core/execution/dispatch_map.rs",
          "crates/soldier_core/execution/order_size.rs",
          "crates/soldier_core/risk/state.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "Outbound Deribit request sends exactly one canonical amount field",
        "If contracts and canonical amount both exist and mismatch, the intent is rejected and RiskState::Degraded is set",
        "order_intent_reject_unit_mismatch_total increments on mismatch",
        "test_dispatch_amount_field_coin_vs_usd and test_order_size_mismatch_rejects_and_degrades pass"
      ],
      "steps": [
        "Review crates/soldier_core/execution/dispatch_map.rs and Deribit request mapping.",
        "Select the canonical amount field using OrderSize and InstrumentKind.",
        "Detect amount mismatch; on mismatch reject the intent, set RiskState::Degraded, and increment order_intent_reject_unit_mismatch_total.",
        "Add tests test_dispatch_amount_field_coin_vs_usd and test_order_size_mismatch_rejects_and_degrades in their respective test files.",
        "Run the targeted tests and plans/verify.sh."
      ],
      "verify": [
        "cargo test -p soldier_core --test test_dispatch_map test_dispatch_amount_field_coin_vs_usd",
        "cargo test -p soldier_core --test test_order_size test_order_size_mismatch_rejects_and_degrades",
        "./plans/verify.sh"
      ],
      "evidence": [
        "Test output from cargo test -p soldier_core --test test_dispatch_map test_dispatch_amount_field_coin_vs_usd",
        "Test output from cargo test -p soldier_core --test test_order_size test_order_size_mismatch_rejects_and_degrades"
      ],
      "dependencies": ["S1-002"],
      "est_size": "M",
      "risk": "high",
      "needs_human_decision": false,
      "passes": false
    }
  ]
}
