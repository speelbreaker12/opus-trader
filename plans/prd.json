{
  "project": "StoicTrader",
  "source": {
    "implementation_plan_path": "IMPLEMENTATION_PLAN.md",
    "contract_path": "CONTRACT.md"
  },
  "rules": {
    "one_story_per_iteration": true,
    "one_commit_per_story": true,
    "no_prd_rewrite": true,
    "passes_only_flips_after_verify_green": true
  },
  "items": [
    {
      "id": "S1-000",
      "priority": 100,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Verify harness baseline",
      "category": "workflow",
      "description": "Confirm plans/verify.sh is the canonical verification script and runnable.",
      "contract_refs": [
        "CONTRACT.md 0.Y Verification Harness (Non-Negotiable)",
        "Anchor-002",
        "VR-001"
      ],
      "plan_refs": [
        "Test harness configured (cargo test \\--workspace)."
      ],
      "scope": {
        "touch": [
          "plans/verify.sh"
        ],
        "avoid": [
          "crates/**",
          "python/**",
          "specs/**"
        ]
      },
      "acceptance": [
        "GIVEN plans/verify.sh exists WHEN running `bash -n plans/verify.sh` THEN it exits 0.",
        "GIVEN plans/verify.sh is executable WHEN running `./plans/verify.sh` THEN it completes without error on a clean workspace.",
        "GIVEN plans/verify.sh defines the test gate WHEN inspecting its contents THEN it includes `cargo test --workspace`."
      ],
      "steps": [
        "Check that plans/verify.sh exists in the repo root.",
        "Inspect plans/verify.sh for the Rust test command and compare with the plan entry criteria.",
        "Add or update the `cargo test --workspace` command in plans/verify.sh if missing.",
        "Ensure plans/verify.sh is executable (chmod +x).",
        "Run `bash -n plans/verify.sh` to validate shell syntax.",
        "Run `./plans/verify.sh` to confirm the baseline is green."
      ],
      "verify": [
        "./plans/verify.sh",
        "bash -n plans/verify.sh",
        "rg -n \"cargo test --workspace\" plans/verify.sh"
      ],
      "evidence": [
        "bash -n plans/verify.sh output",
        "Execution output of ./plans/verify.sh",
        "rg output showing cargo test --workspace present in plans/verify.sh"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-001",
      "priority": 90,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Workspace scaffolding",
      "category": "infra",
      "description": "Initialize the Rust workspace with soldier_core and soldier_infra crates.",
      "contract_refs": [
        "CONTRACT.md 0.X Repository Layout & Canonical Module Mapping (Non-Negotiable)",
        "Anchor-001"
      ],
      "plan_refs": [
        "Rust workspace exists with crates/soldier\\_core, crates/soldier\\_infra."
      ],
      "scope": {
        "touch": [
          "Cargo.toml",
          ".gitignore",
          "crates/soldier_core/Cargo.toml",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_infra/Cargo.toml",
          "crates/soldier_infra/src/lib.rs",
          "plans/verify.sh"
        ],
        "avoid": [
          "python/**",
          "specs/**",
          "artifacts/**"
        ]
      },
      "acceptance": [
        "GIVEN the workspace is configured WHEN running `cargo test --workspace` THEN it builds and exits 0.",
        "GIVEN Cargo.toml is inspected WHEN reading workspace members THEN it includes crates/soldier_core and crates/soldier_infra.",
        "GIVEN plans/verify.sh is run WHEN invoked from repo root THEN it executes `cargo test --workspace` and passes."
      ],
      "steps": [
        "Create the crates/ directory if it does not exist.",
        "Initialize crates/soldier_core as a Rust library crate.",
        "Initialize crates/soldier_infra as a Rust library crate.",
        "Create or update the root Cargo.toml with a workspace members list including both crates.",
        "Update plans/verify.sh to run `cargo test --workspace` if needed.",
        "Run `cargo test --workspace` to confirm the workspace builds."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test --workspace output",
        "Execution output of ./plans/verify.sh"
      ],
      "dependencies": [
        "S1-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-002",
      "priority": 80,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 InstrumentKind and RiskState",
      "category": "execution",
      "description": "Implement InstrumentKind derivation and RiskState enum per contract definitions.",
      "contract_refs": [
        "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
        "CONTRACT.md RiskState (health/cause layer): `Healthy | Degraded | Maintenance | Kill`",
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract) — MUST implement",
        "Anchor-010",
        "VR-010"
      ],
      "plan_refs": [
        "S1.1 — InstrumentKind derivation \\+ instrument cache TTL (fail‑closed)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/src/risk/state.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs",
          "crates/soldier_infra/src/deribit/public/mod.rs",
          "crates/soldier_infra/src/deribit/mod.rs",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/Cargo.toml"
        ],
        "avoid": [
          "crates/soldier_core/execution/**",
          "crates/soldier_core/policy/**"
        ]
      },
      "acceptance": [
        "GIVEN Deribit metadata for a USDC-margined perpetual WHEN deriving InstrumentKind THEN it returns linear_future.",
        "GIVEN metadata for option, perpetual, inverse_future, and linear_future instruments WHEN deriving InstrumentKind THEN it maps to the contract enum values.",
        "GIVEN the RiskState enum WHEN compiled THEN it includes Healthy, Degraded, Maintenance, and Kill variants."
      ],
      "steps": [
        "Define the RiskState enum in crates/soldier_core/risk/state.rs with the contract variants.",
        "Define the InstrumentKind enum in crates/soldier_core/venue/types.rs with contract values.",
        "Define the minimal Deribit public instrument structs needed for mapping in crates/soldier_infra/deribit/public.",
        "Implement conversion logic from Deribit instrument metadata to InstrumentKind, including linear perpetual → linear_future.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_kind_mapping.rs for mapping behavior.",
        "Wire any required imports so the new enums are accessible where used."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_kind_mapping"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_kind_mapping output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-003",
      "priority": 70,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL",
      "category": "risk",
      "description": "Enforce InstrumentCache TTL and degrade RiskState on stale metadata.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
        "CONTRACT.md RiskState (health/cause layer): `Healthy | Degraded | Maintenance | Kill`",
        "Anchor-011",
        "VR-011"
      ],
      "plan_refs": [
        "S1.1 — InstrumentKind derivation \\+ instrument cache TTL (fail‑closed)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN cached instrument metadata older than the configured TTL WHEN accessed THEN RiskState::Degraded is returned for that lookup (test_stale_instrument_cache_sets_degraded).",
        "GIVEN cached metadata within TTL WHEN accessed THEN RiskState::Healthy is returned alongside the metadata.",
        "GIVEN cache access WHEN processing THEN the cache age is compared against instrument_cache_ttl_s deterministically."
      ],
      "steps": [
        "Locate or create the InstrumentCache structure in crates/soldier_core/venue.",
        "Add timestamp tracking for cache insert/update and compute cache age on read; record instrument_cache_age_s and increment instrument_cache_hits_total.",
        "Compare cache age to TTL and return RiskState::Degraded when stale.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_cache_ttl.rs for fresh vs stale behavior.",
        "Add or update a test to assert cache age comparisons against instrument_cache_ttl_s are deterministic."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl output",
        "Unit test asserts RiskState::Degraded on stale metadata",
        "Unit test asserts instrument_cache_ttl_s comparison is deterministic"
      ],
      "dependencies": [
        "S1-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-006",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL observability",
      "category": "risk",
      "description": "Add required TTL observability hooks for instrument cache freshness.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) — MUST implement",
        "Anchor-011",
        "VR-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 1 — Instrument Units \\+ Dispatcher Invariants / S1.1 — InstrumentKind derivation \\+ instrument cache TTL (fail‑closed)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN a TTL breach WHEN processing THEN a structured log InstrumentCacheTtlBreach{instrument_id, age_s, ttl_s} is emitted.",
        "GIVEN any cache access WHEN processing THEN instrument_cache_hits_total increments and instrument_cache_age_s is updated.",
        "GIVEN a stale access WHEN processing THEN instrument_cache_stale_total increments."
      ],
      "steps": [
        "Emit a structured log InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s on staleness.",
        "Increment instrument_cache_hits_total on every cache access.",
        "Update instrument_cache_age_s gauge with computed cache age.",
        "Increment instrument_cache_stale_total on staleness.",
        "Add test assertions in crates/soldier_core/tests/test_instrument_cache_ttl.rs for the log event.",
        "Add test assertions for metric increments and gauge updates using an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl output",
        "Log capture shows InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s",
        "Unit test asserts instrument_cache_hits_total and instrument_cache_stale_total increments",
        "Unit test asserts instrument_cache_age_s gauge update"
      ],
      "dependencies": [
        "S1-003"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-004",
      "priority": 60,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize canonical sizing",
      "category": "execution",
      "description": "Implement OrderSize canonical sizing with deterministic notional_usd using the discovery report.",
      "contract_refs": [
        "CONTRACT.md OrderSize struct (MUST implement):",
        "CONTRACT.md Canonical internal units (single source of truth):",
        "Anchor-012",
        "VR-010"
      ],
      "plan_refs": [
        "S1.2 — OrderSize canonical sizing \\+ notional invariant"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_infra/**",
          "crates/soldier_core/venue/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind option or linear_future WHEN building OrderSize THEN qty_coin is canonical and notional_usd = qty_coin * index_price.",
        "GIVEN instrument_kind perpetual or inverse_future WHEN building OrderSize THEN qty_usd is canonical and notional_usd = qty_usd.",
        "GIVEN any OrderSize WHEN built THEN notional_usd is always populated and internal fields are consistent with the contract invariants."
      ],
      "steps": [
        "Review docs/order_size_discovery.md for current gaps and proposed tests.",
        "Create crates/soldier_core/execution/order_size.rs if missing.",
        "Define the OrderSize struct with contracts, qty_coin, qty_usd, and notional_usd.",
        "Implement a constructor/builder that computes canonical units based on InstrumentKind.",
        "Populate notional_usd deterministically using index_price for coin-sized instruments.",
        "Add a debug log OrderSizeComputed{instrument_kind, notional_usd}.",
        "Add unit tests in crates/soldier_core/tests/test_order_size.rs for canonical sizing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_order_size output"
      ],
      "dependencies": [
        "S1-002",
        "S1-008"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-005",
      "priority": 50,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher amount mapping",
      "category": "execution",
      "description": "Map OrderSize to Deribit request amounts using the discovery report.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
        "Anchor-010",
        "VR-010"
      ],
      "plan_refs": [
        "S1.3 — Dispatcher amount mapping \\+ mismatch reject→Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs"
        ],
        "avoid": [
          "crates/soldier_core/risk/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN option or linear_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_coin.",
        "GIVEN perpetual or inverse_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_usd.",
        "GIVEN any OrderSize WHEN mapping THEN exactly one canonical amount field is set and the other is unset."
      ],
      "steps": [
        "Review docs/dispatch_map_discovery.md for current gaps and proposed tests.",
        "Create or update crates/soldier_core/execution/dispatch_map.rs with OrderSize mapping logic.",
        "Implement the rule: exactly one canonical amount field is sent per instrument_kind.",
        "Ensure outbound request uses qty_coin for option/linear_future and qty_usd for perpetual/inverse_future.",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for amount field selection.",
        "Add a negative test asserting no second amount field is set."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_dispatch_map output"
      ],
      "dependencies": [
        "S1-004",
        "S1-009"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-007",
      "priority": 55,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mismatch rejection",
      "category": "execution",
      "description": "Reject contract/amount mismatches and emit mismatch metrics.",
      "contract_refs": [
        "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
        "CONTRACT.md RiskState (health/cause layer): `Healthy | Degraded | Maintenance | Kill`",
        "Anchor-010",
        "VR-010"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 1 — Instrument Units \\+ Dispatcher Invariants / S1.3 — Dispatcher amount mapping \\+ mismatch reject→Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_core/risk/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN contracts and canonical amount mismatch WHEN mapping THEN the intent is rejected and RiskState::Degraded is returned (fail-closed).",
        "GIVEN a mismatch rejection WHEN processing THEN order_intent_reject_unit_mismatch_total increments.",
        "GIVEN a mismatch rejection WHEN processing THEN the error is surfaced to callers with a deterministic reason code."
      ],
      "steps": [
        "Validate contracts vs canonical amount and return an error with RiskState::Degraded on mismatch.",
        "Define a deterministic error reason for unit mismatches to surface to callers.",
        "Increment order_intent_reject_unit_mismatch_total for mismatch rejections.",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for mismatch rejection behavior.",
        "Add or update unit tests in crates/soldier_core/tests/test_order_size.rs for mismatch cases.",
        "Assert the metric increment via an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_dispatch_map output",
        "cargo test -p soldier_core --test test_order_size output",
        "Unit test asserts order_intent_reject_unit_mismatch_total increment"
      ],
      "dependencies": [
        "S1-005"
      ],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-008",
      "priority": 95,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize discovery",
      "category": "qa",
      "description": "Discover current OrderSize logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "1.0 Instrument Units",
        "Anchor-012"
      ],
      "plan_refs": [
        "S1.2 — OrderSize canonical sizing \\+ notional invariant"
      ],
      "scope": {
        "touch": [
          "docs/**"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN the current OrderSize implementation WHEN inspected THEN docs/order_size_discovery.md lists current fields, call sites, and gaps vs the contract OrderSize struct.",
        "GIVEN contract unit invariants WHEN inspected THEN docs/order_size_discovery.md lists required tests to add for canonical sizing.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff needed for OrderSize canonical sizing."
      ],
      "steps": [
        "Locate current OrderSize logic and any related helpers in the codebase.",
        "Identify call sites that construct OrderSize or size fields.",
        "Draft docs/order_size_discovery.md with: current fields, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align OrderSize with contract invariants.",
        "Keep the report scoped to OrderSize and sizing invariants only."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -f docs/order_size_discovery.md",
        "rg -n \"OrderSize\" docs/order_size_discovery.md"
      ],
      "evidence": [
        "docs/order_size_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S1-009",
      "priority": 85,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 — Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mapping discovery",
      "category": "qa",
      "description": "Discover current dispatcher mapping logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
        "Anchor-010"
      ],
      "plan_refs": [
        "S1.3 — Dispatcher amount mapping \\+ mismatch reject→Degraded"
      ],
      "scope": {
        "touch": [
          "docs/**"
        ],
        "avoid": [
          "crates/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN the current dispatch mapping WHEN inspected THEN docs/dispatch_map_discovery.md lists current amount field logic and contract gaps.",
        "GIVEN contract mapping rules WHEN inspected THEN docs/dispatch_map_discovery.md lists tests to add for canonical amount selection.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff required for dispatcher mapping."
      ],
      "steps": [
        "Locate current dispatch mapping logic in the codebase.",
        "Identify how outbound amount fields are chosen today.",
        "Draft docs/dispatch_map_discovery.md with: current logic, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align mapping with contract rules.",
        "Keep the report scoped to dispatcher mapping only."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -f docs/dispatch_map_discovery.md",
        "rg -n \"dispatch\" docs/dispatch_map_discovery.md"
      ],
      "evidence": [
        "docs/dispatch_map_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S2-000",
      "priority": 100,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.1 Quantization rounding",
      "category": "execution",
      "description": "Implement deterministic quantization for qty and limit price with safe rounding.",
      "contract_refs": [
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "Anchor-021",
        "VR-020"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.1 — Integer tick/step quantization (safer direction)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_core/tests/test_quantize.rs"
        ],
        "avoid": [
          "crates/soldier_core/execution/label.rs",
          "crates/soldier_core/idempotency/**"
        ]
      },
      "acceptance": [
        "GIVEN raw_qty and amount_step WHEN quantizing THEN qty_steps = floor(raw_qty / amount_step) and qty_q = qty_steps * amount_step.",
        "GIVEN a BUY raw_limit_price and tick_size WHEN quantizing THEN price_ticks = floor(raw_limit_price / tick_size) and limit_price_q = price_ticks * tick_size; GIVEN SELL THEN price_ticks = ceil(raw_limit_price / tick_size).",
        "GIVEN qty_q < min_amount WHEN quantizing THEN the intent is rejected with TooSmallAfterQuantization."
      ],
      "steps": [
        "Implement quantize helpers to read tick_size, amount_step, and min_amount from instrument metadata.",
        "Compute qty_steps and price_ticks as integers using amount_step and tick_size with directional rounding by side.",
        "Derive qty_q and limit_price_q from qty_steps and price_ticks.",
        "Add a rejection path when qty_q < min_amount with an explicit error type.",
        "Add counter quantization_reject_too_small_total for rejection metrics.",
        "Add unit tests in crates/soldier_core/tests/test_quantize.rs for rounding and rejection behavior.",
        "Ensure integer tick/step values are returned for downstream idempotency hashing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_quantize"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_quantize output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S2-001",
      "priority": 90,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.2 Intent hash from quantized fields",
      "category": "durability",
      "description": "Compute intent_hash from quantized fields only and exclude timestamps.",
      "contract_refs": [
        "CONTRACT.md 1.1 Labeling & Idempotency Contract",
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "Anchor-020",
        "VR-020"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.2 — Intent hash from quantized fields only"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/idempotency/**",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_idempotency.rs"
        ],
        "avoid": [
          "crates/soldier_core/execution/label.rs",
          "crates/soldier_core/execution/quantize.rs"
        ]
      },
      "acceptance": [
        "GIVEN two codepaths that yield identical quantized fields WHEN hashing THEN the intent_hash values are identical.",
        "GIVEN an intent with time-of-day timestamps WHEN hashing THEN timestamps are excluded from the hash input.",
        "GIVEN quantized qty_steps and price_ticks WHEN hashing THEN those integer values (plus stable strings) are used, not raw f64."
      ],
      "steps": [
        "Implement or update the intent_hash function in crates/soldier_core/idempotency/hash.rs to accept quantized integer inputs.",
        "Remove any inclusion of wall-clock timestamps from the hash input.",
        "Use qty_steps and price_ticks (integers) alongside instrument, side, group_id, and leg_idx in the hash material.",
        "Add unit tests in crates/soldier_core/tests/test_idempotency.rs for deterministic hashing.",
        "Ensure callers pass quantized integer fields into the hashing function."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_idempotency"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_idempotency output"
      ],
      "dependencies": [
        "S2-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S2-002",
      "priority": 80,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.3 Compact label schema",
      "category": "durability",
      "description": "Implement compact label encode/decode with 64-character limit enforcement.",
      "contract_refs": [
        "CONTRACT.md Compact Label Schema (must implement):",
        "Anchor-020",
        "VR-021"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.3 — Compact label schema encode/decode (≤64 chars)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_core/tests/test_label.rs"
        ],
        "avoid": [
          "crates/soldier_core/recovery/**"
        ]
      },
      "acceptance": [
        "GIVEN strat_id, group_id, leg_idx, and intent_hash WHEN encoding THEN the label matches s4:{sid8}:{gid12}:{li}:{ih16} and is ≤ 64 chars.",
        "GIVEN a compact label WHEN decoding THEN sid8, gid12, leg_idx, and ih16 are parsed correctly.",
        "GIVEN an overlength label WHEN encoding THEN only hashed fields are truncated and structural fields remain intact."
      ],
      "steps": [
        "Implement label encoding in crates/soldier_core/execution/label.rs to produce sid8, gid12, and ih16.",
        "Enforce the ≤64 character limit and truncate only hashed components when required.",
        "Implement label decoding to parse sid8, gid12, leg_idx, and ih16.",
        "Add counter label_truncated_total for truncation events.",
        "Add unit tests in crates/soldier_core/tests/test_label.rs for length limits and parsing.",
        "Ensure encode/decode round-trips for valid inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_label output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true
    },
    {
      "id": "S2-003",
      "priority": 70,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 — Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.4 Label match disambiguation",
      "category": "risk",
      "description": "Disambiguate label matches deterministically and degrade on ambiguity.",
      "contract_refs": [
        "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
        "CONTRACT.md RiskState (health/cause layer): `Healthy | Degraded | Maintenance | Kill`",
        "Anchor-022",
        "VR-022"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 2 — Quantization \\+ Labeling \\+ Idempotency / S2.4 — Label match disambiguation; ambiguity→Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/recovery/*"
        ],
        "avoid": [
          "crates/soldier_core/execution/**"
        ]
      },
      "acceptance": [
        "GIVEN multiple intents sharing gid12 and leg_idx WHEN matching THEN tie-breakers are applied in order: ih16, instrument, side, qty_q.",
        "GIVEN ambiguity remains after tie-breakers WHEN matching THEN RiskState::Degraded is returned and no intent is matched (fail-closed).",
        "GIVEN a single clear candidate WHEN matching THEN the matched intent is returned deterministically."
      ],
      "steps": [
        "Parse labels into sid8, gid12, leg_idx, and ih16 in crates/soldier_core/recovery/label_match.rs.",
        "Build the candidate set by gid12 and leg_idx.",
        "Apply the tie-breakers in the contract order: ih16, instrument, side, qty_q.",
        "On unresolved ambiguity, return a Degraded outcome and increment label_match_ambiguity_total.",
        "Add unit tests in crates/soldier_core/tests/test_label_match.rs for disambiguation and ambiguity cases.",
        "Ensure the matching result is deterministic for identical inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label_match"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_label_match output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [
        "S2-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S3-000",
      "priority": 100,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed)",
      "story_ref": "S3.1 Preflight guard",
      "category": "execution",
      "description": "Implement order-type preflight rules for market/stop/linked orders across instruments.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "CONTRACT.md linked_order_type: Deribit linked/OCO semantics (venue-specific; gated off for this bot).",
        "Anchor-030",
        "VR-030"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed) / S3.1 — Preflight guard (market/stop/linked rules)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind=option WHEN order_type is market or stop or trigger fields are present THEN preflight rejects the intent deterministically.",
        "GIVEN instrument_kind in {linear_future,inverse_future,perpetual} WHEN order_type is market OR stop without trigger THEN preflight rejects the intent deterministically.",
        "GIVEN linked_order_type is set and linked orders are not explicitly enabled WHEN preflight runs THEN it rejects the intent and the preflight tests pass.",
        "GIVEN intent construction via build_order_intent WHEN preflight runs THEN it is invoked through a single shared preflight entrypoint (no bypass)."
      ],
      "steps": [
        "Create execution/preflight.rs and execution/order_type_guard.rs and wire them into crates/soldier_core/src/execution/mod.rs.",
        "Implement preflight checks for options and futures/perps per contract, returning explicit rejection reasons.",
        "Reject any linked_order_type unless feature-flagged and capability-enabled (default false).",
        "Add preflight_reject_total{reason} counter for rejects.",
        "Add unit tests in crates/soldier_core/tests/test_preflight.rs for market, stop, linked, and trigger requirements.",
        "Ensure preflight is invoked before any API dispatch path in the execution module.",
        "Expose a single preflight entrypoint (e.g., preflight_intent) and wire build_order_intent to call it."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_preflight"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_preflight output",
        "Unit test asserts reject reasons for market/stop/linked orders"
      ],
      "dependencies": [
        "S2-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S3-001",
      "priority": 90,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed)",
      "story_ref": "S3.2 Post-only crossing guard",
      "category": "execution",
      "description": "Reject post-only orders that would cross the book deterministically.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "Anchor-030",
        "VR-030"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed) / S3.2 — Post‑only crossing guard"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN post_only=true and the limit price would cross the touch WHEN preflight runs THEN it rejects the intent deterministically.",
        "GIVEN post_only=true and the limit price does not cross the touch WHEN preflight runs THEN it allows the intent to pass.",
        "GIVEN post_only crossing scenarios WHEN running tests THEN test_post_only_crossing_rejected passes."
      ],
      "steps": [
        "Create execution/post_only_guard.rs and wire it into crates/soldier_core/src/execution/mod.rs.",
        "Implement crossing detection using best bid/ask touch prices and reject when post_only would cross.",
        "Integrate the post-only guard into the preflight sequence.",
        "Add counter post_only_cross_reject_total for reject metrics.",
        "Add unit tests in crates/soldier_core/tests/test_post_only_guard.rs for crossing and non-crossing cases."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_post_only_guard"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_post_only_guard output"
      ],
      "dependencies": [
        "S3-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S3-002",
      "priority": 80,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed)",
      "story_ref": "S3.3 Capabilities matrix + feature flags",
      "category": "execution",
      "description": "Implement venue capabilities to gate linked/OCO orders behind explicit flags.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "CONTRACT.md linked_order_type: Deribit linked/OCO semantics (venue-specific; gated off for this bot).",
        "Anchor-031",
        "VR-030"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 3 — Order‑Type Preflight \\+ Venue Capabilities (artifact‑backed) / S3.3 — Capabilities matrix \\+ feature flags"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests"
        ],
        "avoid": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN default configuration WHEN computing capabilities THEN linked/OCO support is false for all instruments.",
        "GIVEN a venue capability and feature flag are both enabled WHEN computing capabilities THEN linked/OCO support is true.",
        "GIVEN the default configuration WHEN running tests THEN test_oco_not_supported passes."
      ],
      "steps": [
        "Create venue/capabilities.rs with a capabilities struct and evaluation helpers.",
        "Expose a feature flag (ENABLE_LINKED_ORDERS_FOR_BOT) to gate linked/OCO support.",
        "Default linked_orders_supported to false unless both capability and feature flag are true.",
        "Add unit tests in crates/soldier_core/tests/test_capabilities.rs for default and enabled behavior.",
        "Wire capabilities into venue module exports for consumption by preflight."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_capabilities"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_capabilities output"
      ],
      "dependencies": [
        "S3-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S4-000",
      "priority": 100,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.1 WAL append + replay no-resend",
      "category": "durability",
      "description": "Persist intents to a durable WAL and replay without resending after crash.",
      "contract_refs": [
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "CONTRACT.md 2.4 RecordedBeforeDispatch",
        "Anchor-041",
        "Anchor-042",
        "VR-040",
        "VR-041"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.1 — WAL append \\+ replay no-resend"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra"
        ],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN an intent is appended to the durable ledger before dispatch WHEN the system restarts THEN the intent is not resent.",
        "GIVEN the system restarts WHEN reconstructing state from the durable ledger THEN in-flight intents are rebuilt without duplicate dispatch.",
        "GIVEN a recorded intent WHEN persisted THEN the record includes intent_hash, group_id, leg_idx, instrument, side, qty_steps or qty_q, limit_price_q or price_ticks, tls_state, created_ts, sent_ts, ack_ts, last_fill_ts, and exchange_order_id when available.",
        "GIVEN ledger append fails WHEN dispatch is attempted THEN dispatch is blocked until a recorded (not necessarily durable) record exists."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/ledger.rs with append + replay primitives.",
        "Wire the store module into crates/soldier_infra/src/lib.rs.",
        "Record intents before dispatch (RecordedBeforeDispatch) and mark replay outcomes.",
        "Define the minimum persisted intent schema in ledger storage comments and enforce it in the record struct.",
        "Add unit tests in crates/soldier_infra/tests/test_ledger_replay.rs for no-resend after crash.",
        "Document WAL initialization and replay expectations in module-level comments."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_ledger_replay"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_ledger_replay output"
      ],
      "dependencies": [
        "S3-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S4-001",
      "priority": 90,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.2 TLSM out-of-order events",
      "category": "execution",
      "description": "Handle fill-before-ack and out-of-order TLSM events without panic.",
      "contract_refs": [
        "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "Anchor-040"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.2 — TLSM out‑of‑order events (fill-before-ack)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs",
          "crates/soldier_core/tests/test_quantize.rs",
          "crates/soldier_core/tests/test_idempotency.rs",
          "crates/soldier_core/tests/test_label.rs",
          "crates/soldier_core/tests/test_label_match.rs"
        ]
      },
      "acceptance": [
        "GIVEN a fill arrives before an ack WHEN processing TLSM events THEN no panic occurs and the final state is Filled.",
        "GIVEN out-of-order TLSM events WHEN applied THEN transitions converge to the correct terminal state deterministically.",
        "GIVEN TLSM transitions are applied WHEN events process THEN each transition is appended to the durable ledger immediately."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/state.rs and tlsm.rs to model TLSM transitions.",
        "Wire TLSM modules into crates/soldier_core/src/execution/mod.rs.",
        "Implement out-of-order handling (fill-before-ack) without panics.",
        "Append each transition to WAL via the infra ledger adapter.",
        "Add unit tests in crates/soldier_core/tests/test_tlsm.rs for fill-before-ack behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_tlsm"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_tlsm output"
      ],
      "dependencies": [
        "S4-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S4-002",
      "priority": 80,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.3 Trade-ID registry dedupe",
      "category": "durability",
      "description": "Persist processed trade IDs to prevent duplicate processing.",
      "contract_refs": [
        "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
        "Anchor-043",
        "VR-042"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.3 — Trade‑ID registry dedupe"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra"
        ],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN a trade_id already recorded WHEN handling a trade event THEN it is a NOOP and no duplicate updates occur.",
        "GIVEN a new trade_id WHEN processing a trade THEN trade_id is appended to the durable ledger before applying updates.",
        "GIVEN a restart WHEN the same trade_id is seen again THEN it is ignored due to the registry.",
        "GIVEN concurrent events for the same trade_id WHEN inserting THEN the registry insert is atomic and only one apply occurs."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/trade_id_registry.rs with persistent registry logic.",
        "Wire registry into crates/soldier_infra/src/lib.rs.",
        "Append trade_id before applying TLSM or position updates.",
        "Implement insert-if-absent atomically (single transaction or unique constraint) to avoid double-apply on concurrency.",
        "Add counter trade_id_duplicates_total when a duplicate trade_id is ignored.",
        "Add unit tests in crates/soldier_infra/tests/test_trade_id_registry.rs for dedupe behavior, including a concurrent insert case."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_trade_id_registry"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_trade_id_registry output"
      ],
      "dependencies": [
        "S4-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    },
    {
      "id": "S4-003",
      "priority": 70,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry",
      "story_ref": "S4.4 Dispatch requires durable WAL barrier",
      "category": "durability",
      "description": "Block dispatch until WAL durability marker when configured.",
      "contract_refs": [
        "CONTRACT.md RecordedBeforeDispatch",
        "Anchor-042",
        "VR-040"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md §Slice 4 — Durable WAL \\+ TLSM \\+ Trade‑ID Registry / S4.4 — Dispatch requires durable WAL barrier (when configured)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra",
          "crates/soldier_core/src/execution",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests"
        ],
        "avoid": [
          "crates/soldier_infra/src/deribit/**",
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ]
      },
      "acceptance": [
        "GIVEN the durability barrier flag is enabled WHEN dispatching THEN the path blocks until a durable ledger marker is recorded.",
        "GIVEN the durability barrier flag is disabled WHEN dispatching THEN the path proceeds without the durability barrier.",
        "GIVEN the durability barrier is enabled WHEN running tests THEN the dispatch durability test passes."
      ],
      "steps": [
        "Extend the ledger to expose a durable-append barrier and config flag.",
        "Wire the barrier into the core dispatch path (execution module) before any network send.",
        "Add unit tests in crates/soldier_infra/tests/test_dispatch_durability.rs for the barrier behavior.",
        "Document configuration flag require_wal_fsync_before_dispatch in infra config.",
        "Add a helper to surface barrier wait time for observability."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_dispatch_durability"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_dispatch_durability output"
      ],
      "dependencies": [
        "S4-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false
    }
  ]
}
