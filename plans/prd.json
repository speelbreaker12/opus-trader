{
  "project": "StoicTrader",
  "source": {
    "implementation_plan_path": "IMPLEMENTATION_PLAN.md",
    "contract_path": "specs/CONTRACT.md"
  },
  "rules": {
    "one_commit_per_story": true,
    "passes_only_flips_after_verify_green": true,
    "wip_limit": 2,
    "verify_entrypoint": "./plans/verify.sh"
  },
  "items": [
    {
      "id": "S0-000",
      "priority": 200,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-A Launch Policy Baseline",
      "category": "policy",
      "description": "Create launch policy doc with explicit constraints (instruments, position limits, order rate, environments).",
      "contract_refs": [
        "P0-A Launch Policy Baseline"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/launch_policy.md",
          "evidence/phase0/policy/launch_policy_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes allowed instruments/venues.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes max position/daily loss.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes max order rate/pacing.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes environments (DEV/STAGING/PAPER/LIVE).",
        "GIVEN evidence/phase0/policy/launch_policy_snapshot.md exists WHEN reviewed THEN is literal copy of docs."
      ],
      "steps": [
        "Create docs/launch_policy.md with allowed instruments and venues.",
        "Add allowed order types section.",
        "Add max position / max daily loss (capital stop).",
        "Add max order rate / pacing rule.",
        "Add environments section (DEV/STAGING/PAPER/LIVE with purpose).",
        "Copy full contents to evidence/phase0/policy/launch_policy_snapshot.md."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/launch_policy.md",
        "test -s evidence/phase0/policy/launch_policy_snapshot.md"
      ],
      "evidence": [
        "docs/launch_policy.md",
        "evidence/phase0/policy/launch_policy_snapshot.md",
        "evidence/phase0/policy/policy_config_snapshot.json"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-905"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_trading_policy.rs"
      ]
    },
    {
      "id": "S0-001",
      "priority": 199,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-B Environment Isolation",
      "category": "policy",
      "description": "Document environment isolation (separate keys/configs per env, no cross-env leakage).",
      "contract_refs": [
        "P0-B Environment Isolation"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/env_matrix.md",
          "evidence/phase0/env/env_matrix_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN lists each environment (DEV/STAGING/PAPER/LIVE).",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows which exchange account per env.",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows key permissions per env.",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows where secrets are stored.",
        "GIVEN evidence/phase0/env/env_matrix_snapshot.md exists WHEN reviewed THEN is literal copy of docs."
      ],
      "steps": [
        "Create docs/env_matrix.md with environment table.",
        "Add exchange account + API key per environment.",
        "Add permissions/scope per key (read-only vs trade vs withdraw).",
        "Add where secrets are stored (vault, env vars, etc.).",
        "Copy full contents to evidence/phase0/env/env_matrix_snapshot.md."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/env_matrix.md",
        "test -s evidence/phase0/env/env_matrix_snapshot.md"
      ],
      "evidence": [
        "docs/env_matrix.md",
        "evidence/phase0/env/env_matrix_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-277",
        "AT-920"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S0-002",
      "priority": 198,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-C Keys & Secrets Baseline",
      "category": "policy",
      "description": "Document key creation rules, rotation plan, and prove least-privilege with JSON scope probe.",
      "contract_refs": [
        "P0-C Keys & Secrets Baseline"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/keys_and_secrets.md",
          "evidence/phase0/keys/key_scope_probe.json"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes key creation rules (least privilege).",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes rotation plan.",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes where secrets live.",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes LIVE key protection.",
        "GIVEN evidence/phase0/keys/key_scope_probe.json WHEN parsed THEN is valid JSON with required fields."
      ],
      "steps": [
        "Create docs/keys_and_secrets.md with key creation rules.",
        "Add rotation plan (who/when/how).",
        "Add where secrets live (what must never appear in repo).",
        "Add how LIVE keys are protected from local/dev usage.",
        "Execute key scope probe and record in JSON format.",
        "Verify JSON has required fields: env, exchange, key_id, scopes, withdraw_enabled, timestamp_utc, operator."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/keys_and_secrets.md",
        "python -c \"import json; json.load(open('evidence/phase0/keys/key_scope_probe.json'))\""
      ],
      "evidence": [
        "docs/keys_and_secrets.md",
        "evidence/phase0/keys/key_scope_probe.json"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-277",
        "AT-920"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "human_blocker": {
        "why": "Key scope probes require access to exchange APIs",
        "question": "Has key scope probe been executed and recorded as JSON?",
        "options": [
          "Yes - probe JSON recorded",
          "No - awaiting access"
        ],
        "recommended": "Execute probe and record in key_scope_probe.json",
        "unblock_steps": [
          "Get API access",
          "Run scope probe",
          "Record JSON with required fields"
        ]
      }
    },
    {
      "id": "S0-003",
      "priority": 197,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-D Break-Glass Runbook + Drill",
      "category": "policy",
      "description": "Create break-glass runbook and execute a recorded drill proving halt capability.",
      "contract_refs": [
        "P0-D Break-Glass Runbook"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/break_glass_runbook.md",
          "evidence/phase0/break_glass/runbook_snapshot.md",
          "evidence/phase0/break_glass/drill.md",
          "evidence/phase0/break_glass/log_excerpt.txt"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has STOP TRADING steps.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has verify no further OPEN risk.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has verify risk reduction possible.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has escalation + notify.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has trigger scenario.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has time to halt.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has observed behavior.",
        "GIVEN evidence/phase0/break_glass/log_excerpt.txt WHEN reviewed THEN proves drill occurred."
      ],
      "steps": [
        "Create docs/break_glass_runbook.md with STOP TRADING steps (kill switch).",
        "Add how to verify no further OPEN risk.",
        "Add how to verify risk reduction still possible.",
        "Add escalation and who to notify.",
        "Copy runbook to evidence/phase0/break_glass/runbook_snapshot.md.",
        "Execute drill: simulate runaway order attempt.",
        "Record drill in evidence/phase0/break_glass/drill.md with trigger, time to halt, observed behavior.",
        "Capture log excerpt in evidence/phase0/break_glass/log_excerpt.txt."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/break_glass_runbook.md",
        "test -s evidence/phase0/break_glass/runbook_snapshot.md",
        "test -s evidence/phase0/break_glass/drill.md",
        "test -s evidence/phase0/break_glass/log_excerpt.txt"
      ],
      "evidence": [
        "docs/break_glass_runbook.md",
        "evidence/phase0/break_glass/runbook_snapshot.md",
        "evidence/phase0/break_glass/drill.md",
        "evidence/phase0/break_glass/log_excerpt.txt"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-341",
        "AT-040"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "break_glass_drill_completed",
            "type": "gauge",
            "unit": "count",
            "labels": [],
            "note": "Evidence artifact: log_excerpt.txt proves drill occurred (1 when drill completed)"
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "human_blocker": {
        "why": "Drill requires human execution and observation",
        "question": "Has the break-glass drill been executed with witnesses?",
        "options": [
          "Yes - drill completed and recorded",
          "No - drill not yet executed"
        ],
        "recommended": "Execute drill in DEV/STAGING before marking done",
        "unblock_steps": [
          "Create runbook doc",
          "Execute drill",
          "Record in drill.md",
          "Capture log excerpt"
        ]
      }
    },
    {
      "id": "S0-004",
      "priority": 196,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-E Health Endpoint",
      "category": "infra",
      "description": "Implement health endpoint returning ok/build_id/contract_version.",
      "contract_refs": [
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/health_endpoint.md",
          "crates/soldier_infra/src/lib.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN health endpoint called WHEN system healthy THEN returns ok=true, build_id, contract_version.",
        "GIVEN health command WHEN system healthy THEN exits 0.",
        "GIVEN docs/health_endpoint.md WHEN reviewed THEN documents command and format."
      ],
      "steps": [
        "Create docs/health_endpoint.md documenting the health command.",
        "Define expected output format (ok, build_id, contract_version).",
        "Implement health endpoint in soldier_infra.",
        "Wire health endpoint to CLI command.",
        "Implement test_health_endpoint_returns_required_fields.",
        "Implement test_health_command_exits_zero_when_healthy.",
        "Run tests and verify all pass."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_health"
      ],
      "evidence": [
        "cargo test output",
        "docs/health_endpoint.md",
        "evidence/phase0/health/health_endpoint_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-333"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "ok",
          "build_id",
          "contract_version"
        ],
        "status_contract_ats": [
          "AT-012"
        ]
      },
      "implementation_tests": []
    },
    {
      "id": "S1-001",
      "priority": 90,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Workspace scaffolding",
      "category": "infra",
      "description": "Initialize the Rust workspace with soldier_core and soldier_infra crates.",
      "contract_refs": [
        "CONTRACT.md 0.X Repository Layout & Canonical Module Mapping (Non-Negotiable)",
        "CONTRACT.md AT-905"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md C) Entry Criteria"
      ],
      "scope": {
        "touch": [
          "Cargo.toml",
          ".gitignore",
          "crates/soldier_core/Cargo.toml",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_infra/Cargo.toml",
          "crates/soldier_infra/src/lib.rs"
        ],
        "avoid": [
          "python/**",
          "specs/**",
          "artifacts/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN the repo layout WHEN inspected THEN crates/soldier_core and crates/soldier_infra directories exist.",
        "GIVEN Cargo.toml is inspected WHEN reading workspace members THEN it includes crates/soldier_core and crates/soldier_infra.",
        "GIVEN the workspace is configured WHEN running `cargo test --workspace` THEN it builds and exits 0."
      ],
      "steps": [
        "Create the crates/ directory if it does not exist.",
        "Initialize crates/soldier_core as a Rust library crate.",
        "Initialize crates/soldier_infra as a Rust library crate.",
        "Create or update the root Cargo.toml with a workspace members list including both crates.",
        "Run `cargo test --workspace` to confirm the workspace builds."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test --workspace output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-905"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-002",
      "priority": 80,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 InstrumentKind and RiskState",
      "category": "execution",
      "description": "Implement InstrumentKind derivation and RiskState enum per contract definitions.",
      "contract_refs": [
        "CONTRACT.md AT-333"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/src/risk/state.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_core/policy/**",
          "crates/soldier_infra/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN Deribit metadata for a USDC-margined perpetual WHEN deriving InstrumentKind THEN it returns linear_future.",
        "GIVEN metadata for option, perpetual, inverse_future, and linear_future instruments WHEN deriving InstrumentKind THEN it maps to the contract enum values.",
        "GIVEN instrument metadata from /public/get_instruments WHEN mapping to internal fields THEN tick_size, amount_step, min_amount, and contract_multiplier match the fetched values (test_instrument_metadata_uses_get_instruments).",
        "GIVEN the RiskState enum WHEN compiled THEN it includes Healthy, Degraded, Maintenance, and Kill variants."
      ],
      "steps": [
        "Define the RiskState enum in crates/soldier_core/risk/state.rs with the contract variants.",
        "Define the InstrumentKind enum in crates/soldier_core/venue/types.rs with contract values.",
        "Implement conversion logic from Deribit instrument metadata to InstrumentKind, including linear perpetual \u2192 linear_future and metadata field passthrough.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_kind_mapping.rs for mapping behavior and metadata passthrough (test_instrument_metadata_uses_get_instruments).",
        "Wire any required imports so the new enums are accessible where used."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_kind_mapping"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_kind_mapping output"
      ],
      "dependencies": [
        "S1-011"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
          "location": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
          "anchor": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata)."
        }
      ],
      "enforcing_contract_ats": [
        "AT-333"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
      ]
    },
    {
      "id": "S1-003",
      "priority": 70,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL",
      "category": "risk",
      "description": "Enforce InstrumentCache TTL and degrade RiskState on stale metadata.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
        "CONTRACT.md AT-104",
        "VR-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN cached instrument metadata older than the configured TTL WHEN accessed THEN RiskState::Degraded is returned for that lookup (test_stale_instrument_cache_sets_degraded).",
        "GIVEN cached metadata within TTL WHEN accessed THEN RiskState::Healthy is returned alongside the metadata.",
        "GIVEN instrument_cache_age_s > instrument_cache_ttl_s and an OPEN intent WHEN dispatch eligibility is checked THEN the OPEN is rejected and CLOSE/HEDGE/CANCEL remain allowed (test_instrument_cache_ttl_blocks_opens_allows_closes).",
        "GIVEN cache access WHEN processing THEN the cache age is compared against instrument_cache_ttl_s deterministically."
      ],
      "steps": [
        "Locate or create the InstrumentCache structure in crates/soldier_core/venue.",
        "Add timestamp tracking for cache insert/update and compute cache age on read; record instrument_cache_age_s and increment instrument_cache_hits_total.",
        "Compare cache age to TTL and return RiskState::Degraded when stale.",
        "Expose the cache freshness signal to dispatch eligibility checks so OPEN is rejected and CLOSE/HEDGE/CANCEL remain allowed when stale.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_cache_ttl.rs for fresh vs stale behavior.",
        "Add a unit test for stale metadata blocking OPEN while allowing CLOSE/HEDGE/CANCEL.",
        "Add or update a test to assert cache age comparisons against instrument_cache_ttl_s are deterministic."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl output",
        "Unit test asserts RiskState::Degraded on stale metadata",
        "Unit test asserts OPEN blocked and CLOSE/HEDGE/CANCEL allowed when metadata is stale",
        "Unit test asserts instrument_cache_ttl_s comparison is deterministic"
      ],
      "dependencies": [
        "S1-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "location": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "anchor": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement"
        }
      ],
      "enforcing_contract_ats": [
        "AT-104"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "instrument_cache_hits_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          },
          {
            "name": "instrument_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "RiskState::Healthy",
        "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
      ]
    },
    {
      "id": "S1-004",
      "priority": 60,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize canonical sizing",
      "category": "execution",
      "description": "Implement OrderSize canonical sizing with deterministic notional_usd using the discovery report.",
      "contract_refs": [
        "CONTRACT.md OrderSize struct (MUST implement):",
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract)"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.2 \u2014 OrderSize canonical sizing + notional invariant"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_infra/**",
          "crates/soldier_core/src/venue/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN instrument_kind option or linear_future WHEN building OrderSize THEN qty_coin is canonical and notional_usd = qty_coin * index_price.",
        "GIVEN instrument_kind option WHEN building OrderSize THEN qty_usd is unset.",
        "GIVEN instrument_kind perpetual or inverse_future WHEN building OrderSize THEN qty_usd is canonical and notional_usd = qty_usd.",
        "GIVEN any OrderSize WHEN built THEN notional_usd is always populated and internal fields are consistent with the contract invariants."
      ],
      "steps": [
        "Review docs/order_size_discovery.md for current gaps and proposed tests.",
        "Create crates/soldier_core/execution/order_size.rs if missing.",
        "Define the OrderSize struct with contracts, qty_coin, qty_usd, and notional_usd.",
        "Implement a constructor/builder that computes canonical units based on InstrumentKind.",
        "Ensure option sizing uses qty_coin and leaves qty_usd unset.",
        "Populate notional_usd deterministically using index_price for coin-sized instruments.",
        "Add a debug log OrderSizeComputed{instrument_kind, notional_usd}.",
        "Add unit tests in crates/soldier_core/tests/test_order_size.rs for canonical sizing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_order_size output"
      ],
      "dependencies": [
        "S1-002",
        "S1-008"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md OrderSize struct (MUST implement):",
          "location": "CONTRACT.md OrderSize struct (MUST implement):",
          "anchor": "CONTRACT.md OrderSize struct (MUST implement):"
        }
      ],
      "enforcing_contract_ats": [
        "AT-277"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "order_size_computed_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_order_size.rs"
      ]
    },
    {
      "id": "S1-005",
      "priority": 50,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher amount mapping",
      "category": "execution",
      "description": "Map OrderSize to Deribit request amounts using the discovery report.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.3 \u2014 Dispatcher amount mapping + mismatch reject\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/risk/**",
          "crates/soldier_infra/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN option or linear_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_coin.",
        "GIVEN perpetual or inverse_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_usd.",
        "GIVEN any OrderSize WHEN mapping THEN exactly one canonical amount field is set and the other is unset.",
        "GIVEN intent classification CLOSE/HEDGE WHEN mapping THEN reduce_only=true; GIVEN OPEN THEN reduce_only=false or omitted."
      ],
      "steps": [
        "Review docs/dispatch_map_discovery.md for current gaps and proposed tests.",
        "Create or update crates/soldier_core/execution/dispatch_map.rs with OrderSize mapping logic.",
        "Implement the rule: exactly one canonical amount field is sent per instrument_kind.",
        "Ensure outbound request uses qty_coin for option/linear_future and qty_usd for perpetual/inverse_future.",
        "Map reduce_only from intent classification only (CLOSE/HEDGE=true, OPEN=false or omitted).",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for amount field selection.",
        "Add a negative test asserting no second amount field is set."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_dispatch_map output",
        "Unit test asserts reduce_only mapping by intent classification"
      ],
      "dependencies": [
        "S1-004",
        "S1-009"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
          "location": "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
          "anchor": "CONTRACT.md Dispatcher Rules (Deribit request mapping):"
        }
      ],
      "enforcing_contract_ats": [
        "AT-277"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_dispatch_map.rs"
      ]
    },
    {
      "id": "S1-006",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL observability",
      "category": "risk",
      "description": "Add required TTL observability hooks for instrument cache freshness.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
        "VR-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN a TTL breach WHEN processing THEN a structured log InstrumentCacheTtlBreach{instrument_id, age_s, ttl_s} is emitted.",
        "GIVEN any cache access WHEN processing THEN instrument_cache_hits_total increments and instrument_cache_age_s is updated.",
        "GIVEN a stale access WHEN processing THEN instrument_cache_stale_total increments.",
        "GIVEN a metadata refresh failure WHEN processing THEN instrument_cache_refresh_errors_total increments."
      ],
      "steps": [
        "Emit a structured log InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s on staleness.",
        "Increment instrument_cache_hits_total on every cache access.",
        "Update instrument_cache_age_s gauge with computed cache age.",
        "Increment instrument_cache_stale_total on staleness.",
        "Increment instrument_cache_refresh_errors_total when a metadata refresh fails.",
        "Add test assertions in crates/soldier_core/tests/test_instrument_cache_ttl.rs for the log event.",
        "Add test assertions for metric increments and gauge updates using an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_cache_ttl output",
        "Log capture shows InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s",
        "Unit test asserts instrument_cache_hits_total and instrument_cache_stale_total increments",
        "Unit test asserts instrument_cache_refresh_errors_total increment",
        "Unit test asserts instrument_cache_age_s gauge update"
      ],
      "dependencies": [
        "S1-003"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "location": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "anchor": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement"
        }
      ],
      "enforcing_contract_ats": [
        "AT-104"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "instrument_cache_hits_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          },
          {
            "name": "instrument_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "instrument_cache_stale_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
      ]
    },
    {
      "id": "S1-007",
      "priority": 55,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mismatch rejection",
      "category": "execution",
      "description": "Reject contract/amount mismatches and emit mismatch metrics.",
      "contract_refs": [
        "CONTRACT.md AT-920"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.3 \u2014 Dispatcher amount mapping + mismatch reject\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/risk/**",
          "crates/soldier_infra/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN AT-920 requires rejecting intent on contracts/amount mismatch and setting RiskState::Degraded WHEN contracts vs canonical amount differ by more than contracts_amount_match_tolerance=0.001 THEN the intent is rejected with RejectReason::UnitMismatch AND RiskState::Degraded is returned (enforcing fail-closed per contract).",
        "GIVEN AT-920 requires observability of mismatch rejections WHEN a mismatch rejection occurs THEN order_intent_reject_unit_mismatch_total counter increments by 1.",
        "GIVEN the contract requires deterministic error propagation (AT-920) WHEN a mismatch rejection occurs THEN the error is surfaced to callers with RejectReason::UnitMismatch and includes the computed mismatch delta."
      ],
      "steps": [
        "Validate contracts vs canonical amount using contracts_amount_match_tolerance=0.001 and return an error with RiskState::Degraded on mismatch.",
        "Define a deterministic error reason for unit mismatches to surface to callers.",
        "Increment order_intent_reject_unit_mismatch_total for mismatch rejections.",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for mismatch rejection behavior.",
        "Add or update unit tests in crates/soldier_core/tests/test_order_size.rs for mismatch cases.",
        "Assert the metric increment via an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_dispatch_map output",
        "cargo test -p soldier_core --test test_order_size output",
        "Unit test asserts order_intent_reject_unit_mismatch_total increment",
        "Unit test asserts contracts_amount_match_tolerance=0.001 applied"
      ],
      "dependencies": [
        "S1-005"
      ],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
          "location": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
          "anchor": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`"
        }
      ],
      "enforcing_contract_ats": [
        "AT-920"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "UnitMismatch"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "order_intent_reject_unit_mismatch_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "crates/soldier_core/tests/test_dispatch_map.rs",
        "crates/soldier_core/tests/test_order_size.rs"
      ]
    },
    {
      "id": "S1-008",
      "priority": 95,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize discovery",
      "category": "qa",
      "description": "Discover current OrderSize logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract)",
        "CONTRACT.md OrderSize struct (MUST implement):",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.2 \u2014 OrderSize canonical sizing + notional invariant"
      ],
      "scope": {
        "touch": [
          "docs/order_size_discovery.md"
        ],
        "avoid": [],
        "create": []
      },
      "acceptance": [
        "GIVEN the current OrderSize implementation WHEN inspected THEN docs/order_size_discovery.md lists current fields, call sites, and gaps vs the contract OrderSize struct.",
        "GIVEN contract unit invariants WHEN inspected THEN docs/order_size_discovery.md lists required tests to add for canonical sizing.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff needed for OrderSize canonical sizing."
      ],
      "steps": [
        "Locate current OrderSize logic and any related helpers in the codebase.",
        "Identify call sites that construct OrderSize or size fields.",
        "Draft docs/order_size_discovery.md with: current fields, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align OrderSize with contract invariants.",
        "Keep the report scoped to OrderSize and sizing invariants only."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -f docs/order_size_discovery.md",
        "rg -n \"OrderSize\" docs/order_size_discovery.md"
      ],
      "evidence": [
        "docs/order_size_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-277",
        "AT-920"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-009",
      "priority": 85,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mapping discovery",
      "category": "qa",
      "description": "Discover current dispatcher mapping logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.3 \u2014 Dispatcher amount mapping + mismatch reject\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "docs/dispatch_map_discovery.md"
        ],
        "avoid": [
          "crates/**",
          "plans/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN the current dispatch mapping WHEN inspected THEN docs/dispatch_map_discovery.md lists current amount field logic and contract gaps.",
        "GIVEN contract mapping rules WHEN inspected THEN docs/dispatch_map_discovery.md lists tests to add for canonical amount selection.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff required for dispatcher mapping."
      ],
      "steps": [
        "Locate current dispatch mapping logic in the codebase.",
        "Identify how outbound amount fields are chosen today.",
        "Draft docs/dispatch_map_discovery.md with: current logic, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align mapping with contract rules.",
        "Keep the report scoped to dispatcher mapping only."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -f docs/dispatch_map_discovery.md",
        "rg -n \"dispatch\" docs/dispatch_map_discovery.md"
      ],
      "evidence": [
        "docs/dispatch_map_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-277",
        "AT-920"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-010",
      "priority": 88,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Appendix A config defaults",
      "category": "infra",
      "description": "Apply Appendix A safety-critical defaults in infra config and verify missing-value behavior.",
      "contract_refs": [
        "CONTRACT.md Appendix A: Configuration Defaults (Safety-Critical Thresholds)",
        "CONTRACT.md AT-341",
        "CONTRACT.md AT-040",
        "Anchor-001",
        "Anchor-002",
        "Anchor-003",
        "Anchor-008",
        "Anchor-009",
        "Anchor-010",
        "Anchor-012",
        "Anchor-015",
        "Anchor-016",
        "Anchor-020",
        "Anchor-022",
        "VR-001",
        "VR-002",
        "VR-003",
        "VR-004a",
        "VR-004b",
        "VR-005",
        "VR-006",
        "VR-008",
        "VR-009",
        "VR-015",
        "VR-016",
        "VR-023"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.0 \u2014 Repo verification harness (plans/verify.sh) + safety-critical config defaults (Appendix A)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests"
        ],
        "create": [
          "crates/soldier_infra/config"
        ],
        "avoid": [
          "plans/**",
          "crates/soldier_core/**"
        ]
      },
      "acceptance": [
        "GIVEN config omits instrument_cache_ttl_s WHEN defaults are applied THEN the TTL uses the Appendix A default of 3600s.",
        "GIVEN config omits the global evidence cooldown setting WHEN defaults are applied THEN the cooldown uses the Appendix A default of 120s.",
        "GIVEN config omits mm_util_kill WHEN defaults are applied THEN the kill threshold uses the Appendix A default of 0.95.",
        "GIVEN a safety-critical gate references a parameter without an Appendix A default WHEN the parameter is missing THEN the gate fails closed with a deterministic reason."
      ],
      "steps": [
        "Define a centralized defaults table covering Appendix A safety-critical parameters, including instrument_cache_ttl_s, evidenceguard_global_cooldown, and mm_util_kill.",
        "Create a config loader in crates/soldier_infra that applies Appendix A defaults when values are missing.",
        "Add a fail-closed path for safety-critical parameters that lack Appendix A defaults, surfacing a deterministic error.",
        "Create crates/soldier_infra/tests/test_config_defaults.rs with a test for missing instrument_cache_ttl_s and the global evidence cooldown applying defaults.",
        "Add a test case for missing mm_util_kill applying the Appendix A default.",
        "Add a test case for a missing non-Appendix A parameter to assert fail-closed behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_config_defaults"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_config_defaults output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-341",
        "AT-040"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "config_defaults_applied_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "config_key"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-011",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Deribit instrument structs",
      "category": "infra",
      "description": "Define Deribit public instrument structs for metadata mapping.",
      "contract_refs": [
        "CONTRACT.md AT-333"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/deribit/public/mod.rs",
          "crates/soldier_infra/src/deribit/mod.rs",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/Cargo.toml"
        ],
        "avoid": [
          "crates/soldier_core/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN AT-333 requires InstrumentKind derivation from venue metadata WHEN the Deribit public instrument struct is defined THEN it MUST include the 'kind' field (option|future|option_combo) required for mapping to the contract InstrumentKind enum.",
        "GIVEN the contract OrderSize struct requires tick_size, amount_step, min_amount, and contract_multiplier (AT-333) WHEN the Deribit public instrument struct is defined THEN all four fields are present and deserializable from /public/get_instruments responses.",
        "GIVEN soldier_core will consume Deribit metadata (AT-333) WHEN the Deribit public module is compiled THEN the instrument structs are pub-exported from soldier_infra and importable by dependent crates."
      ],
      "steps": [
        "Define the minimal Deribit public instrument structs needed for mapping in crates/soldier_infra/deribit/public, including tick_size, amount_step, min_amount, and contract_multiplier.",
        "Add required serde derives for deserialization from Deribit API responses.",
        "Wire imports in crates/soldier_infra/src/deribit/mod.rs and src/lib.rs to expose the public module.",
        "Add basic unit tests or compile checks to verify the struct fields are correctly defined.",
        "Run cargo test -p soldier_infra to confirm the module compiles and is accessible."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra"
      ],
      "evidence": [
        "cargo test -p soldier_infra output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-333"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-012",
      "priority": 84,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.4 Instrument lifecycle + expiry safety (Expiry Cliff Guard)",
      "category": "risk",
      "description": "Implement S1.4 (Instrument lifecycle + expiry safety (Expiry Cliff Guard)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "AT-949",
        "AT-950",
        "AT-960",
        "AT-961",
        "AT-962",
        "AT-965",
        "AT-966"
      ],
      "plan_refs": [
        "Slice 1 \u2014 Instrument Units + Dispatcher Invariants",
        "S1.4 \u2014 Instrument lifecycle + expiry safety (Expiry Cliff Guard)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/src/venue",
          "crates/soldier_core/tests"
        ],
        "create": [
          "crates/soldier_core/tests/test_expiry_guard.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "If `expiration_timestamp_ms` is present and now_ms is within `expiry_delist_buffer_s`, reject NEW OPEN with `Rejected(InstrumentExpiredOrDelisted)`; CLOSE/HEDGE/CANCEL remain allowed subject to TradingMode.",
        "Terminal lifecycle errors for expired/delisted instruments MUST be classified as `Terminal(InstrumentExpiredOrDelisted)`; MUST NOT panic; MUST NOT restart process; reconcile that instrument only and mark `instrument_state=ExpiredOrDelisted`.",
        "CANCEL on expired/delisted instrument returning terminal error MUST be treated as idempotently successful."
      ],
      "steps": [
        "Map S1.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S1.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S1.4: crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_delist_buffer_rejects_open, crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_outside_buffer_allows_open, crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_cancel_idempotent_success.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_expiry_guard output",
        "PRD entry S1-012 records contract AT and test mappings for this story."
      ],
      "dependencies": [
        "S1-003",
        "S1-011"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S1.4 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:230",
          "anchor": "AT-949"
        }
      ],
      "enforcing_contract_ats": [
        "AT-949",
        "AT-950",
        "AT-960",
        "AT-961",
        "AT-962",
        "AT-965",
        "AT-966"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "INSTRUMENT_EXPIRED_OR_DELISTED"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s1_012_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-949",
          "AT-950"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_delist_buffer_rejects_open",
        "crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_outside_buffer_allows_open",
        "crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_cancel_idempotent_success",
        "crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_non_terminal_cancel_does_not_mark_expired",
        "crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_reconcile_does_not_halt_other_instruments",
        "crates/soldier_core/tests/test_expiry_guard.rs::test_expiry_no_retry_loop_after_positions_clear"
      ]
    },
    {
      "id": "S1-013",
      "priority": 62,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units + Dispatcher Invariants",
      "story_ref": "S1.0b PR merge-readiness automation gate",
      "category": "infra",
      "description": "Add a workflow harness script that auto-detects current-branch PR and fail-closes on non-mergeable CI/review states, with deterministic fixture coverage.",
      "contract_refs": [
        "CONTRACT.md 0.Z.9 CSP-Only CI Gate",
        "AT-1056",
        "AT-1057"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.0 \u2014 Repo verification harness (plans/verify.sh) + safety-critical config defaults (Appendix A)"
      ],
      "scope": {
        "touch": [
          "plans/pr_gate.sh",
          "plans/tests/test_pr_gate.sh",
          "plans/preflight.sh",
          "plans/workflow_verify.sh",
          "plans/workflow_files_allowlist.txt",
          "plans/tests/test_workflow_allowlist_coverage.sh"
        ],
        "create": [],
        "avoid": [
          "crates/**",
          "specs/CONTRACT.md"
        ]
      },
      "acceptance": [
        "GIVEN a branch with an open PR WHEN running `./plans/pr_gate.sh` without `--pr` THEN it auto-detects the PR and returns pass/fail from GitHub state.",
        "GIVEN PR mergeability/check-run/review blockers WHEN running `./plans/pr_gate.sh` THEN it exits non-zero with deterministic reason tokens (`merge_conflict_or_blocked`, `checks_pending`, `checks_failing`, `changes_requested`).",
        "GIVEN bot/copilot comments newer than head commit WHEN running in default mode THEN gate warns but does not block; WHEN `--bot-comments-mode block` THEN gate blocks."
      ],
      "steps": [
        "Add `plans/pr_gate.sh` with fail-closed checks for mergeable state, check-runs, and reviewDecision using `gh`+`jq`.",
        "Implement PR auto-detection via `gh pr view --json number` when `--pr` is omitted.",
        "Implement optional story artifact report output under `artifacts/story/<ID>/pr_gate/<ts>_pr_gate.md`.",
        "Add deterministic fixture test `plans/tests/test_pr_gate.sh` with mocked `gh` responses to verify pass/fail/warn/block behavior.",
        "Wire fixture into `plans/preflight.sh` and workflow allowlist coverage checks so harness edits are self-proving under verify."
      ],
      "verify": [
        "./plans/verify.sh",
        "bash plans/tests/test_pr_gate.sh",
        "bash plans/tests/test_workflow_allowlist_coverage.sh"
      ],
      "evidence": [
        "plans/pr_gate.sh",
        "plans/tests/test_pr_gate.sh",
        "artifacts/verify/<run_id>/preflight.log"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-1056",
        "AT-1057"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "plans/tests/test_pr_gate.sh"
      ]
    },
    {
      "id": "S2-000",
      "priority": 100,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.1 Quantization rounding",
      "category": "execution",
      "description": "Implement deterministic quantization for qty and limit price with safe rounding.",
      "contract_refs": [
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "AT-021",
        "AT-020",
        "AT-926"
      ],
      "plan_refs": [
        "Slice 2 \u2014 Quantization + Labeling + Idempotency",
        "S2.1 \u2014 Integer tick/step quantization (safer direction)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/quantize.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_quantize.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/idempotency/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN raw_qty and amount_step WHEN quantizing THEN qty_steps = floor(raw_qty / amount_step) and qty_q = qty_steps * amount_step.",
        "GIVEN a BUY raw_limit_price and tick_size WHEN quantizing THEN price_ticks = floor(raw_limit_price / tick_size) and limit_price_q = price_ticks * tick_size; GIVEN SELL THEN price_ticks = ceil(raw_limit_price / tick_size).",
        "GIVEN qty_q < min_amount WHEN quantizing THEN the intent is rejected with TooSmallAfterQuantization."
      ],
      "steps": [
        "Implement quantize helpers to read tick_size, amount_step, and min_amount from instrument metadata.",
        "Compute qty_steps and price_ticks as integers using amount_step and tick_size with directional rounding by side.",
        "Derive qty_q and limit_price_q from qty_steps and price_ticks.",
        "Add a rejection path when qty_q < min_amount with an explicit error type.",
        "Add counter quantization_reject_too_small_total for rejection metrics.",
        "Add unit tests in crates/soldier_core/tests/test_quantize.rs for rounding and rejection behavior.",
        "Ensure integer tick/step values are returned for downstream idempotency hashing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_quantize"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_quantize output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
          "location": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
          "anchor": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-020",
        "AT-021",
        "AT-926"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::TooSmallAfterQuantization"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "quantization_reject_too_small_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_quantize.rs"
      ]
    },
    {
      "id": "S2-001",
      "priority": 90,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.2 Intent hash from quantized fields",
      "category": "durability",
      "description": "Compute intent_hash from quantized fields only and exclude timestamps.",
      "contract_refs": [
        "CONTRACT.md 1.1 Labeling & Idempotency Contract",
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "AT-020",
        "Anchor-017",
        "VR-017",
        "AT-201",
        "AT-343",
        "AT-928"
      ],
      "plan_refs": [
        "Slice 2 \u2014 Quantization + Labeling + Idempotency",
        "S2.2 \u2014 Intent hash from quantized fields only"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/idempotency/hash.rs",
          "crates/soldier_core/src/idempotency/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_idempotency.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/execution/quantize.rs"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN two codepaths that yield identical quantized fields WHEN hashing THEN the intent_hash values are identical.",
        "GIVEN an intent with time-of-day timestamps WHEN hashing THEN timestamps are excluded from the hash input.",
        "GIVEN quantized qty_steps and price_ticks WHEN hashing THEN those integer values (plus stable strings) are used, not raw f64."
      ],
      "steps": [
        "Implement or update the intent_hash function in crates/soldier_core/idempotency/hash.rs to accept quantized integer inputs.",
        "Remove any inclusion of wall-clock timestamps from the hash input.",
        "Use qty_steps and price_ticks (integers) alongside instrument, side, group_id, and leg_idx in the hash material.",
        "Add unit tests in crates/soldier_core/tests/test_idempotency.rs for deterministic hashing.",
        "Ensure callers pass quantized integer fields into the hashing function."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_idempotency"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_idempotency output"
      ],
      "dependencies": [
        "S2-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1 Labeling & Idempotency Contract",
          "location": "CONTRACT.md 1.1 Labeling & Idempotency Contract",
          "anchor": "CONTRACT.md 1.1 Labeling & Idempotency Contract"
        }
      ],
      "enforcing_contract_ats": [
        "AT-020",
        "AT-201",
        "AT-343",
        "AT-928"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_idempotency.rs"
      ]
    },
    {
      "id": "S2-002",
      "priority": 80,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.3 Compact label schema",
      "category": "durability",
      "description": "Implement compact label encode/decode with 64-character limit enforcement.",
      "contract_refs": [
        "CONTRACT.md \u00a71.1 Labeling & Idempotency Contract",
        "AT-216",
        "AT-217",
        "AT-041",
        "AT-921"
      ],
      "plan_refs": [
        "Slice 2 \u2014 Quantization + Labeling + Idempotency",
        "S2.3 \u2014 Compact label schema encode/decode (\u226464 chars)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_label.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/recovery/**"
        ],
        "create": []
      },
      "acceptance": [
        "GIVEN strat_id, group_id, leg_idx, and intent_hash WHEN encoding THEN the label matches s4:{sid8}:{gid12}:{li}:{ih16} and is \u2264 64 chars.",
        "GIVEN a compact label WHEN decoding THEN sid8, gid12, leg_idx, and ih16 are parsed correctly.",
        "GIVEN a computed s4 label would exceed 64 chars WHEN encoding THEN the intent is rejected with Rejected(LabelTooLong), RiskState::Degraded is set, and no dispatch occurs (no truncation)."
      ],
      "steps": [
        "Implement label encoding in crates/soldier_core/src/execution/label.rs to produce sid8, gid12, and ih16.",
        "Enforce the \u226464 character limit; if the computed label would exceed 64 chars, reject with LabelTooLong and set RiskState::Degraded (no truncation).",
        "Implement label decoding to parse sid8, gid12, leg_idx, and ih16.",
        "Add unit tests in crates/soldier_core/tests/test_label.rs for length limits and parsing.",
        "Ensure encode/decode round-trips for valid inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_label output",
        "Test assertions for LabelTooLong rejection and label parsing"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.1 Labeling & Idempotency Contract",
          "location": "CONTRACT.md \u00a71.1 Labeling & Idempotency Contract",
          "anchor": "AT-216"
        }
      ],
      "enforcing_contract_ats": [
        "AT-216",
        "AT-217",
        "AT-041",
        "AT-921"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::LabelTooLong"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-216",
          "AT-217"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_label.rs"
      ]
    },
    {
      "id": "S2-003",
      "priority": 70,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.4 Label match disambiguation",
      "category": "risk",
      "description": "Disambiguate label matches deterministically and degrade on ambiguity.",
      "contract_refs": [
        "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
        "AT-022",
        "Anchor-001",
        "Anchor-019",
        "VR-021",
        "VR-022",
        "AT-217"
      ],
      "plan_refs": [
        "Slice 2 \u2014 Quantization + Labeling + Idempotency",
        "S2.4 \u2014 Label match disambiguation; ambiguity\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/src/recovery",
          "crates/soldier_core/tests/test_label_match.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/**"
        ]
      },
      "acceptance": [
        "GIVEN multiple intents sharing gid12 and leg_idx WHEN matching THEN tie-breakers are applied in order: ih16, instrument, side, qty_q.",
        "GIVEN ambiguity remains after tie-breakers WHEN matching THEN RiskState::Degraded is returned and no intent is matched (fail-closed).",
        "GIVEN a single clear candidate WHEN matching THEN the matched intent is returned deterministically."
      ],
      "steps": [
        "Parse labels into sid8, gid12, leg_idx, and ih16 in crates/soldier_core/src/recovery/label_match.rs.",
        "Build the candidate set by gid12 and leg_idx.",
        "Apply the tie-breakers in the contract order: ih16, instrument, side, qty_q.",
        "On unresolved ambiguity, return a Degraded outcome and increment label_match_ambiguity_total.",
        "Add unit tests in crates/soldier_core/tests/test_label_match.rs for disambiguation and ambiguity cases.",
        "Ensure the matching result is deterministic for identical inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label_match"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_label_match output",
        "Unit test asserts metric increment via in-memory metrics registry/mock"
      ],
      "dependencies": [
        "S2-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
          "location": "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
          "anchor": "AT-022"
        }
      ],
      "enforcing_contract_ats": [
        "AT-022",
        "AT-217"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "DEGRADED_LABEL_AMBIGUITY"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "label_match_ambiguity_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-022"
        ]
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "crates/soldier_core/tests/test_label_match.rs"
      ]
    },
    {
      "id": "S2-004",
      "priority": 60,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization + Labeling + Idempotency",
      "story_ref": "S2.5 RejectReasonCode registry (intent-level rejections)",
      "category": "execution",
      "description": "Implement S2.5 (RejectReasonCode registry (intent\u2011level rejections)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "CONTRACT.md RejectReasonCode registry (intent\u2011level rejections)",
        "CONTRACT.md 2.2.6 RejectReasonCode Registry (Intent-Level Rejections)",
        "RejectReasonCode",
        "AT-201"
      ],
      "plan_refs": [
        "Slice 2 \u2014 Quantization + Labeling + Idempotency",
        "S2.5 \u2014 RejectReasonCode registry (intent\u2011level rejections)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [
          "crates/soldier_core/tests/test_reject_reason.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "Any intent rejected before dispatch MUST include reject_reason_code and it MUST be in the contract registry.",
        "Registry must be updated in the same patch when a new rejection token is added.",
        "GIVEN adverse inputs for S2.5 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S2.5 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S2.5 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S2.5: crates/soldier_core/tests/test_reject_reason.rs::test_reject_reason_present_on_pre_dispatch_reject, crates/soldier_core/tests/test_reject_reason.rs::test_reject_reason_in_registry, crates/soldier_core/tests/test_reject_reason.rs::test_registry_contains_contract_minimum_set.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_reject_reason output",
        "PRD entry S2-004 records contract AT and test mappings for this story."
      ],
      "dependencies": [
        "S2-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "Fail-closed contract behavior must be verified by targeted acceptance tests.",
          "location": "plans/prd.json S2-004",
          "anchor": "AT-201"
        }
      ],
      "enforcing_contract_ats": [
        "AT-201"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-201"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_reject_reason.rs::test_reject_reason_present_on_pre_dispatch_reject",
        "crates/soldier_core/tests/test_reject_reason.rs::test_reject_reason_in_registry",
        "crates/soldier_core/tests/test_reject_reason.rs::test_registry_contains_contract_minimum_set"
      ]
    },
    {
      "id": "S3-000",
      "priority": 100,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed)",
      "story_ref": "S3.1 Preflight guard",
      "category": "execution",
      "description": "Implement order-type preflight rules for market/stop/linked orders across instruments.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-013",
        "AT-023",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-004",
        "AT-016",
        "AT-017",
        "AT-018",
        "AT-019",
        "AT-913",
        "AT-914",
        "AT-915",
        "Anchor-013",
        "Anchor-014",
        "Anchor-023",
        "VR-025",
        "VR-026",
        "VR-027"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed) / S3.1 \u2014 Preflight guard (market/stop/linked rules)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/build_order_intent.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/pipeline.rs",
          "crates/soldier_core/src/execution/preflight.rs",
          "crates/soldier_core/tests/test_gate_ordering.rs",
          "crates/soldier_core/tests/test_intent_pipeline.rs",
          "crates/soldier_core/tests/test_preflight.rs",
          "crates/soldier_core/tests/test_rejection_side_effects.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind=option WHEN order_type is market or stop or trigger fields are present THEN preflight rejects the intent deterministically.",
        "GIVEN instrument_kind in {linear_future,inverse_future,perpetual} WHEN order_type is market OR stop without trigger THEN preflight rejects the intent deterministically.",
        "GIVEN linked_order_type is set and linked orders are not explicitly enabled WHEN preflight runs THEN it rejects the intent and the preflight tests pass.",
        "GIVEN intent construction via build_order_intent WHEN preflight runs THEN it is invoked through a single shared preflight entrypoint (no bypass)."
      ],
      "steps": [
        "Create execution/preflight.rs and wire it into crates/soldier_core/src/execution/mod.rs.",
        "Create execution/pipeline.rs and test_intent_pipeline.rs to prove preflight and capabilities are enforced through one runtime path.",
        "Implement preflight checks for options and futures/perps per contract, returning explicit rejection reasons.",
        "Reject any linked_order_type unless feature-flagged and capability-enabled (default false).",
        "Integrate post-only crossing rejections into the preflight sequence and surface deterministic reject reasons.",
        "Add preflight_reject_total{reason} counter for rejects.",
        "Add unit tests in crates/soldier_core/tests/test_preflight.rs for market, stop, linked, and trigger requirements.",
        "Ensure preflight is invoked before any API dispatch path in the execution module.",
        "Expose a single preflight entrypoint (e.g., preflight_intent) and wire build_order_intent to call it."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_preflight"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_preflight output",
        "Unit test asserts reject reasons for market/stop/linked orders"
      ],
      "dependencies": [
        "S2-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-013"
        }
      ],
      "enforcing_contract_ats": [
        "AT-013",
        "AT-023",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-004",
        "AT-016",
        "AT-017",
        "AT-018",
        "AT-019",
        "AT-913",
        "AT-914",
        "AT-915"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "preflight_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_preflight.rs"
      ]
    },
    {
      "id": "S3-001",
      "priority": 90,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed)",
      "story_ref": "S3.2 Post-only crossing guard",
      "category": "execution",
      "description": "Reject post-only orders that would cross the book deterministically.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-916"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed) / S3.2 \u2014 Post\u2011only crossing guard"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/post_only_guard.rs",
          "crates/soldier_core/tests/test_post_only_guard.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN post_only=true and the limit price would cross the touch WHEN preflight runs THEN it rejects the intent deterministically.",
        "GIVEN post_only=true and the limit price does not cross the touch WHEN preflight runs THEN it allows the intent to pass.",
        "GIVEN post_only crossing scenarios WHEN running tests THEN test_post_only_crossing_rejected passes."
      ],
      "steps": [
        "Create execution/post_only_guard.rs and wire it into crates/soldier_core/src/execution/mod.rs.",
        "Implement crossing detection using best bid/ask touch prices and reject when post_only would cross.",
        "Integrate the post-only guard into the preflight sequence.",
        "Add counter post_only_cross_reject_total for reject metrics.",
        "Add unit tests in crates/soldier_core/tests/test_post_only_guard.rs for crossing and non-crossing cases."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_post_only_guard"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_post_only_guard output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-916"
        }
      ],
      "enforcing_contract_ats": [
        "AT-916"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "post_only_cross_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_post_only_guard.rs"
      ]
    },
    {
      "id": "S3-002",
      "priority": 80,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed)",
      "story_ref": "S3.3 Capabilities matrix + feature flags",
      "category": "execution",
      "description": "Implement venue capabilities to gate linked/OCO orders behind explicit flags.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-028",
        "AT-004",
        "AT-915",
        "Anchor-023",
        "VR-026",
        "VR-027",
        "VR-028"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed) / S3.3 \u2014 Capabilities matrix \\+ feature flags"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/src/venue/capabilities.rs",
          "crates/soldier_core/tests/test_capabilities.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN default configuration WHEN computing capabilities THEN linked/OCO support is false for all instruments.",
        "GIVEN a venue capability and feature flag are both enabled WHEN computing capabilities THEN linked/OCO support is true.",
        "GIVEN the default configuration WHEN running tests THEN test_oco_not_supported passes."
      ],
      "steps": [
        "Create venue/capabilities.rs with a capabilities struct and evaluation helpers.",
        "Expose a feature flag (ENABLE_LINKED_ORDERS_FOR_BOT) to gate linked/OCO support.",
        "Default linked_orders_supported to false unless both capability and feature flag are true.",
        "Add unit tests in crates/soldier_core/tests/test_capabilities.rs for default and enabled behavior.",
        "Wire capabilities into venue module exports for consumption by preflight."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_capabilities"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_capabilities output"
      ],
      "dependencies": [
        "S3-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-028"
        }
      ],
      "enforcing_contract_ats": [
        "AT-028",
        "AT-004",
        "AT-915"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_capabilities.rs"
      ]
    },
    {
      "id": "S4-000",
      "priority": 100,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.1 WAL append + replay no-resend",
      "category": "durability",
      "description": "Persist intents to a durable WAL and replay without resending after crash.",
      "contract_refs": [
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "CONTRACT.md \u00a72.4.1 WAL Writer Isolation (Hot Loop Protection)",
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234",
        "Anchor-004",
        "Anchor-005",
        "Anchor-006",
        "VR-010",
        "VR-014"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.1 \u2014 WAL append \\+ replay no-resend"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests",
          "crates/soldier_infra/src/store"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN an intent is appended to the durable ledger before dispatch WHEN the system restarts THEN the intent is not resent.",
        "GIVEN the system restarts WHEN reconstructing state from the durable ledger THEN in-flight intents are rebuilt without duplicate dispatch.",
        "GIVEN a recorded intent WHEN persisted THEN the record includes intent_hash, group_id, leg_idx, instrument, side, qty_steps or qty_q, limit_price_q or price_ticks, tls_state, created_ts, sent_ts, ack_ts, last_fill_ts, and exchange_order_id when available.",
        "GIVEN ledger append fails WHEN dispatch is attempted THEN the OPEN intent is rejected and the error counter increments.",
        "GIVEN the ledger writer queue is full WHEN an append is attempted THEN the append returns immediately with an error (hot loop not blocked)."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/ledger.rs with append + replay primitives.",
        "Wire the store module into crates/soldier_infra/src/lib.rs.",
        "Record intents before dispatch (RecordedBeforeDispatch) and mark replay outcomes.",
        "Define the minimum persisted intent schema in ledger storage comments and enforce it in the record struct.",
        "Add unit tests in crates/soldier_infra/tests/test_ledger_replay.rs for no-resend after crash.",
        "Document WAL initialization and replay expectations in module-level comments."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_ledger_replay"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_ledger_replay output"
      ],
      "dependencies": [
        "S3-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
          "location": "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
          "anchor": "AT-935"
        }
      ],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "EXEC_WAL_WRITE_FAILED"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [
          {
            "name": "wal_write_errors",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_ledger_replay.rs"
      ]
    },
    {
      "id": "S4-001",
      "priority": 90,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.2 TLSM out-of-order events",
      "category": "execution",
      "description": "Handle fill-before-ack and out-of-order TLSM events without panic.",
      "contract_refs": [
        "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "AT-230",
        "AT-210",
        "Anchor-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.2 \u2014 TLSM out\u2011of\u2011order events (fill-before-ack)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/tlsm.rs",
          "crates/soldier_core/tests/test_tlsm.rs"
        ],
        "create": [
          "crates/soldier_core/src/execution/state.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs",
          "crates/soldier_core/tests/test_quantize.rs",
          "crates/soldier_core/tests/test_idempotency.rs",
          "crates/soldier_core/tests/test_label.rs",
          "crates/soldier_core/tests/test_label_match.rs"
        ]
      },
      "acceptance": [
        "GIVEN a fill arrives before an ack WHEN processing TLSM events THEN no panic occurs and the final state is Filled.",
        "GIVEN out-of-order TLSM events WHEN applied THEN transitions converge to the correct terminal state deterministically.",
        "GIVEN TLSM transitions are applied WHEN events process THEN each transition is appended to the durable ledger immediately."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/state.rs and tlsm.rs to model TLSM transitions.",
        "Wire TLSM modules into crates/soldier_core/src/execution/mod.rs.",
        "Implement out-of-order handling (fill-before-ack) without panics.",
        "Append each transition to WAL via the infra ledger adapter.",
        "Add unit tests in crates/soldier_core/tests/test_tlsm.rs for fill-before-ack behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_tlsm"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_tlsm output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
          "location": "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
          "anchor": "AT-230"
        }
      ],
      "enforcing_contract_ats": [
        "AT-230",
        "AT-210"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_tlsm.rs"
      ]
    },
    {
      "id": "S4-002",
      "priority": 80,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.3 Trade-ID registry dedupe",
      "category": "durability",
      "description": "Persist processed trade IDs to prevent duplicate processing.",
      "contract_refs": [
        "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
        "AT-269",
        "AT-270",
        "Anchor-007",
        "VR-022"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.3 \u2014 Trade\u2011ID registry dedupe"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests",
          "crates/soldier_infra/src/store"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN a trade_id already recorded WHEN handling a trade event THEN it is a NOOP and no duplicate updates occur.",
        "GIVEN a new trade_id WHEN processing a trade THEN trade_id is appended to the durable ledger before applying updates.",
        "GIVEN a restart WHEN the same trade_id is seen again THEN it is ignored due to the registry.",
        "GIVEN concurrent events for the same trade_id WHEN inserting THEN the registry insert is atomic and only one apply occurs."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/trade_id_registry.rs with persistent registry logic.",
        "Wire registry into crates/soldier_infra/src/lib.rs.",
        "Append trade_id before applying TLSM or position updates.",
        "Implement insert-if-absent atomically (single transaction or unique constraint) to avoid double-apply on concurrency.",
        "Add counter trade_id_duplicates_total when a duplicate trade_id is ignored.",
        "Add unit tests in crates/soldier_infra/tests/test_trade_id_registry.rs for dedupe behavior, including a concurrent insert case."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_trade_id_registry"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_trade_id_registry output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
          "location": "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
          "anchor": "AT-269"
        }
      ],
      "enforcing_contract_ats": [
        "AT-269",
        "AT-270"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "trade_id_duplicates_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_trade_id_registry.rs"
      ]
    },
    {
      "id": "S4-003",
      "priority": 70,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.4 Dispatch requires durable WAL barrier",
      "category": "durability",
      "description": "Block dispatch until WAL durability marker when configured.",
      "contract_refs": [
        "CONTRACT.md \u00a72.4.1 WAL Writer Isolation (Hot Loop Protection)",
        "CONTRACT.md \u00a72.4 Durable Intent Ledger",
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234",
        "Anchor-006",
        "VR-014"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.4 \u2014 Dispatch requires durable WAL barrier (when configured)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests",
          "crates/soldier_infra/src/wal.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/src/deribit/**",
          "crates/soldier_core/**"
        ]
      },
      "acceptance": [
        "GIVEN the durability barrier config flag is enabled WHEN a caller awaits the durable-append barrier THEN the durable ledger returns only after the configured durability marker (fsync or equivalent) completes.",
        "GIVEN the durability barrier config flag is disabled WHEN a caller awaits the durable-append barrier THEN the durable ledger returns immediately after enqueue (no fsync wait).",
        "GIVEN the ledger enqueue queue is full or enqueue fails WHEN append is attempted THEN the durable ledger returns an error, increments ledger_write_errors, and does not block the caller indefinitely."
      ],
      "steps": [
        "Extend the ledger to expose a durable-append barrier API and config flag.",
        "Ensure WAL enqueue failure increments wal_write_errors and returns error without blocking.",
        "Add unit tests in crates/soldier_infra/tests/test_dispatch_durability.rs for barrier behavior.",
        "Document configuration flag require_wal_fsync_before_dispatch in infra config.",
        "Add a helper to surface barrier wait time for observability."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_dispatch_durability"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_dispatch_durability output"
      ],
      "dependencies": [
        "S4-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "RecordedBeforeDispatch is mandatory. DurableBeforeDispatch is required when the durability barrier flag is enabled.",
          "location": "CONTRACT.md \u00a72.4 Durable Intent Ledger",
          "anchor": "AT-935"
        }
      ],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "EXEC_WAL_WRITE_FAILED"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [
          {
            "name": "wal_durability_barrier_wait_ms",
            "type": "histogram",
            "unit": "ms",
            "labels": []
          },
          {
            "name": "wal_write_errors",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_dispatch_durability.rs"
      ]
    },
    {
      "id": "S5-000",
      "priority": 100,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.1 Liquidity Gate (book-walk WAP, reject sweep)",
      "category": "execution",
      "description": "Implement Liquidity Gate book-walk slippage checks and L2 staleness rejects for OPEN intents.",
      "contract_refs": [
        "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
        "CONTRACT.md Rejections due to missing/unparseable/stale L2 MUST use Rejected(LiquidityGateNoL2).",
        "CONTRACT.md AT-222",
        "CONTRACT.md AT-344",
        "CONTRACT.md AT-909",
        "CONTRACT.md AT-421",
        "VR-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.1 \u2014 Liquidity Gate (book-walk WAP, reject sweep)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/gate.rs",
          "crates/soldier_core/tests/test_liquidity_gate.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN an L2 book where OrderQty implies slippage_bps > max_slippage_bps WHEN Liquidity Gate evaluates an OPEN intent THEN the intent is rejected with Rejected(ExpectedSlippageTooHigh) and no OrderIntent is emitted.",
        "GIVEN L2BookSnapshot is missing, unparseable, or older than l2_book_snapshot_max_age_ms WHEN Liquidity Gate evaluates an OPEN intent THEN it is rejected with Rejected(LiquidityGateNoL2) and dispatch count remains 0.",
        "GIVEN L2 is missing or stale WHEN evaluating intents THEN CANCEL-only proceeds and CLOSE/HEDGE order placement is rejected.",
        "GIVEN Liquidity Gate rejects WHEN evaluated THEN a LiquidityGateReject log entry includes WAP and slippage_bps."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/gate.rs with a Liquidity Gate evaluator that walks L2 depth and computes WAP and slippage_bps.",
        "Validate L2BookSnapshot freshness and structure; treat missing/unparseable/stale snapshots as LiquidityGateNoL2.",
        "Reject OPEN intents when slippage_bps exceeds max_slippage_bps with Rejected(ExpectedSlippageTooHigh).",
        "Emit a LiquidityGateReject log entry that includes WAP and slippage_bps on rejection.",
        "Export the Liquidity Gate from crates/soldier_core/src/execution/mod.rs for chokepoint integration.",
        "Add unit tests in crates/soldier_core/tests/test_liquidity_gate.rs for sweep rejection, no-L2 rejection reason, and cancel vs close/hedge behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_liquidity_gate"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_liquidity_gate output",
        "Assertions in test_liquidity_gate.rs for Rejected(ExpectedSlippageTooHigh) and Rejected(LiquidityGateNoL2)",
        "Captured LiquidityGateReject log entry with WAP and slippage_bps in test output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Reject if slippage_bps > max_slippage_bps (default 10bps).",
          "location": "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
          "anchor": "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-222",
        "AT-344",
        "AT-909",
        "AT-421"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::ExpectedSlippageTooHigh",
          "RejectReason::LiquidityGateNoL2"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "expected_slippage_bps",
            "type": "histogram",
            "unit": "pct",
            "labels": []
          },
          {
            "name": "liquidity_gate_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_liquidity_gate.rs"
      ]
    },
    {
      "id": "S5-001",
      "priority": 90,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.2 Fee cache staleness (soft buffer / hard ReduceOnly latch)",
      "category": "risk",
      "description": "Apply fee model cache staleness rules with soft buffering and hard-stale RiskState::Degraded blocks.",
      "contract_refs": [
        "CONTRACT.md \u00a74.2 Fee-Aware Execution",
        "CONTRACT.md Fee Cache Staleness (Fail-Closed)",
        "CONTRACT.md AT-031",
        "CONTRACT.md AT-032",
        "CONTRACT.md AT-033",
        "CONTRACT.md AT-042",
        "CONTRACT.md AT-244",
        "CONTRACT.md AT-246",
        "VR-007"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.2 \u2014 Fee cache staleness (soft buffer / hard ReduceOnly latch)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/deribit/mod.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/state.rs",
          "crates/soldier_infra/src/deribit/account_summary.rs",
          "crates/soldier_core/src/risk/fees.rs",
          "crates/soldier_core/tests/test_fee_staleness.rs",
          "crates/soldier_infra/tests/test_fee_cache.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN fee_model_cache_age_s is in the soft-stale window (fee_cache_soft_s < age <= fee_cache_hard_s) WHEN estimating fees THEN fee_rate_effective applies fee_stale_buffer (0.20).",
        "GIVEN fee_model_cache_age_s > fee_cache_hard_s WHEN evaluating an OPEN intent THEN RiskState::Degraded is set and the OPEN is rejected (fail-closed) with 0 dispatches.",
        "GIVEN fee_model_cached_at_ts_ms is missing or unparseable WHEN staleness is computed THEN it is treated as hard stale and OPEN intents are rejected (fail-closed).",
        "GIVEN fee tier changes WHEN the next polling cycle completes THEN NetEdge uses the updated fee tier within one cycle."
      ],
      "steps": [
        "Add crates/soldier_infra/src/deribit/account_summary.rs to parse /private/get_account_summary and store fee tier data with fee_model_cached_at_ts_ms in epoch ms.",
        "Poll the account summary every 60s and update fee_model_cache_age_s based on now_ms - fee_model_cached_at_ts_ms.",
        "Implement fee staleness logic in crates/soldier_core/src/risk/fees.rs to apply fee_stale_buffer in the soft-stale window.",
        "Treat hard-stale or missing fee_model_cached_at_ts_ms as RiskState::Degraded and expose the flag to Phase 1 dispatch authorization (OPEN blocked, CLOSE/HEDGE/CANCEL allowed).",
        "Add unit tests in crates/soldier_core/tests/test_fee_staleness.rs for soft buffer and hard stale behavior.",
        "Add unit tests in crates/soldier_infra/tests/test_fee_cache.rs for missing timestamp handling, epoch-ms restart arithmetic, and fee tier update within one polling cycle."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_fee_staleness",
        "cargo test -p soldier_infra --test test_fee_cache"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_fee_staleness output",
        "cargo test -p soldier_infra --test test_fee_cache output",
        "Test assertions showing soft-stale fee buffer and hard-stale OPEN rejection"
      ],
      "dependencies": [
        "S5-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Hard stale (age > fee_cache_hard_s): set RiskState::Degraded.",
          "location": "CONTRACT.md \u00a74.2 Fee-Aware Execution",
          "anchor": "CONTRACT.md \u00a74.2 Fee-Aware Execution"
        }
      ],
      "enforcing_contract_ats": [
        "AT-031",
        "AT-032",
        "AT-033",
        "AT-042",
        "AT-244",
        "AT-246"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_FEE_MODEL_HARD_STALE",
          "REDUCEONLY_RISKSTATE_DEGRADED"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "fee_model_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "fee_model_refresh_fail_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_fee_staleness.rs",
        "crates/soldier_infra/tests/test_fee_cache.rs"
      ]
    },
    {
      "id": "S5-002",
      "priority": 80,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.3 NetEdge gate",
      "category": "execution",
      "description": "Reject OPEN intents when net edge after fees and slippage falls below min_edge_usd.",
      "contract_refs": [
        "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
        "CONTRACT.md net_edge_usd = gross_edge_usd - fee_usd - expected_slippage_usd",
        "CONTRACT.md AT-015",
        "CONTRACT.md AT-932",
        "Anchor-018",
        "VR-012",
        "VR-018",
        "VR-019",
        "VR-020",
        "AT-015",
        "AT-243",
        "AT-932"
      ],
      "plan_refs": [
        "Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer",
        "S5.3 \u2014 NetEdge gate"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/gates.rs",
          "crates/soldier_core/tests/test_net_edge_gate.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN net_edge_usd < min_edge_usd WHEN evaluating an OPEN intent THEN it is rejected with Rejected(NetEdgeTooLow) and no dispatch occurs.",
        "GIVEN fee_usd or expected_slippage_usd is missing/unparseable WHEN evaluating an OPEN intent THEN it is rejected with Rejected(NetEdgeInputMissing) and no dispatch occurs.",
        "GIVEN gross_edge_usd is missing/unparseable WHEN evaluating an OPEN intent THEN it is rejected (fail-closed) and no OrderIntent is emitted."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/gates.rs with a NetEdgeGate evaluator.",
        "Compute net_edge_usd from gross_edge_usd, fee_usd, and expected_slippage_usd.",
        "Reject OPEN intents when any NetEdge input is missing/unparseable with Rejected(NetEdgeInputMissing).",
        "Reject OPEN intents when net_edge_usd < min_edge_usd with Rejected(NetEdgeTooLow).",
        "Export NetEdgeGate from crates/soldier_core/src/execution/mod.rs for use in the dispatch chokepoint.",
        "Add unit tests in crates/soldier_core/tests/test_net_edge_gate.rs for low edge rejection, missing inputs, and fees exceeding gross edge."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_net_edge_gate"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_net_edge_gate output",
        "Test assertions for Rejected(NetEdgeTooLow) and Rejected(NetEdgeInputMissing)"
      ],
      "dependencies": [
        "S5-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "net_edge_usd = gross_edge_usd - fee_usd - expected_slippage_usd.",
          "location": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
          "anchor": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-015",
        "AT-932",
        "AT-243"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::NetEdgeTooLow",
          "RejectReason::NetEdgeInputMissing"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "net_edge_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_net_edge_gate.rs"
      ]
    },
    {
      "id": "S5-003",
      "priority": 70,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.4 IOC limit pricer clamp (guarantee min edge at limit)",
      "category": "execution",
      "description": "Clamp IOC limit prices to guarantee min-edge bounds using the fee-aware pricer.",
      "contract_refs": [
        "CONTRACT.md \u00a71.4 Fee-Aware IOC Limit Pricer (No Market Orders)",
        "CONTRACT.md AT-223"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.4 \u2014 IOC limit pricer clamp (guarantee min edge at limit)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/pricer.rs",
          "crates/soldier_core/tests/test_pricer.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN net_edge_usd < min_edge_usd WHEN the pricer evaluates an OPEN intent THEN it is rejected with Rejected(NetEdgeTooLow) and no dispatch occurs.",
        "GIVEN fair_price, fee_estimate_usd, min_edge_usd, qty, and side WHEN the pricer computes a limit THEN limit_price is clamped to max_price_for_min_edge and never crosses beyond the min-edge bound.",
        "GIVEN an IOC limit order fills WHEN execution occurs THEN no fill is worse than limit_price and realized edge at limit_price >= min_edge_usd."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/pricer.rs implementing the fee-aware IOC limit pricer.",
        "Compute net_edge_usd and reject OPEN intents when net_edge_usd < min_edge_usd.",
        "Calculate proposed_limit from fair_price +/- 0.5 * net_edge_per_unit and clamp to max_price_for_min_edge.",
        "Return limit_price for IOC dispatch without any market-order fallback.",
        "Export the pricer from crates/soldier_core/src/execution/mod.rs for chokepoint integration.",
        "Add unit tests in crates/soldier_core/tests/test_pricer.rs for clamped limits and min-edge enforcement."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_pricer"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_pricer output",
        "Test assertions showing limit_price clamp and min-edge enforcement"
      ],
      "dependencies": [
        "S5-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Final limit clamped to guarantee min edge at the limit price.",
          "location": "CONTRACT.md \u00a71.4 Fee-Aware IOC Limit Pricer (No Market Orders)",
          "anchor": "CONTRACT.md \u00a71.4 Fee-Aware IOC Limit Pricer (No Market Orders)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-223"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::NetEdgeTooLow"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "pricer_limit_vs_fair_bps",
            "type": "histogram",
            "unit": "pct",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_pricer.rs"
      ]
    },
    {
      "id": "S5-004",
      "priority": 60,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.5 Enforce single chokepoint build_order_intent() (gate ordering)",
      "category": "execution",
      "description": "Route all dispatch through build_order_intent() and enforce deterministic gate ordering at the chokepoint.",
      "contract_refs": [
        "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
        "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
        "CONTRACT.md RecordedBeforeDispatch",
        "CONTRACT.md CSP.5.2 Enforcement Rules"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.5 \u2014 Enforce single chokepoint build_order_intent() (gate ordering)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/build_order_intent.rs",
          "crates/soldier_core/tests/test_gate_ordering.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN build_order_intent is called for an OPEN intent WHEN gates run THEN the sequence is preflight -> quantize -> fee cache check -> Liquidity Gate -> Net Edge Gate -> pricer, and only after all pass does dispatch occur.",
        "GIVEN RiskState::Degraded WHEN an OPEN intent is evaluated at the chokepoint THEN it is rejected and dispatch count remains 0 while CLOSE/HEDGE/CANCEL remain allowed.",
        "GIVEN any dispatch attempt WHEN inspecting code paths THEN build_order_intent is the only constructor used for OrderIntent dispatch (no alternate bypass)."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/build_order_intent.rs to centralize intent construction and gating.",
        "Route all dispatch entry points through build_order_intent and return early on gate failures.",
        "Implement a deterministic gate sequence trace used by test_gate_ordering_call_log.",
        "Enforce Phase 1 dispatch authorization: if RiskState != Healthy, reject OPEN intents and allow CLOSE/HEDGE/CANCEL.",
        "Ensure intent recording occurs before any network dispatch (RecordedBeforeDispatch).",
        "Restrict dispatch helpers to pub(crate) and update module exports to prevent bypass.",
        "Add tests in crates/soldier_core/tests/test_gate_ordering.rs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_gate_ordering"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_gate_ordering output",
        "Gate sequence trace assertions showing ordered steps"
      ],
      "dependencies": [
        "S5-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "This gate MUST run before any OrderIntent is eligible for dispatch.",
          "location": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
          "anchor": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-015"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_RISKSTATE_DEGRADED"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "gate_sequence_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_gate_ordering.rs"
      ]
    },
    {
      "id": "S6-000",
      "priority": 95,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-A Single Dispatch Chokepoint Proof",
      "category": "hardening",
      "description": "Implement CI tests proving exactly one module/function may dispatch exchange orders with no bypass paths.",
      "contract_refs": [
        "RecordedBeforeDispatch",
        "AT-935",
        "Anchor-006",
        "VR-014",
        "1. Execution Architecture: The \"Atomic Group\" (Real-Time Repair)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_dispatch_chokepoint.rs",
          "docs/dispatch_chokepoint.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_dispatch_chokepoint_no_direct_exchange_client_usage runs WHEN exchange client is imported outside chokepoint module THEN test fails.",
        "GIVEN test_dispatch_visibility_is_restricted runs WHEN dispatch function is public beyond pub(crate) THEN test fails.",
        "GIVEN docs/dispatch_chokepoint.md exists WHEN reviewed THEN it names the exact module, function, and exchange client type."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_dispatch_chokepoint.rs with AST/grep checks for exchange client usage.",
        "Implement test_dispatch_chokepoint_no_direct_exchange_client_usage that fails if exchange client constructed outside chokepoint.",
        "Implement test_dispatch_visibility_is_restricted that fails if dispatch fn is not pub(crate).",
        "Create docs/dispatch_chokepoint.md documenting the chokepoint module, function, and normative statement.",
        "Run tests and verify they pass on compliant code."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_chokepoint"
      ],
      "evidence": [
        "cargo test output showing test_dispatch_chokepoint_no_direct_exchange_client_usage PASS",
        "cargo test output showing test_dispatch_visibility_is_restricted PASS",
        "docs/dispatch_chokepoint.md exists with required content"
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_dispatch_chokepoint.rs"
      ]
    },
    {
      "id": "S6-001",
      "priority": 94,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-B Determinism Snapshot Test",
      "category": "hardening",
      "description": "Implement CI test proving identical inputs produce identical intent bytes/hashes across runs and restarts.",
      "contract_refs": [
        "CSP.2.1 Stable Intent Identity",
        "1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "evidence/phase1/determinism/intent_hashes.txt",
          "crates/soldier_core/tests/test_intent_determinism.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_intent_determinism_same_inputs_same_hash runs with fixed inputs and frozen clock WHEN executed twice THEN intent hash is identical.",
        "GIVEN test runs across process restart WHEN inputs are identical THEN hash is identical.",
        "GIVEN HashMap iteration order varies WHEN intent is built THEN hash is still identical (no map ordering dependency)."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_intent_determinism.rs.",
        "Implement test_intent_determinism_same_inputs_same_hash with clock injection.",
        "Use deterministic seed/inputs and assert exact byte equality or hash equality.",
        "Emit hash values to evidence/phase1/determinism/intent_hashes.txt.",
        "Run test twice and verify hashes match."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_intent_determinism"
      ],
      "evidence": [
        "cargo test output showing test_intent_determinism_same_inputs_same_hash PASS",
        "evidence/phase1/determinism/intent_hashes.txt showing identical hashes"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-343",
        "AT-218",
        "AT-219",
        "AT-216"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_intent_determinism.rs"
      ]
    },
    {
      "id": "S6-002",
      "priority": 93,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-C No Partial Side Effects on Rejection",
      "category": "hardening",
      "description": "Implement CI test proving rejected intents leave no persistent state changes except counters/logs.",
      "contract_refs": [
        "RecordedBeforeDispatch",
        "AT-201",
        "Anchor-006",
        "1.2 Atomic Group Executor"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_rejection_side_effects.rs",
          "evidence/phase1/no_side_effects/rejection_cases.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_rejected_intent_has_no_side_effects runs for missing config rejection THEN durable ledger unchanged, no orders, no position delta.",
        "GIVEN test runs for invalid instrument meta rejection THEN same assertions hold.",
        "GIVEN test runs for quantization failure rejection THEN same assertions hold.",
        "GIVEN evidence/phase1/no_side_effects/rejection_cases.md exists THEN it lists at least 3 rejection cases with CI links."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_rejection_side_effects.rs.",
        "Implement test_rejected_intent_has_no_side_effects with parameterized rejection cases.",
        "Assert: WAL unchanged, no open orders, no position deltas, no exposure increments.",
        "Create evidence/phase1/no_side_effects/rejection_cases.md documenting 3+ cases.",
        "Link CI logs in the evidence doc."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_rejection_side_effects"
      ],
      "evidence": [
        "cargo test output showing test_rejected_intent_has_no_side_effects PASS",
        "evidence/phase1/no_side_effects/rejection_cases.md with 3+ cases"
      ],
      "dependencies": [
        "S6-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-201",
        "AT-926"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_rejection_side_effects.rs"
      ]
    },
    {
      "id": "S6-003",
      "priority": 92,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-D intent_id/run_id Propagation Contract",
      "category": "hardening",
      "description": "Implement CI test proving every intent-handling log/metric includes the same intent_id and run_id.",
      "contract_refs": [
        "0.Z.7.4 Observability Requirement"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "evidence/phase1/traceability/sample_rejection_log.txt",
          "crates/soldier_core/tests/test_intent_id_propagation.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_intent_id_propagates_to_logs_and_metrics triggers a rejected intent WHEN logs are captured THEN every log line includes identical intent_id.",
        "GIVEN metrics are emitted during intent handling WHEN inspected THEN they include intent_id label.",
        "GIVEN evidence/phase1/traceability/sample_rejection_log.txt exists THEN it shows consistent intent_id across all log lines."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_intent_id_propagation.rs.",
        "Implement test_intent_id_propagates_to_logs_and_metrics with log capture.",
        "Trigger a rejection and collect all logs/metrics from the intent span.",
        "Assert all entries include the same intent_id.",
        "Emit sample log to evidence/phase1/traceability/sample_rejection_log.txt."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_intent_id_propagation"
      ],
      "evidence": [
        "cargo test output showing test_intent_id_propagates_to_logs_and_metrics PASS",
        "evidence/phase1/traceability/sample_rejection_log.txt"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-902"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "intent_id_propagation_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_intent_id_propagation.rs"
      ]
    },
    {
      "id": "S6-004",
      "priority": 91,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-E Gate Ordering Constraints",
      "category": "hardening",
      "description": "Implement CI test and doc proving gate ordering invariants: reject before persist, WAL before dispatch.",
      "contract_refs": [
        "CONTRACT.md RecordedBeforeDispatch",
        "CONTRACT.md CSP.5.2 Enforcement Rules",
        "Anchor-006",
        "VR-014"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_gate_ordering.rs",
          "docs/intent_gate_invariants.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_gate_ordering_constraints runs WHEN a side effect occurs before final accept THEN test fails.",
        "GIVEN durable ledger commit is attempted after dispatch WHEN test runs THEN test fails.",
        "GIVEN docs/intent_gate_invariants.md exists THEN it states the 3 normative ordering constraints."
      ],
      "steps": [
        "Extend or create crates/soldier_core/tests/test_gate_ordering.rs.",
        "Implement test_gate_ordering_constraints with instrumented gate/side-effect events.",
        "Assert: reject gates before persist, WAL before dispatch, no side effects before accept.",
        "Create docs/intent_gate_invariants.md with normative statements.",
        "Run test and verify pass."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_gate_ordering"
      ],
      "evidence": [
        "cargo test output showing test_gate_ordering_constraints PASS",
        "docs/intent_gate_invariants.md with 3 normative statements"
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-010",
        "AT-1055",
        "AT-338"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_gate_ordering.rs"
      ]
    },
    {
      "id": "S6-005",
      "priority": 90,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-F Fail-Closed Defaults for Missing Config",
      "category": "hardening",
      "description": "Implement CI test proving missing critical config causes fail-closed rejection with enumerated reason code.",
      "contract_refs": [
        "Appendix A",
        "Appendix A: Configuration Defaults (Safety-Critical Thresholds)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "evidence/phase1/config_fail_closed/missing_keys_matrix.json",
          "crates/soldier_core/tests/test_missing_config.rs",
          "docs/critical_config_keys.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_missing_config_fails_closed runs for each critical key WHEN key is removed THEN intent rejected.",
        "GIVEN rejection occurs THEN no persistent side effects (durable ledger, orders, positions).",
        "GIVEN rejection occurs THEN reject reason is enumerated (not free text).",
        "GIVEN evidence/phase1/config_fail_closed/missing_keys_matrix.json exists THEN it shows PASS/FAIL + reason code per key."
      ],
      "steps": [
        "Create docs/critical_config_keys.md listing Phase-1 critical config keys.",
        "Create crates/soldier_core/tests/test_missing_config.rs.",
        "Implement test_missing_config_fails_closed parameterized over critical keys.",
        "Assert rejection, no side effects, enumerated reason code.",
        "Emit evidence/phase1/config_fail_closed/missing_keys_matrix.json from test."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_missing_config"
      ],
      "evidence": [
        "cargo test output showing test_missing_config_fails_closed PASS",
        "evidence/phase1/config_fail_closed/missing_keys_matrix.json",
        "docs/critical_config_keys.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-926",
        "AT-930"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "CONFIG_MISSING"
        ]
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_missing_config.rs"
      ]
    },
    {
      "id": "S6-006",
      "priority": 89,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates (Supplementary)",
      "story_ref": "P1-G Minimal Crash-Mid-Intent Proof",
      "category": "hardening",
      "description": "Implement CI test or drill proving crash mid-intent before dispatch causes no duplicate dispatch on restart.",
      "contract_refs": [
        "AT-935",
        "AT-233",
        "2.4 \u2014 WAL / intent ledger (RecordedBeforeDispatch)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "evidence/phase1/crash_mid_intent/drill.md",
          "crates/soldier_infra/tests/test_crash_mid_intent.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_crash_mid_intent_no_duplicate_dispatch runs WHEN process crashes before dispatch THEN restart produces no dispatch.",
        "GIVEN crash occurs mid-intent THEN no ghost state or unsafe opens on restart.",
        "IF AUTO test not feasible THEN evidence/phase1/crash_mid_intent/drill.md documents manual drill with proof logs."
      ],
      "steps": [
        "Create crates/soldier_infra/tests/test_crash_mid_intent.rs (preferred AUTO).",
        "Implement test_crash_mid_intent_no_duplicate_dispatch simulating crash before dispatch.",
        "Assert: no dispatch on restart, no side effects beyond counters/logs.",
        "If AUTO not feasible, document manual drill in evidence/phase1/crash_mid_intent/drill.md.",
        "Include trigger, restart steps, and proof logs in drill doc."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_crash_mid_intent"
      ],
      "evidence": [
        "cargo test output showing test_crash_mid_intent_no_duplicate_dispatch PASS",
        "OR evidence/phase1/crash_mid_intent/drill.md with recorded proof",
        "evidence/phase1/restart_loop/restart_100_cycles.log"
      ],
      "dependencies": [
        "S4-000",
        "S4-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-233",
        "AT-234"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_crash_mid_intent.rs"
      ]
    },
    {
      "id": "S6-007",
      "priority": 89,
      "phase": 2,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
      "story_ref": "S6.1 Inventory skew gate",
      "category": "risk",
      "description": "Implement S6.1 (Inventory skew gate) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "AT-030",
        "AT-043",
        "CONTRACT.md Inventory skew gate"
      ],
      "plan_refs": [
        "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
        "S6.1 \u2014 Inventory skew gate"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [
          "crates/soldier_core/tests/test_inventory_skew.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "tightens only for risk-increasing, may relax only for risk-reducing.",
        "Inputs (contract): `current_delta`, `delta_limit`, `side`, `min_edge_usd`, `limit_price`, `fair_price`.",
        "`delta_limit` MUST be provided by policy/config; missing \u21d2 reject OPEN intents (fail-closed)."
      ],
      "steps": [
        "Map S6.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S6.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S6.1: crates/soldier_core/tests/test_inventory_skew.rs::test_inventory_skew_rejects_risk_increasing_near_limit, crates/soldier_core/tests/test_inventory_skew.rs::test_inventory_skew_tick_penalty_max_is_exactly_3_ticks_at_bias_1_0.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_inventory_skew output",
        "PRD entry S6-007 records contract AT and test mappings for this story."
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S6.1 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:579",
          "anchor": "AT-030"
        }
      ],
      "enforcing_contract_ats": [
        "AT-030",
        "AT-043"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "INVENTORY_SKEW_REJECT"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-030",
          "AT-043"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_inventory_skew.rs::test_inventory_skew_rejects_risk_increasing_near_limit",
        "crates/soldier_core/tests/test_inventory_skew.rs::test_inventory_skew_tick_penalty_max_is_exactly_3_ticks_at_bias_1_0"
      ]
    },
    {
      "id": "S6-008",
      "priority": 88,
      "phase": 2,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
      "story_ref": "S6.2 Pending exposure reservation",
      "category": "risk",
      "description": "Implement S6.2 (Pending exposure reservation) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "CONTRACT.md Pending exposure reservation"
      ],
      "plan_refs": [
        "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
        "S6.2 \u2014 Pending exposure reservation"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [
          "crates/soldier_core/tests/test_pending_exposure.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "reserve before dispatch; release on terminal TLSM; concurrent opens cannot overfill.",
        "GIVEN contract AT coverage for S6.2 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S6.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S6.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S6.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S6.2: crates/soldier_core/tests/test_pending_exposure.rs::test_pending_exposure_reservation_blocks_overfill.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_pending_exposure output",
        "PRD entry S6-008 records contract AT and test mappings for this story."
      ],
      "dependencies": [
        "S6-007"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "Fail-closed contract behavior must be verified by targeted acceptance tests.",
          "location": "plans/prd.json S6-008",
          "anchor": "AT-043"
        }
      ],
      "enforcing_contract_ats": [
        "AT-043"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "PENDING_EXPOSURE_OVERFILL"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-043"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_pending_exposure.rs::test_pending_exposure_reservation_blocks_overfill"
      ]
    },
    {
      "id": "S6-009",
      "priority": 87,
      "phase": 2,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
      "story_ref": "S6.3 Global exposure budget (corr buckets)",
      "category": "risk",
      "description": "Implement S6.3 (Global exposure budget (corr buckets)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "CONTRACT.md Global exposure budget (corr buckets)"
      ],
      "plan_refs": [
        "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
        "S6.3 \u2014 Global exposure budget (corr buckets)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [
          "crates/soldier_core/tests/test_exposure_budget.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "correlation-aware; uses current+pending.",
        "Contract integration rule: Global Budget MUST be checked using current + pending exposure (no current-only).",
        "GIVEN adverse inputs for S6.3 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S6.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S6.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S6.3: crates/soldier_core/tests/test_exposure_budget.rs::test_global_exposure_budget_correlation_rejects.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_exposure_budget output",
        "PRD entry S6-009 records contract AT and test mappings for this story."
      ],
      "dependencies": [
        "S6-008"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "Fail-closed contract behavior must be verified by targeted acceptance tests.",
          "location": "plans/prd.json S6-009",
          "anchor": "AT-043"
        }
      ],
      "enforcing_contract_ats": [
        "AT-043"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "GLOBAL_EXPOSURE_BUDGET_REJECT"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-043"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_exposure_budget.rs::test_global_exposure_budget_correlation_rejects"
      ]
    },
    {
      "id": "S6-010",
      "priority": 86,
      "phase": 2,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
      "story_ref": "S6.4 Margin headroom gate",
      "category": "risk",
      "description": "Implement S6.4 (Margin headroom gate) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "CONTRACT.md Margin headroom gate"
      ],
      "plan_refs": [
        "Slice 6 \u2014 Inventory Skew + Pending Exposure + Global Budget + Margin Gate",
        "S6.4 \u2014 Margin headroom gate"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [
          "crates/soldier_core/tests/test_margin_gate.rs"
        ],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "70% reject opens; 85% ReduceOnly; 95% Kill.",
        "GIVEN contract AT coverage for S6.4 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S6.4 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S6.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S6.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S6.4: crates/soldier_core/tests/test_margin_gate.rs::test_margin_gate_thresholds_block_reduceonly_kill.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_margin_gate output",
        "PRD entry S6-010 records contract AT and test mappings for this story."
      ],
      "dependencies": [
        "S6-009"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "Fail-closed contract behavior must be verified by targeted acceptance tests.",
          "location": "plans/prd.json S6-010",
          "anchor": "AT-001"
        }
      ],
      "enforcing_contract_ats": [
        "AT-001"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_MM_UTIL_THRESHOLD"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-001"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_margin_gate.rs::test_margin_gate_thresholds_block_reduceonly_kill"
      ]
    },
    {
      "id": "S7-000",
      "priority": 100,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor \\+ Emergency Close \\+ Sequencer \\+ Churn Breaker",
      "story_ref": "S7.1 \u2014 Group state machine \\+ first-fail invariant",
      "category": "hardening",
      "description": "Implement S7.1 (Group state machine + first-fail invariant) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-116"
      ],
      "plan_refs": [
        "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
        "S7.1 \u2014 Group state machine + first-fail invariant"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "cannot mark Complete until safe; first failure seeds MixedFailed.",
        "First observed failure (reject/cancel/unfilled/partial mismatch) MUST seed MixedFailed and MUST NOT be overwritten by later async updates.",
        "GIVEN adverse inputs for S7.1 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S7.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S7.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S7.1: crates/soldier_core/tests/test_atomic_group.rs::test_atomic_group_mixed_failed_then_flattened, crates/soldier_core/tests/test_atomic_group.rs::test_mixed_failed_blocks_opens_until_neutral.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_atomic_group output",
        "PRD entry S7-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S7.1 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:627",
          "anchor": "AT-116"
        }
      ],
      "enforcing_contract_ats": [
        "AT-116"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-116"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_atomic_group.rs::test_atomic_group_mixed_failed_then_flattened",
        "crates/soldier_core/tests/test_atomic_group.rs::test_mixed_failed_blocks_opens_until_neutral"
      ]
    },
    {
      "id": "S7-001",
      "priority": 99,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor \\+ Emergency Close \\+ Sequencer \\+ Churn Breaker",
      "story_ref": "S7.2 \u2014 Bounded rescue (\u22642) and no chase loop",
      "category": "hardening",
      "description": "Implement S7.2 (Bounded rescue (\u22642) and no chase loop) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-117"
      ],
      "plan_refs": [
        "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
        "S7.2 \u2014 Bounded rescue (\u22642) and no chase loop"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "max 2 rescue IOC attempts; then flatten.",
        "GIVEN contract AT coverage for S7.2 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S7.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S7.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S7.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S7.2: crates/soldier_core/tests/test_atomic_group.rs::test_atomic_rescue_attempts_limited_to_two.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_atomic_group output",
        "PRD entry S7-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S7.2 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:635",
          "anchor": "AT-117"
        }
      ],
      "enforcing_contract_ats": [
        "AT-117"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-117"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_atomic_group.rs::test_atomic_rescue_attempts_limited_to_two"
      ]
    },
    {
      "id": "S7-002",
      "priority": 98,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor \\+ Emergency Close \\+ Sequencer \\+ Churn Breaker",
      "story_ref": "S7.3 \u2014 Deterministic emergency close \\+ hedge fallback",
      "category": "hardening",
      "description": "Implement S7.3 (Deterministic emergency close + hedge fallback) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-013",
        "AT-338",
        "AT-339",
        "AT-340",
        "AT-346",
        "AT-347",
        "AT-1049"
      ],
      "plan_refs": [
        "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
        "S7.3 \u2014 Deterministic emergency close + hedge fallback"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "3 tries IOC close; then reduce-only delta hedge; logs AtomicNakedEvent; TradingMode is ReduceOnly during exposure.",
        "GIVEN contract AT coverage for S7.3 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S7.3 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S7.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S7.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S7.3: crates/soldier_core/tests/test_emergency_close.rs::test_emergency_close_fallback_hedge_after_retries, crates/soldier_core/tests/test_emergency_close.rs::test_emergency_close_bypasses_liquidity_gate, crates/soldier_core/tests/test_emergency_close.rs::test_emergency_close_bypasses_net_edge_gate.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_emergency_close output",
        "PRD entry S7-002 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S7.3 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:640",
          "anchor": "AT-013"
        }
      ],
      "enforcing_contract_ats": [
        "AT-013",
        "AT-338",
        "AT-339",
        "AT-340",
        "AT-346",
        "AT-347",
        "AT-1049"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-013",
          "AT-338"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_emergency_close.rs::test_emergency_close_fallback_hedge_after_retries",
        "crates/soldier_core/tests/test_emergency_close.rs::test_emergency_close_bypasses_liquidity_gate",
        "crates/soldier_core/tests/test_emergency_close.rs::test_emergency_close_bypasses_net_edge_gate"
      ]
    },
    {
      "id": "S7-003",
      "priority": 97,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor \\+ Emergency Close \\+ Sequencer \\+ Churn Breaker",
      "story_ref": "S7.4 \u2014 Sequencer ordering rules",
      "category": "hardening",
      "description": "Implement S7.4 (Sequencer ordering rules) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
        "S7.4 \u2014 Sequencer ordering rules"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "close\u2192confirm\u2192hedge.",
        "Repair path: flatten filled legs first via emergency_close_algorithm; hedge only after flatten retries fail and exposure remains above limit.",
        "Never increase exposure while RiskState != Healthy (includes Degraded/Maintenance/Kill)."
      ],
      "steps": [
        "Map S7.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S7.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S7.4: crates/soldier_core/tests/test_sequencer.rs::test_sequencer_close_then_hedge_ordering, crates/soldier_core/tests/test_sequencer.rs::test_sequencer_blocks_exposure_increase_when_riskstate_not_healthy, crates/soldier_core/tests/test_sequencer.rs::test_sequencer_repair_flattens_before_hedge.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_sequencer output",
        "PRD entry S7-003 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_sequencer.rs::test_sequencer_close_then_hedge_ordering",
        "crates/soldier_core/tests/test_sequencer.rs::test_sequencer_blocks_exposure_increase_when_riskstate_not_healthy",
        "crates/soldier_core/tests/test_sequencer.rs::test_sequencer_repair_flattens_before_hedge"
      ]
    },
    {
      "id": "S7-004",
      "priority": 96,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor \\+ Emergency Close \\+ Sequencer \\+ Churn Breaker",
      "story_ref": "S7.5 \u2014 Churn breaker",
      "category": "hardening",
      "description": "Implement S7.5 (Churn breaker) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
        "S7.5 \u2014 Churn breaker"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        ">2 flattens/5m => 15m blacklist blocks opens for that key.",
        "GIVEN contract AT coverage for S7.5 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S7.5 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S7.5 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S7.5 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S7.5: crates/soldier_core/tests/test_churn_breaker.rs::test_churn_breaker_blacklists_after_three.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_churn_breaker output",
        "PRD entry S7-004 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_churn_breaker.rs::test_churn_breaker_blacklists_after_three"
      ]
    },
    {
      "id": "S7-005",
      "priority": 95,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor \\+ Emergency Close \\+ Sequencer \\+ Churn Breaker",
      "story_ref": "S7.6 \u2014 Self\u2011Impact Feedback Loop Guard (Echo Chamber Breaker)",
      "category": "hardening",
      "description": "Implement S7.6 (Self\u2011Impact Feedback Loop Guard (Echo Chamber Breaker)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-953",
        "AT-955",
        "AT-956",
        "AT-957"
      ],
      "plan_refs": [
        "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
        "S7.6 \u2014 Self\u2011Impact Feedback Loop Guard (Echo Chamber Breaker)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "If public trade feed is stale/missing: MUST NOT compute self_fraction; set RiskState::Degraded; set Open Permission Latch `WS_TRADES_GAP_RECONCILE_REQUIRED`; block OPENs until reconcile clears.",
        "When feed is fresh: if self_fraction/self_notional trip conditions met for an OPEN in same direction as recent self trades, reject with `Rejected(FeedbackLoopGuardActive)` and apply cooldown.",
        "GIVEN adverse inputs for S7.6 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S7.6 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S7.6 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S7.6: crates/soldier_core/tests/test_self_impact.rs::test_self_impact_stale_feed_sets_latch, crates/soldier_core/tests/test_self_impact.rs::test_self_impact_fraction_trip_rejects, crates/soldier_core/tests/test_self_impact.rs::test_self_impact_notional_trip_rejects.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_self_impact output",
        "PRD entry S7-005 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S7.6 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:707",
          "anchor": "AT-953"
        }
      ],
      "enforcing_contract_ats": [
        "AT-953",
        "AT-955",
        "AT-956",
        "AT-957"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-953",
          "AT-955"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_self_impact.rs::test_self_impact_stale_feed_sets_latch",
        "crates/soldier_core/tests/test_self_impact.rs::test_self_impact_fraction_trip_rejects",
        "crates/soldier_core/tests/test_self_impact.rs::test_self_impact_notional_trip_rejects",
        "crates/soldier_core/tests/test_self_impact.rs::test_self_impact_below_threshold_allows"
      ]
    },
    {
      "id": "S8-000",
      "priority": 100,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.1 \u2014 PolicyGuard precedence \\+ staleness handling",
      "category": "hardening",
      "description": "Implement S8.1 (PolicyGuard precedence + staleness handling) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-001",
        "AT-112",
        "AT-991",
        "AT-992",
        "AT-1048",
        "AT-1050",
        "AT-1051",
        "AT-1052",
        "AT-1053",
        "AT-1054",
        "AT-1055",
        "AT-1065",
        "AT-1066",
        "AT-1067",
        "AT-1068",
        "AT-1069"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.1 \u2014 PolicyGuard precedence + staleness handling"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "recompute each tick; stale policy => ReduceOnly.",
        "Freshness defaults (contract): `mm_util_max_age_ms = 30_000`, `disk_used_max_age_ms = 30_000`.",
        "Timebase: now_ms and all *_ts_ms used for staleness/Kill decisions are monotonic\u2011epoch per contract \u00a70.Z.2.2.H; do not use raw system clock for interval comparisons."
      ],
      "steps": [
        "Map S8.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.1: crates/soldier_core/tests/test_profile_isolation.rs::test_csp_ignores_gop_health, crates/soldier_core/tests/test_profile_isolation.rs::test_gop_blocks_opens_when_evidence_not_green, crates/soldier_core/tests/test_policy_guard.rs::test_policyguard_snapshot_coherency_never_active.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_profile_isolation output",
        "PRD entry S8-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.1 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:721",
          "anchor": "AT-001"
        }
      ],
      "enforcing_contract_ats": [
        "AT-001",
        "AT-112",
        "AT-991",
        "AT-992",
        "AT-1048",
        "AT-1050",
        "AT-1051",
        "AT-1052",
        "AT-1053",
        "AT-1054",
        "AT-1055",
        "AT-1065",
        "AT-1066",
        "AT-1067",
        "AT-1068",
        "AT-1069"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s8_000_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-001",
          "AT-112"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_profile_isolation.rs::test_csp_ignores_gop_health",
        "crates/soldier_core/tests/test_profile_isolation.rs::test_gop_blocks_opens_when_evidence_not_green",
        "crates/soldier_core/tests/test_policy_guard.rs::test_policyguard_snapshot_coherency_never_active",
        "crates/soldier_core/tests/test_policy_guard.rs::test_execution_style_does_not_change_trading_mode",
        "crates/soldier_core/tests/test_policy_guard.rs::test_policy_guard_late_policy_update_stays_reduceonly",
        "crates/soldier_core/tests/test_policy_guard.rs::test_policy_guard_override_priority",
        "crates/soldier_core/tests/test_policy_freshness.rs::test_policy_age_sec_boundary_300_no_trip",
        "crates/soldier_core/tests/test_policy_freshness.rs::test_policy_age_sec_301_trips_reduceonly",
        "crates/soldier_core/tests/test_policy_freshness.rs::test_max_policy_age_sec_forces_reduceonly_after_300s",
        "crates/soldier_core/tests/test_policy_guard.rs::test_mm_util_stale_forces_reduceonly_input_missing_or_stale",
        "crates/soldier_core/tests/test_policy_guard.rs::test_missing_watchdog_heartbeat_forces_reduceonly_input_missing_or_stale",
        "crates/soldier_core/tests/test_policy_guard.rs::test_watchdog_unconfirmed_forces_reduceonly",
        "crates/soldier_core/tests/test_policy_guard.rs::test_disk_kill_unconfirmed_forces_reduceonly",
        "crates/soldier_core/tests/test_policy_guard.rs::test_session_kill_unconfirmed_forces_reduceonly",
        "crates/soldier_core/tests/test_policy_guard.rs::test_kill_confirmed_requires_corroboration",
        "crates/soldier_core/tests/test_order_cancel.rs::test_reduceonly_cancels_risk_increasing_opens"
      ]
    },
    {
      "id": "S8-001",
      "priority": 99,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.2 \u2014 Runtime F1 gate (HARD): artifacts/F1\\_CERT.json",
      "category": "hardening",
      "description": "Implement S8.2 (Runtime F1 gate (HARD): artifacts/F1_CERT.json) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-012",
        "AT-020",
        "AT-021"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.2 \u2014 Runtime F1 gate (HARD): artifacts/F1_CERT.json"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "missing/stale/FAIL => ReduceOnly; no grace; no caching last-known-good.",
        "Explicit identifier: `artifacts/RELEASE_CERT.json` (a.k.a. `release_cert`); missing/unparseable is a hard ReduceOnly.",
        "GIVEN adverse inputs for S8.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S8.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.2: crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_missing_forces_reduceonly, crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_fail_forces_reduceonly, crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_stale_forces_reduceonly.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_f1_gate output",
        "PRD entry S8-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.2 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:789",
          "anchor": "AT-012"
        }
      ],
      "enforcing_contract_ats": [
        "AT-012",
        "AT-020",
        "AT-021"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-012",
          "AT-020"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_missing_forces_reduceonly",
        "crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_fail_forces_reduceonly",
        "crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_stale_forces_reduceonly",
        "crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_binding_mismatch_forces_reduceonly",
        "crates/soldier_core/tests/test_f1_gate.rs::test_f1_cert_no_last_known_good_bypass",
        "crates/soldier_core/tests/test_f1_gate.rs::test_contract_version_format_numeric_only_rejects_v_prefix"
      ]
    },
    {
      "id": "S8-002",
      "priority": 98,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.3 \u2014 EvidenceGuard (Patch B) enforcement + cooldown",
      "category": "hardening",
      "description": "Implement S8.3 (EvidenceGuard (Patch B) enforcement + cooldown) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-005",
        "AT-105",
        "AT-107"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.3 \u2014 EvidenceGuard (Patch B) enforcement + cooldown"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "evidence chain not GREEN => ReduceOnly; CLOSE/HEDGE/CANCEL allowed; cooldown after recovery.",
        "EvidenceChainState GREEN must be computed over chain_guard_window_s (default 60s) rolling window and requires all of:",
        "truth_capsule_write_errors == 0"
      ],
      "steps": [
        "Map S8.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.3: crates/soldier_core/tests/test_evidence_guard.rs::test_evidence_guard_blocks_opens_allows_closes, crates/soldier_core/tests/test_evidence_guard.rs::test_evidence_guard_cooldown_after_recovery, crates/soldier_core/tests/test_evidence_guard.rs::test_evidenceguard_window_boundary_60s.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_evidence_guard output",
        "PRD entry S8-002 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.3 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:824",
          "anchor": "AT-005"
        }
      ],
      "enforcing_contract_ats": [
        "AT-005",
        "AT-105",
        "AT-107"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s8_002_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-005",
          "AT-105"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_evidence_guard.rs::test_evidence_guard_blocks_opens_allows_closes",
        "crates/soldier_core/tests/test_evidence_guard.rs::test_evidence_guard_cooldown_after_recovery",
        "crates/soldier_core/tests/test_evidence_guard.rs::test_evidenceguard_window_boundary_60s",
        "crates/soldier_core/tests/test_evidence_guard.rs::test_wal_write_errors_force_not_green",
        "crates/soldier_core/tests/test_evidence_guard.rs::test_evidence_guard_non_fill_does_not_require_attribution"
      ]
    },
    {
      "id": "S8-003",
      "priority": 97,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.4 \u2014 Bunker Mode network jitter monitor (Patch C)",
      "category": "hardening",
      "description": "Implement S8.4 (Bunker Mode network jitter monitor (Patch C)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-115",
        "AT-205",
        "AT-345"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.4 \u2014 Bunker Mode network jitter monitor (Patch C)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "jitter thresholds => ReduceOnly; stable cooldown required to exit.",
        "Fail-closed metric rule (contract): if `ws_event_lag_ms` is missing/uncomputable, set `bunker_mode_active = true` and block OPENs (AT-205).",
        "GIVEN adverse inputs for S8.4 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S8.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.4: crates/soldier_core/tests/test_bunker_mode.rs::test_ws_event_lag_breach_blocks_opens, crates/soldier_core/tests/test_bunker_mode.rs::test_bunker_mode_cooldown_then_exit, crates/soldier_core/tests/test_bunker_mode.rs::test_bunker_mode_exit_after_stable_window.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_bunker_mode output",
        "PRD entry S8-003 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.4 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:880",
          "anchor": "AT-115"
        }
      ],
      "enforcing_contract_ats": [
        "AT-115",
        "AT-205",
        "AT-345"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s8_003_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-115",
          "AT-205"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_bunker_mode.rs::test_ws_event_lag_breach_blocks_opens",
        "crates/soldier_core/tests/test_bunker_mode.rs::test_bunker_mode_cooldown_then_exit",
        "crates/soldier_core/tests/test_bunker_mode.rs::test_bunker_mode_exit_after_stable_window",
        "crates/soldier_core/tests/test_bunker_mode.rs::test_bunker_mode_http_p95_three_consecutive_breaches"
      ]
    },
    {
      "id": "S8-004",
      "priority": 96,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.5 \u2014 Cortex enforcement",
      "category": "hardening",
      "description": "Implement S8.5 (Cortex enforcement) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-045",
        "AT-119"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.5 \u2014 Cortex enforcement"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "DVOL/spread/depth shocks => ReduceOnly; WS gap blocks risk-increasing cancel/replace.",
        "GIVEN contract AT coverage for S8.5 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S8.5 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S8.5 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.5 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.5: crates/soldier_core/tests/test_cortex.rs::test_cortex_dvol_spike_force_reduceonly, crates/soldier_core/tests/test_cortex.rs::test_ws_gap_blocks_risk_increasing_cancel_replace, crates/soldier_core/tests/test_cortex.rs::test_cortex_force_kill_on_spread_or_depth.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_cortex output",
        "PRD entry S8-004 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.5 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:898",
          "anchor": "AT-045"
        }
      ],
      "enforcing_contract_ats": [
        "AT-045",
        "AT-119"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-045",
          "AT-119"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_cortex.rs::test_cortex_dvol_spike_force_reduceonly",
        "crates/soldier_core/tests/test_cortex.rs::test_ws_gap_blocks_risk_increasing_cancel_replace",
        "crates/soldier_core/tests/test_cortex.rs::test_cortex_force_kill_on_spread_or_depth"
      ]
    },
    {
      "id": "S8-005",
      "priority": 95,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.6 \u2014 Exchange maintenance monitor",
      "category": "hardening",
      "description": "Implement S8.6 (Exchange maintenance monitor) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-204"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.6 \u2014 Exchange maintenance monitor"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "maint within 60m => set RiskState::Maintenance; mode resolver forces ReduceOnly; /api/v1/status reports risk_state=Maintenance; opens blocked.",
        "Fail-closed handling (contract): if `/public/get_announcements` unreachable/invalid for `exchange_health_stale_s` (default 180s), set `cortex_override = ForceReduceOnly` and block OPENs (AT-204).",
        "GIVEN adverse inputs for S8.6 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S8.6 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.6 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.6: crates/soldier_core/tests/test_exchange_health.rs::test_exchange_health_maintenance_blocks_opens, crates/soldier_core/tests/test_exchange_health.rs::test_exchange_health_stale_announcements_force_reduceonly.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_exchange_health output",
        "PRD entry S8-005 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.6 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:917",
          "anchor": "AT-204"
        }
      ],
      "enforcing_contract_ats": [
        "AT-204"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s8_005_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-204"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_exchange_health.rs::test_exchange_health_maintenance_blocks_opens",
        "crates/soldier_core/tests/test_exchange_health.rs::test_exchange_health_stale_announcements_force_reduceonly"
      ]
    },
    {
      "id": "S8-006",
      "priority": 94,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.7 \u2014 Endpoint: POST /api/v1/emergency/reduce\\_only (existing plan)",
      "category": "hardening",
      "description": "Implement S8.7 (Endpoint: POST /api/v1/emergency/reduce_only (existing plan)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.7 \u2014 Endpoint: POST /api/v1/emergency/reduce_only (existing plan)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_core/src",
          "crates/soldier_infra/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "flips to ReduceOnly; cancels only non-reduce-only opens; preserves closes/hedges.",
        "GIVEN contract AT coverage for S8.7 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S8.7 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S8.7 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.7 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.7: crates/soldier_infra/tests/test_http_emergency.rs::test_post_emergency_reduce_only_endpoint.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_http_emergency output",
        "PRD entry S8-006 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_http_emergency.rs::test_post_emergency_reduce_only_endpoint"
      ]
    },
    {
      "id": "S8-007",
      "priority": 93,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.8 \u2014 Owner endpoint: GET /api/v1/status (Patch D)",
      "category": "hardening",
      "description": "Implement S8.8 (Owner endpoint: GET /api/v1/status (Patch D)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-003",
        "AT-023",
        "AT-024",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-028",
        "AT-029",
        "AT-405",
        "AT-407",
        "AT-419",
        "AT-907",
        "AT-927",
        "AT-967"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.8 \u2014 Owner endpoint: GET /api/v1/status (Patch D)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_infra/tests",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "HTTP 200 JSON includes keys (contract \u00a77.0):",
        "status_schema_version (int; current=1)",
        "supported_profiles (string[]; MUST include CSP)"
      ],
      "steps": [
        "Map S8.8 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.8 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.8: crates/soldier_infra/tests/test_http_status.rs::test_status_endpoint_returns_required_fields, crates/soldier_infra/tests/test_http_status.rs::test_status_mode_reasons_empty_iff_active, crates/soldier_infra/tests/test_http_status.rs::test_status_mode_reasons_tier_purity_and_ordering.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_http_status output",
        "PRD entry S8-007 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.8 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:941",
          "anchor": "AT-003"
        }
      ],
      "enforcing_contract_ats": [
        "AT-003",
        "AT-023",
        "AT-024",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-028",
        "AT-029",
        "AT-405",
        "AT-407",
        "AT-419",
        "AT-907",
        "AT-927",
        "AT-967"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state",
          "mode_reasons"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_http_status.rs::test_status_endpoint_returns_required_fields",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_mode_reasons_empty_iff_active",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_mode_reasons_tier_purity_and_ordering",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_open_permission_latch_invariants",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_policy_timestamp_consistency",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_snapshot_coverage_pct_uses_replay_window_hours",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_schema_version_is_1",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_includes_all_required_fields",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_rate_limit_counters_present",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_atomic_naked_events_non_negative",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_wal_queue_invariants",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_gop_keys_present_when_gop",
        "crates/soldier_infra/tests/test_http_status.rs::test_status_rejects_non_get",
        "crates/soldier_core/tests/test_status_endpoint.rs::test_status_endpoint_f1_cert_expires_at_matches_generated_plus_window"
      ]
    },
    {
      "id": "S8-008",
      "priority": 92,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.9 \u2014 Owner endpoint: GET /api/v1/health (minimal, read-only)",
      "category": "hardening",
      "description": "Implement S8.9 (Owner endpoint: GET /api/v1/health (minimal, read-only)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-022"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.9 \u2014 Owner endpoint: GET /api/v1/health (minimal, read-only)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_infra/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "HTTP 200 JSON includes keys (contract \u00a77.0):",
        "ok (bool; MUST be true when process is up)",
        "build_id (string)"
      ],
      "steps": [
        "Map S8.9 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.9 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.9: crates/soldier_infra/tests/test_http_health.rs::test_health_endpoint_returns_minimal_payload.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_http_health output",
        "PRD entry S8-008 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.9 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1007",
          "anchor": "AT-022"
        }
      ],
      "enforcing_contract_ats": [
        "AT-022"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-022"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_http_health.rs::test_health_endpoint_returns_minimal_payload"
      ]
    },
    {
      "id": "S8-009",
      "priority": 91,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard \\+ Cortex \\+ Exchange Health \\+ Bunker/Evidence/F1 \\+ Owner Endpoints (Patch D)",
      "story_ref": "S8.10 \u2014 Basis monitor (Mark/Index/Last liquidation reality guard)",
      "category": "hardening",
      "description": "Implement S8.10 (Basis monitor (Mark/Index/Last liquidation reality guard)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-951",
        "AT-952",
        "AT-954"
      ],
      "plan_refs": [
        "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
        "S8.10 \u2014 Basis monitor (Mark/Index/Last liquidation reality guard)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "If any required price is missing/unparseable OR stale beyond basis_price_max_age_ms, emit ForceReduceOnly{cooldown_s=basis_reduceonly_cooldown_s}.",
        "If max(basis_mark_last_bps, basis_mark_index_bps) >= basis_kill_bps for basis_kill_window_s \u21d2 ForceKill.",
        "Else if >= basis_reduceonly_bps for basis_reduceonly_window_s \u21d2 ForceReduceOnly{cooldown_s=basis_reduceonly_cooldown_s}."
      ],
      "steps": [
        "Map S8.10 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S8.10 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S8.10: crates/soldier_core/tests/test_basis_monitor.rs::test_basis_reduceonly_trip, crates/soldier_core/tests/test_basis_monitor.rs::test_basis_kill_trip, crates/soldier_core/tests/test_basis_monitor.rs::test_basis_missing_stale_fails_closed.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_basis_monitor output",
        "PRD entry S8-009 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S8.10 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1022",
          "anchor": "AT-951"
        }
      ],
      "enforcing_contract_ats": [
        "AT-951",
        "AT-952",
        "AT-954"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s8_009_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-951",
          "AT-952"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_basis_monitor.rs::test_basis_reduceonly_trip",
        "crates/soldier_core/tests/test_basis_monitor.rs::test_basis_kill_trip",
        "crates/soldier_core/tests/test_basis_monitor.rs::test_basis_missing_stale_fails_closed"
      ]
    },
    {
      "id": "S9-000",
      "priority": 100,
      "phase": 2,
      "slice": 9,
      "slice_ref": "Slice 9 \u2014 Rate Limit Circuit Breaker \\+ WS Gaps \\+ Reconcile \\+ Zombie Sweeper",
      "story_ref": "S9.1 \u2014 Rate limiter priority \\+ brownout",
      "category": "hardening",
      "description": "Implement S9.1 (Rate limiter priority + brownout) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-106",
        "AT-133"
      ],
      "plan_refs": [
        "Slice 9 \u2014 Rate Limit Circuit Breaker + WS Gaps + Reconcile + Zombie Sweeper",
        "S9.1 \u2014 Rate limiter priority + brownout"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_infra/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "priority EMERGENCY_CLOSE>CANCEL>HEDGE>OPEN>DATA; shed DATA first; block OPEN under pressure.",
        "GIVEN contract AT coverage for S9.1 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S9.1 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S9.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S9.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S9.1: crates/soldier_infra/tests/test_rate_limiter.rs::test_rate_limiter_priority_preemption, crates/soldier_infra/tests/test_rate_limiter.rs::test_rate_limiter_ignores_rate_limit_headers, crates/soldier_infra/tests/test_rate_limiter.rs::test_429_triggers_degraded_on_first_observation.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_rate_limiter output",
        "PRD entry S9-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S9.1 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1036",
          "anchor": "AT-106"
        }
      ],
      "enforcing_contract_ats": [
        "AT-106",
        "AT-133"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-106",
          "AT-133"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_rate_limiter.rs::test_rate_limiter_priority_preemption",
        "crates/soldier_infra/tests/test_rate_limiter.rs::test_rate_limiter_ignores_rate_limit_headers",
        "crates/soldier_infra/tests/test_rate_limiter.rs::test_429_triggers_degraded_on_first_observation"
      ]
    },
    {
      "id": "S9-001",
      "priority": 99,
      "phase": 2,
      "slice": 9,
      "slice_ref": "Slice 9 \u2014 Rate Limit Circuit Breaker \\+ WS Gaps \\+ Reconcile \\+ Zombie Sweeper",
      "story_ref": "S9.2 \u2014 10028/too\\_many\\_requests \\=\\> Kill \\+ reconnect \\+ reconcile",
      "category": "hardening",
      "description": "Implement S9.2 (10028/too_many_requests => Kill + reconnect + reconcile) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 9 \u2014 Rate Limit Circuit Breaker + WS Gaps + Reconcile + Zombie Sweeper",
        "S9.2 \u2014 10028/too_many_requests => Kill + reconnect + reconcile"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_core/src/recovery",
          "crates/soldier_infra/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "10028 triggers rate_limit_session_kill_active == true, TradingMode == Kill, RiskState == Degraded immediately; backoff; reconcile before resume.",
        "GIVEN contract AT coverage for S9.2 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S9.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S9.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S9.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S9.2: crates/soldier_infra/tests/test_rate_limiter.rs::test_rate_limit_10028_triggers_kill_and_reconnect.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_rate_limiter output",
        "PRD entry S9-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_rate_limiter.rs::test_rate_limit_10028_triggers_kill_and_reconnect"
      ]
    },
    {
      "id": "S9-002",
      "priority": 98,
      "phase": 2,
      "slice": 9,
      "slice_ref": "Slice 9 \u2014 Rate Limit Circuit Breaker \\+ WS Gaps \\+ Reconcile \\+ Zombie Sweeper",
      "story_ref": "S9.3 \u2014 WS gap detection (book/trades/private) \\=\\> Degraded \\+ REST snapshots",
      "category": "hardening",
      "description": "Implement S9.3 (WS gap detection (book/trades/private) => Degraded + REST snapshots) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 9 \u2014 Rate Limit Circuit Breaker + WS Gaps + Reconcile + Zombie Sweeper",
        "S9.3 \u2014 WS gap detection (book/trades/private) => Degraded + REST snapshots"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/recovery",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "per-channel continuity rules; gap => Degraded + resubscribe + snapshot rebuild.",
        "GIVEN contract AT coverage for S9.3 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S9.3 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S9.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S9.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S9.3: crates/soldier_core/tests/test_ws_gap.rs::test_orderbook_gap_triggers_resubscribe_and_snapshot, crates/soldier_core/tests/test_ws_gap.rs::test_trades_gap_triggers_reconcile.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_ws_gap output",
        "PRD entry S9-002 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_ws_gap.rs::test_orderbook_gap_triggers_resubscribe_and_snapshot",
        "crates/soldier_core/tests/test_ws_gap.rs::test_trades_gap_triggers_reconcile"
      ]
    },
    {
      "id": "S9-003",
      "priority": 97,
      "phase": 2,
      "slice": 9,
      "slice_ref": "Slice 9 \u2014 Rate Limit Circuit Breaker \\+ WS Gaps \\+ Reconcile \\+ Zombie Sweeper",
      "story_ref": "S9.4 \u2014 OpenPermission latch",
      "category": "hardening",
      "description": "Implement S9.4 (OpenPermission latch) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-010",
        "AT-011",
        "AT-110",
        "AT-120",
        "AT-917"
      ],
      "plan_refs": [
        "Slice 9 \u2014 Rate Limit Circuit Breaker + WS Gaps + Reconcile + Zombie Sweeper",
        "S9.4 \u2014 OpenPermission latch"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "On startup: `open_permission_blocked_latch = true` with reason code `RESTART_RECONCILE_REQUIRED`.",
        "When latch is true: OPEN intents are blocked; CLOSE/HEDGE/CANCEL remain allowed.",
        "`open_permission_reason_codes == []` iff `open_permission_blocked_latch == false`."
      ],
      "steps": [
        "Map S9.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S9.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S9.4: crates/soldier_core/tests/test_open_permission.rs::test_open_permission_blocks_opens_until_reconciled, crates/soldier_core/tests/test_reconcile.rs::test_position_reconcile_epsilon_tolerates_1e_6_qty_diff, crates/soldier_core/tests/test_reconcile.rs::test_reconcile_trade_lookback_sec_queries_300s_history.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_open_permission output",
        "cargo test -p soldier_core --test test_reconcile output",
        "PRD entry S9-003 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S9.4 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1086",
          "anchor": "AT-010"
        }
      ],
      "enforcing_contract_ats": [
        "AT-010",
        "AT-011",
        "AT-110",
        "AT-120",
        "AT-917"
      ],
      "reason_codes": {
        "type": "OpenPermissionReasonCode",
        "values": [
          "RESTART_RECONCILE_REQUIRED"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-010",
          "AT-011"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_open_permission.rs::test_open_permission_blocks_opens_until_reconciled",
        "crates/soldier_core/tests/test_reconcile.rs::test_position_reconcile_epsilon_tolerates_1e_6_qty_diff",
        "crates/soldier_core/tests/test_reconcile.rs::test_reconcile_trade_lookback_sec_queries_300s_history",
        "crates/soldier_core/tests/test_open_permission.rs::test_open_permission_latch_blocks_opens_allows_closes",
        "crates/soldier_core/tests/test_open_permission.rs::test_open_permission_clears_after_reconcile",
        "crates/soldier_core/tests/test_open_permission.rs::test_reduce_only_missing_treated_as_open",
        "crates/soldier_core/tests/test_open_permission.rs::test_risk_increasing_cancel_blocked_when_degraded",
        "crates/soldier_core/tests/test_cancel_replace.rs::test_risk_increasing_cancel_replace_rejected_when_evidence_not_green"
      ]
    },
    {
      "id": "S9-004",
      "priority": 96,
      "phase": 2,
      "slice": 9,
      "slice_ref": "Slice 9 \u2014 Rate Limit Circuit Breaker \\+ WS Gaps \\+ Reconcile \\+ Zombie Sweeper",
      "story_ref": "S9.5 \u2014 Zombie sweeper (ghost orders \\+ orphan fills)",
      "category": "hardening",
      "description": "Implement S9.5 (Zombie sweeper (ghost orders + orphan fills)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-121",
        "AT-122",
        "AT-123",
        "AT-124"
      ],
      "plan_refs": [
        "Slice 9 \u2014 Rate Limit Circuit Breaker + WS Gaps + Reconcile + Zombie Sweeper",
        "S9.5 \u2014 Zombie sweeper (ghost orders + orphan fills)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/recovery",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "cancel ghost s4: orders lacking ledger; reconcile orphan fills via REST; no duplicates via trade-id registry.",
        "Ghost order rule (AT-122): if exchange open order has label `s4:` and no matching ledger intent, issue `CancelStaleOrder` and log `GhostOrderCanceled`.",
        "Orphan fill rule (AT-121): REST trade reconcile updates TLSM and later WS trade is ignored via `processed_trade_ids`."
      ],
      "steps": [
        "Map S9.5 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S9.5 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S9.5: crates/soldier_core/tests/test_reconcile.rs::test_orphan_fill_reconciles_and_no_duplicate, crates/soldier_core/tests/test_zombie_sweeper.rs::test_zombie_sweeper_cancels_ghost_order, crates/soldier_core/tests/test_zombie_sweeper.rs::test_ghost_order_canceled_logs_event.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_reconcile output",
        "cargo test -p soldier_core --test test_zombie_sweeper output",
        "PRD entry S9-004 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S9.5 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1127",
          "anchor": "AT-121"
        }
      ],
      "enforcing_contract_ats": [
        "AT-121",
        "AT-122",
        "AT-123",
        "AT-124"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s9_004_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-121",
          "AT-122"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_reconcile.rs::test_orphan_fill_reconciles_and_no_duplicate",
        "crates/soldier_core/tests/test_zombie_sweeper.rs::test_zombie_sweeper_cancels_ghost_order",
        "crates/soldier_core/tests/test_zombie_sweeper.rs::test_ghost_order_canceled_logs_event",
        "crates/soldier_core/tests/test_reconcile.rs::test_orphan_fill_rest_updates_and_ws_ignored",
        "crates/soldier_core/tests/test_zombie_sweeper.rs::test_sweeper_marks_failed_when_no_open_and_no_trade",
        "crates/soldier_core/tests/test_zombie_sweeper.rs::test_stale_order_canceled_no_replace_when_degraded"
      ]
    },
    {
      "id": "S9-005",
      "priority": 95,
      "phase": 2,
      "slice": 9,
      "slice_ref": "Slice 9 \u2014 Rate Limit Circuit Breaker \\+ WS Gaps \\+ Reconcile \\+ Zombie Sweeper",
      "story_ref": "S9.6 \u2014 WS data liveness (Zombie Socket Detection)",
      "category": "hardening",
      "description": "Implement S9.6 (WS data liveness (Zombie Socket Detection)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-946",
        "AT-947",
        "AT-948"
      ],
      "plan_refs": [
        "Slice 9 \u2014 Rate Limit Circuit Breaker + WS Gaps + Reconcile + Zombie Sweeper",
        "S9.6 \u2014 WS data liveness (Zombie Socket Detection)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/recovery",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "Track last_marketdata_event_ts_ms from application marketdata payloads only.",
        "Trip `WS_DATA_STALE_RECONCILE_REQUIRED` only when `ws_marketdata_event_lag_ms > ws_zombie_silence_ms` AND (has_open_exposure OR had_recent_marketdata_activity).",
        "On trip: set RiskState::Degraded, set open_permission_blocked_latch with WS_DATA_STALE_RECONCILE_REQUIRED, force reconnect/resubscribe, REST snapshots + reconcile; opens blocked until reconcile clears."
      ],
      "steps": [
        "Map S9.6 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S9.6 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S9.6: crates/soldier_core/tests/test_ws_liveness.rs::test_zombie_socket_no_trip_if_other_marketdata_alive, crates/soldier_core/tests/test_ws_liveness.rs::test_zombie_socket_trip_when_lag_and_exposure, crates/soldier_core/tests/test_ws_liveness.rs::test_zombie_socket_no_trip_quiet_market.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_ws_liveness output",
        "PRD entry S9-005 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S9.6 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1147",
          "anchor": "AT-946"
        }
      ],
      "enforcing_contract_ats": [
        "AT-946",
        "AT-947",
        "AT-948"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s9_005_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-946",
          "AT-947"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_ws_liveness.rs::test_zombie_socket_no_trip_if_other_marketdata_alive",
        "crates/soldier_core/tests/test_ws_liveness.rs::test_zombie_socket_trip_when_lag_and_exposure",
        "crates/soldier_core/tests/test_ws_liveness.rs::test_zombie_socket_no_trip_quiet_market"
      ]
    },
    {
      "id": "S10-000",
      "priority": 100,
      "phase": 3,
      "slice": 10,
      "slice_ref": "Slice 10 \u2014 Truth Capsules \\+ Attribution \\+ Time Drift \\+ Decision Snapshots (required)",
      "story_ref": "S10.1 \u2014 TruthCapsule write-before-dispatch (bounded queue)",
      "category": "hardening",
      "description": "Implement S10.1 (TruthCapsule write-before-dispatch (bounded queue)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-046",
        "AT-1046",
        "AT-1047"
      ],
      "plan_refs": [
        "Slice 10 \u2014 Truth Capsules + Attribution + Time Drift + Decision Snapshots (required)",
        "S10.1 \u2014 TruthCapsule write-before-dispatch (bounded queue)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "Evidence commit barrier (when `enforced_profile != CSP`) is satisfied before any risk-increasing dispatch; enqueue/write failure flips EvidenceChainState RED.",
        "Hot loop MUST enqueue to a bounded queue; dedicated writer thread/process drains writes (no hot-loop stall).",
        "Any dispatched order MUST already have a truth_capsule_id linked by `(group_id, leg_idx, intent_hash)` and a joinable `decision_snapshot_id`; no dispatch without linkage."
      ],
      "steps": [
        "Map S10.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S10.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S10.1: crates/soldier_core/tests/test_truth_capsule.rs::test_truth_capsule_written_before_dispatch_and_fk_linked, crates/soldier_core/tests/test_truth_capsule.rs::test_truth_capsule_write_failure_forces_reduceonly, crates/soldier_core/tests/test_truth_capsule.rs::test_no_dispatch_without_truth_capsule_id.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_truth_capsule output",
        "PRD entry S10-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S10.1 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1184",
          "anchor": "AT-046"
        }
      ],
      "enforcing_contract_ats": [
        "AT-046",
        "AT-1046",
        "AT-1047"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-046",
          "AT-1046"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_truth_capsule.rs::test_truth_capsule_written_before_dispatch_and_fk_linked",
        "crates/soldier_core/tests/test_truth_capsule.rs::test_truth_capsule_write_failure_forces_reduceonly",
        "crates/soldier_core/tests/test_truth_capsule.rs::test_no_dispatch_without_truth_capsule_id",
        "crates/soldier_core/tests/test_truth_capsule.rs::test_evidence_commit_barrier_blocks_dispatch",
        "crates/soldier_core/tests/test_truth_capsule.rs::test_evidence_commit_barrier_fail_closed"
      ]
    },
    {
      "id": "S10-001",
      "priority": 99,
      "phase": 3,
      "slice": 10,
      "slice_ref": "Slice 10 \u2014 Truth Capsules \\+ Attribution \\+ Time Drift \\+ Decision Snapshots (required)",
      "story_ref": "S10.2 \u2014 Decision Snapshot capture/persist/link (Patch A requirement)",
      "category": "hardening",
      "description": "Implement S10.2 (Decision Snapshot capture/persist/link (Patch A requirement)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-044"
      ],
      "plan_refs": [
        "Slice 10 \u2014 Truth Capsules + Attribution + Time Drift + Decision Snapshots (required)",
        "S10.2 \u2014 Decision Snapshot capture/persist/link (Patch A requirement)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "L2 top\u2011N snapshot persisted; `decision_snapshot_id` stored in TruthCapsule; every dispatched intent MUST reference `decision_snapshot_id` and `SnapshotRecordedBeforeDispatch` MUST be true immediately before dispatch; `record_decision_snapshot()` returns Ok only after crash-safe persistence; `l2_snapshot_id` MUST NOT be emitted; failure treated as evidence failure (opens blocked, `decision_snapshot_write_errors` increments).",
        "ledger binding: for every dispatched intent, ledger intent record includes `truth_capsule_id`, `decision_snapshot_id`, and `decision_snapshot_recorded=true`; missing fields must block dispatch and enter ReduceOnly.",
        "GIVEN adverse inputs for S10.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S10.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S10.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S10.2: crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_is_required_and_linked, crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_write_failure_blocks_opens, crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_id_present_and_l2_snapshot_id_absent.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_decision_snapshot output",
        "PRD entry S10-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S10.2 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1198",
          "anchor": "AT-044"
        }
      ],
      "enforcing_contract_ats": [
        "AT-044",
        "AT-943",
        "AT-944",
        "AT-945"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-044",
          "AT-943"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_is_required_and_linked",
        "crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_write_failure_blocks_opens",
        "crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_id_present_and_l2_snapshot_id_absent",
        "crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_recorded_before_dispatch_survives_restart",
        "crates/soldier_core/tests/test_decision_snapshot.rs::test_decision_snapshot_persistence_failure_blocks_dispatch",
        "crates/soldier_core/tests/test_wal_intent_fields.rs::test_wal_intent_includes_decision_snapshot_fields"
      ]
    },
    {
      "id": "S10-002",
      "priority": 98,
      "phase": 3,
      "slice": 10,
      "slice_ref": "Slice 10 \u2014 Truth Capsules \\+ Attribution \\+ Time Drift \\+ Decision Snapshots (required)",
      "story_ref": "S10.3 \u2014 Attribution rows \\== fills (+ joins)",
      "category": "hardening",
      "description": "Implement S10.3 (Attribution rows == fills (+ joins)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 10 \u2014 Truth Capsules + Attribution + Time Drift + Decision Snapshots (required)",
        "S10.3 \u2014 Attribution rows == fills (+ joins)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "for each fill, one attribution row with truth_capsule_id and friction fields.",
        "Required fields include `fair_price_at_signal`, `exchange_ts`, `local_send_ts`, `local_recv_ts`, `drift_ms`.",
        "GIVEN adverse inputs for S10.3 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S10.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S10.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S10.3: crates/soldier_core/tests/test_attribution.rs::test_attribution_row_links_truth_capsule, crates/soldier_core/tests/test_parquet_schema.rs::test_shadow_and_live_schema_parity_includes_mode_field.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_attribution output",
        "cargo test -p soldier_core --test test_parquet_schema output",
        "PRD entry S10-002 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s10_002_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_attribution.rs::test_attribution_row_links_truth_capsule",
        "crates/soldier_core/tests/test_parquet_schema.rs::test_shadow_and_live_schema_parity_includes_mode_field"
      ]
    },
    {
      "id": "S10-003",
      "priority": 97,
      "phase": 3,
      "slice": 10,
      "slice_ref": "Slice 10 \u2014 Truth Capsules \\+ Attribution \\+ Time Drift \\+ Decision Snapshots (required)",
      "story_ref": "S10.4 \u2014 PnL decomposition units enforced (Python)",
      "category": "hardening",
      "description": "Implement S10.4 (PnL decomposition units enforced (Python)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 10 \u2014 Truth Capsules + Attribution + Time Drift + Decision Snapshots (required)",
        "S10.4 \u2014 PnL decomposition units enforced (Python)"
      ],
      "scope": {
        "touch": [
          "python"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "theta/day, vega/1pct; raw+normalized stored.",
        "GIVEN contract AT coverage for S10.4 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S10.4 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S10.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S10.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S10.4: python/tests/test_pnl_attribution.py::test_pnl_decomposition_theta_units, python/tests/test_pnl_attribution.py::test_pnl_decomposition_zero_when_no_move.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "python -m pytest python/tests/test_pnl_attribution.py::test_pnl_decomposition_theta_units output",
        "python -m pytest python/tests/test_pnl_attribution.py::test_pnl_decomposition_zero_when_no_move output",
        "PRD entry S10-003 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "python/tests/test_pnl_attribution.py::test_pnl_decomposition_theta_units",
        "python/tests/test_pnl_attribution.py::test_pnl_decomposition_zero_when_no_move"
      ]
    },
    {
      "id": "S10-004",
      "priority": 96,
      "phase": 3,
      "slice": 10,
      "slice_ref": "Slice 10 \u2014 Truth Capsules \\+ Attribution \\+ Time Drift \\+ Decision Snapshots (required)",
      "story_ref": "S10.5 \u2014 Time drift gate \\=\\> ReduceOnly",
      "category": "hardening",
      "description": "Implement S10.5 (Time drift gate => ReduceOnly) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-108"
      ],
      "plan_refs": [
        "Slice 10 \u2014 Truth Capsules + Attribution + Time Drift + Decision Snapshots (required)",
        "S10.5 \u2014 Time drift gate => ReduceOnly"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "if drift_ms > time_drift_threshold_ms then set RiskState::Degraded and mode resolver forces ReduceOnly; exposed in /status.",
        "Default threshold (contract): `time_drift_threshold_ms = 50` (configurable).",
        "GIVEN adverse inputs for S10.5 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S10.5 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S10.5 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S10.5: crates/soldier_core/tests/test_time_drift.rs::test_time_drift_gate_forces_reduceonly, crates/soldier_core/tests/test_time_drift.rs::test_time_drift_forces_policyguard_reduceonly.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_time_drift output",
        "PRD entry S10-004 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S10.5 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1223",
          "anchor": "AT-108"
        }
      ],
      "enforcing_contract_ats": [
        "AT-108"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "s10_004_checks_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-108"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_time_drift.rs::test_time_drift_gate_forces_reduceonly",
        "crates/soldier_core/tests/test_time_drift.rs::test_time_drift_forces_policyguard_reduceonly"
      ]
    },
    {
      "id": "S11-000",
      "priority": 100,
      "phase": 3,
      "slice": 11,
      "slice_ref": "Slice 11 \u2014 SVI Stability Gates \\+ Arb Guards",
      "story_ref": "S11.1 \u2014 RMSE/drift gates (liquidity-aware)",
      "category": "hardening",
      "description": "Implement S11.1 (RMSE/drift gates (liquidity-aware)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 11 \u2014 SVI Stability Gates + Arb Guards",
        "S11.1 \u2014 RMSE/drift gates (liquidity-aware)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "Gate 0 (liquidity-aware thresholds): if depth_topN < depth_min, set rmse_max = 0.08 and drift_max = 0.40; otherwise rmse_max = 0.05 and drift_max = 0.20.",
        "Explicit identifiers: `depth_topn` (top-N depth) and `depth_min` (minimum depth).",
        "Gate 1 (RMSE): rmse > rmse_max \u21d2 reject new fit."
      ],
      "steps": [
        "Map S11.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S11.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S11.1: crates/soldier_core/tests/test_svi.rs::test_svi_rmse_drift_gates, crates/soldier_core/tests/test_svi.rs::test_svi_depth_min_applies_loosened_thresholds.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_svi output",
        "PRD entry S11-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_svi.rs::test_svi_rmse_drift_gates",
        "crates/soldier_core/tests/test_svi.rs::test_svi_depth_min_applies_loosened_thresholds"
      ]
    },
    {
      "id": "S11-001",
      "priority": 99,
      "phase": 3,
      "slice": 11,
      "slice_ref": "Slice 11 \u2014 SVI Stability Gates \\+ Arb Guards",
      "story_ref": "S11.2 \u2014 Arb guards (convexity/calendar/density)",
      "category": "hardening",
      "description": "Implement S11.2 (Arb guards (convexity/calendar/density)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 11 \u2014 SVI Stability Gates + Arb Guards",
        "S11.2 \u2014 Arb guards (convexity/calendar/density)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "On any arb-guard failure: invalidate fit, hold last valid, increment svi_arb_guard_trips.",
        "GIVEN contract AT coverage for S11.2 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S11.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S11.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S11.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S11.2: crates/soldier_core/tests/test_svi.rs::test_svi_arb_guard_convexity_rejects, crates/soldier_core/tests/test_svi.rs::test_svi_arb_guard_trip_count_triggers_degraded_after_3_trips, crates/soldier_core/tests/test_svi.rs::test_svi_arb_violation_rejects_and_holds_last_fit.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_svi output",
        "PRD entry S11-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_svi.rs::test_svi_arb_guard_convexity_rejects",
        "crates/soldier_core/tests/test_svi.rs::test_svi_arb_guard_trip_count_triggers_degraded_after_3_trips",
        "crates/soldier_core/tests/test_svi.rs::test_svi_arb_violation_rejects_and_holds_last_fit"
      ]
    },
    {
      "id": "S11-002",
      "priority": 98,
      "phase": 3,
      "slice": 11,
      "slice_ref": "Slice 11 \u2014 SVI Stability Gates \\+ Arb Guards",
      "story_ref": "S11.3 \u2014 NaN/Inf guard holds last fit",
      "category": "hardening",
      "description": "Implement S11.3 (NaN/Inf guard holds last fit) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 11 \u2014 SVI Stability Gates + Arb Guards",
        "S11.3 \u2014 NaN/Inf guard holds last fit"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN S11.3 requirements are implemented WHEN targeted checks run THEN behavior is deterministic and fail-closed.",
        "GIVEN contract AT coverage for S11.3 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S11.3 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S11.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S11.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S11.3: crates/soldier_core/tests/test_svi.rs::test_svi_nan_guard_holds_last_fit.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_svi output",
        "PRD entry S11-002 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_svi.rs::test_svi_nan_guard_holds_last_fit"
      ]
    },
    {
      "id": "S12-000",
      "priority": 100,
      "phase": 3,
      "slice": 12,
      "slice_ref": "Slice 12 \u2014 Fill Simulator \\+ Slippage Calibration",
      "story_ref": "S12.1 \u2014 Deterministic fill simulator (book-walk \\+ fees)",
      "category": "hardening",
      "description": "Implement S12.1 (Deterministic fill simulator (book-walk + fees)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 12 \u2014 Fill Simulator + Slippage Calibration",
        "S12.1 \u2014 Deterministic fill simulator (book-walk + fees)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "given fixed L2 snapshot + size, simulator outputs deterministic WAP and `slippage_bps`.",
        "GIVEN contract AT coverage for S12.1 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S12.1 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S12.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S12.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S12.1: crates/soldier_core/tests/test_fill_sim.rs::test_fill_simulator_deterministic_wap, crates/soldier_core/tests/test_fill_sim.rs::test_fill_simulator_deterministic_slippage_bps.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_fill_sim output",
        "PRD entry S12-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_fill_sim.rs::test_fill_simulator_deterministic_wap",
        "crates/soldier_core/tests/test_fill_sim.rs::test_fill_simulator_deterministic_slippage_bps"
      ]
    },
    {
      "id": "S12-001",
      "priority": 99,
      "phase": 3,
      "slice": 12,
      "slice_ref": "Slice 12 \u2014 Fill Simulator \\+ Slippage Calibration",
      "story_ref": "S12.2 \u2014 Slippage calibration \\+ safe default (1.3)",
      "category": "hardening",
      "description": "Implement S12.2 (Slippage calibration + safe default (1.3)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 12 \u2014 Fill Simulator + Slippage Calibration",
        "S12.2 \u2014 Slippage calibration + safe default (1.3)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src",
          "python",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN S12.2 requirements are implemented WHEN targeted checks run THEN behavior is deterministic and fail-closed.",
        "GIVEN contract AT coverage for S12.2 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S12.2 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S12.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S12.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S12.2: crates/soldier_core/tests/test_slippage_calibration.rs::test_slippage_calibration_penalty_factor_converges, crates/soldier_core/tests/test_slippage_calibration.rs::test_realism_penalty_default_applied_when_missing.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_slippage_calibration output",
        "PRD entry S12-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_slippage_calibration.rs::test_slippage_calibration_penalty_factor_converges",
        "crates/soldier_core/tests/test_slippage_calibration.rs::test_realism_penalty_default_applied_when_missing"
      ]
    },
    {
      "id": "S13-000",
      "priority": 100,
      "phase": 4,
      "slice": 13,
      "slice_ref": "Slice 13 \u2014 Replay Gatekeeper \\+ Canary \\+ Reviews \\+ Retention \\+ F1 Cert",
      "story_ref": "S13.1 \u2014 Replay Gatekeeper (Decision Snapshots required; quality ladder + ungameable apply)",
      "category": "hardening",
      "description": "Implement S13.1 (Replay Gatekeeper (Decision Snapshots required; quality ladder + ungameable apply)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-002",
        "AT-034",
        "AT-040",
        "AT-257",
        "AT-1062",
        "AT-1064",
        "AT-1070"
      ],
      "plan_refs": [
        "Slice 13 \u2014 Replay Gatekeeper + Canary + Reviews + Retention + F1 Cert",
        "S13.1 \u2014 Replay Gatekeeper (Decision Snapshots required; quality ladder + ungameable apply)"
      ],
      "scope": {
        "touch": [
          "python",
          "crates/soldier_core/src/execution",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "Decision Snapshots required; QualityState/ApplyMode computed; tighten-only classifier enforced; haircut enforced by dispatch size; `dd_limit` explicit (missing \u21d2 fail-closed).",
        "Bad policy must fail due to realism penalty (profit flips \u2264 0).",
        "GIVEN adverse inputs for S13.1 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S13.1 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S13.1 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S13.1: python/tests/test_replay_gatekeeper.py::test_replay_gatekeeper_penalized_pnl_gate, python/tests/test_replay_gatekeeper.py::test_replay_quality_good_at_95, python/tests/test_replay_gatekeeper.py::test_replay_quality_degraded_applies_haircut_and_tighten_only.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "python -m pytest python/tests/test_replay_gatekeeper.py::test_replay_gatekeeper_penalized_pnl_gate output",
        "python -m pytest python/tests/test_replay_gatekeeper.py::test_replay_quality_good_at_95 output",
        "PRD entry S13-000 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S13.1 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1296",
          "anchor": "AT-002"
        }
      ],
      "enforcing_contract_ats": [
        "AT-002",
        "AT-034",
        "AT-040",
        "AT-257",
        "AT-1062",
        "AT-1064",
        "AT-1070"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-002",
          "AT-034"
        ]
      },
      "implementation_tests": [
        "python/tests/test_replay_gatekeeper.py::test_replay_gatekeeper_penalized_pnl_gate",
        "python/tests/test_replay_gatekeeper.py::test_replay_quality_good_at_95",
        "python/tests/test_replay_gatekeeper.py::test_replay_quality_degraded_applies_haircut_and_tighten_only",
        "python/tests/test_replay_gatekeeper.py::test_replay_quality_broken_shadow_only",
        "python/tests/test_replay_gatekeeper.py::test_replay_rejects_loosen_or_unknown_params_in_degraded",
        "python/tests/test_replay_gatekeeper.py::test_replay_hard_fails_when_dd_limit_missing",
        "crates/soldier_core/tests/test_dispatch_map.rs::test_open_haircut_mult_applies_to_open_only",
        "crates/soldier_core/tests/test_profile_isolation.rs::test_csp_isolation_from_replay_snapshot_failures"
      ]
    },
    {
      "id": "S13-001",
      "priority": 99,
      "phase": 4,
      "slice": 13,
      "slice_ref": "Slice 13 \u2014 Replay Gatekeeper \\+ Canary \\+ Reviews \\+ Retention \\+ F1 Cert",
      "story_ref": "S13.2 \u2014 Disk retention \\+ watermarks (Patch A semantics)",
      "category": "hardening",
      "description": "Implement S13.2 (Disk retention + watermarks (Patch A semantics)) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 13 \u2014 Replay Gatekeeper + Canary + Reviews + Retention + F1 Cert",
        "S13.2 \u2014 Disk retention + watermarks (Patch A semantics)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src",
          "crates/soldier_core/src"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "80% disk: pause full tick/L2 archives only; Decision Snapshots continue; does NOT force Degraded by itself.",
        "85% disk: force ReduceOnly (Degraded).",
        "92% disk: Kill."
      ],
      "steps": [
        "Map S13.2 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S13.2 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add focused tests for the story and ensure they fail before implementation and pass after the change.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "Targeted checks for S13-001 pass in verification output.",
        "PRD entry S13-001 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": []
    },
    {
      "id": "S13-002",
      "priority": 98,
      "phase": 4,
      "slice": 13,
      "slice_ref": "Slice 13 \u2014 Replay Gatekeeper \\+ Canary \\+ Reviews \\+ Retention \\+ F1 Cert",
      "story_ref": "S13.3 \u2014 Canary rollout (Shadow\u2192Canary\u2192Full) \\+ abort/rollback",
      "category": "hardening",
      "description": "Implement S13.3 (Canary rollout (Shadow\u2192Canary\u2192Full) + abort/rollback) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-035",
        "AT-036",
        "AT-435",
        "AT-972",
        "AT-973"
      ],
      "plan_refs": [
        "Slice 13 \u2014 Replay Gatekeeper + Canary + Reviews + Retention + F1 Cert",
        "S13.3 \u2014 Canary rollout (Shadow\u2192Canary\u2192Full) + abort/rollback"
      ],
      "scope": {
        "touch": [
          "python"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN S13.3 requirements are implemented WHEN targeted checks run THEN behavior is deterministic and fail-closed.",
        "GIVEN contract AT coverage for S13.3 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S13.3 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S13.3 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S13.3 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S13.3: python/tests/test_canary_rollout.py::test_canary_rollout_aborts_on_slippage, python/tests/test_canary_rollout.py::test_canary_rollout_missing_thresholds_aborts, python/tests/test_canary_rollout.py::test_canary_rollout_aborts_when_slippage_exceeds_limit.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "python -m pytest python/tests/test_canary_rollout.py::test_canary_rollout_aborts_on_slippage output",
        "python -m pytest python/tests/test_canary_rollout.py::test_canary_rollout_missing_thresholds_aborts output",
        "PRD entry S13-002 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S13.3 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1349",
          "anchor": "AT-035"
        }
      ],
      "enforcing_contract_ats": [
        "AT-035",
        "AT-036",
        "AT-435",
        "AT-437",
        "AT-972",
        "AT-973"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-035",
          "AT-036"
        ]
      },
      "implementation_tests": [
        "python/tests/test_canary_rollout.py::test_canary_rollout_aborts_on_slippage",
        "python/tests/test_canary_rollout.py::test_canary_rollout_missing_thresholds_aborts",
        "python/tests/test_canary_rollout.py::test_canary_rollout_aborts_when_slippage_exceeds_limit",
        "python/tests/test_canary_rollout.py::test_canary_rollout_aborts_when_evidence_chain_exceeds_abort_window",
        "python/tests/test_canary_rollout.py::test_canary_rollout_does_not_abort_on_evidence_chain_threshold",
        "python/tests/test_canary_rollout.py::test_canary_rollout_fails_preflight_on_miscalibrated_evidence_abort",
        "python/tests/test_canary_rollout.py::test_canary_rollout_does_not_abort_within_recovery_horizon"
      ]
    },
    {
      "id": "S13-003",
      "priority": 97,
      "phase": 4,
      "slice": 13,
      "slice_ref": "Slice 13 \u2014 Replay Gatekeeper \\+ Canary \\+ Reviews \\+ Retention \\+ F1 Cert",
      "story_ref": "S13.4 \u2014 AutoReviewer daily \\+ incident reports \\+ human approval gate",
      "category": "hardening",
      "description": "Implement S13.4 (AutoReviewer daily + incident reports + human approval gate) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch"
      ],
      "plan_refs": [
        "Slice 13 \u2014 Replay Gatekeeper + Canary + Reviews + Retention + F1 Cert",
        "S13.4 \u2014 AutoReviewer daily + incident reports + human approval gate"
      ],
      "scope": {
        "touch": [
          "python"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN S13.4 requirements are implemented WHEN targeted checks run THEN behavior is deterministic and fail-closed.",
        "GIVEN contract AT coverage for S13.4 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S13.4 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S13.4 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S13.4 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S13.4: python/tests/test_reviewer.py::test_autoreviewer_blocks_aggressive_without_human_approval.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "python -m pytest python/tests/test_reviewer.py::test_autoreviewer_blocks_aggressive_without_human_approval output",
        "PRD entry S13-003 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-023"
        ]
      },
      "implementation_tests": [
        "python/tests/test_reviewer.py::test_autoreviewer_blocks_aggressive_without_human_approval"
      ]
    },
    {
      "id": "S13-004",
      "priority": 96,
      "phase": 4,
      "slice": 13,
      "slice_ref": "Slice 13 \u2014 Replay Gatekeeper \\+ Canary \\+ Reviews \\+ Retention \\+ F1 Cert",
      "story_ref": "S13.5 \u2014 F1 cert generation \\+ CI gate",
      "category": "hardening",
      "description": "Implement S13.5 (F1 cert generation + CI gate) with contract-aligned behavior and deterministic tests.",
      "contract_refs": [
        "TradingMode",
        "ReduceOnly",
        "Open Permission Latch",
        "AT-113",
        "AT-990",
        "AT-1056",
        "AT-1057"
      ],
      "plan_refs": [
        "Slice 13 \u2014 Replay Gatekeeper + Canary + Reviews + Retention + F1 Cert",
        "S13.5 \u2014 F1 cert generation + CI gate"
      ],
      "scope": {
        "touch": [
          "python",
          "crates/soldier_core/tests"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN S13.5 requirements are implemented WHEN targeted checks run THEN behavior is deterministic and fail-closed.",
        "GIVEN contract AT coverage for S13.5 WHEN regression tests execute THEN required guard behavior is enforced before dispatch.",
        "GIVEN adverse inputs for S13.5 WHEN evaluation runs THEN OPEN paths are blocked unless all safety conditions pass."
      ],
      "steps": [
        "Map S13.5 contract obligations and implementation-plan acceptance criteria into executable checks.",
        "Implement S13.5 logic in the smallest practical surface area while preserving fail-closed behavior.",
        "Add/adjust targeted tests for S13.5: python/tests/test_f1_certify.py::test_f1_cert_fail_on_atomic_naked_event, python/tests/test_f1_certify.py::test_runtime_config_hash_canonicalization, crates/soldier_core/tests/test_profile_isolation.rs::test_csp_only_build_starts_and_reports_csp.",
        "Wire reason codes, state transitions, and observability fields required for operator-visible diagnostics.",
        "Run verification commands and archive artifact evidence before setting passes=true."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "python -m pytest python/tests/test_f1_certify.py::test_f1_cert_fail_on_atomic_naked_event output",
        "python -m pytest python/tests/test_f1_certify.py::test_runtime_config_hash_canonicalization output",
        "PRD entry S13-004 records contract AT and test mappings for this story."
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": false,
      "contract_must_evidence": [
        {
          "quote": "S13.5 contract tests must pass before enabling OPEN behavior.",
          "location": "specs/IMPLEMENTATION_PLAN.md:1417",
          "anchor": "AT-113"
        }
      ],
      "enforcing_contract_ats": [
        "AT-113",
        "AT-990",
        "AT-1056",
        "AT-1057"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "trading_mode",
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-113",
          "AT-990"
        ]
      },
      "implementation_tests": [
        "python/tests/test_f1_certify.py::test_f1_cert_fail_on_atomic_naked_event",
        "python/tests/test_f1_certify.py::test_runtime_config_hash_canonicalization",
        "crates/soldier_core/tests/test_profile_isolation.rs::test_csp_only_build_starts_and_reports_csp"
      ]
    }
  ]
}
